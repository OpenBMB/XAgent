{
    "run.py": {
        "parse_args": {
            "type": "FunctionDef",
            "name": "parse_args",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 38,
            "parent": null,
            "have_return": true,
            "code_content": "def parse_args() -> argparse.Namespace:\n    \"\"\"\n    Parse the command line arguments and return them as an argparse.Namespace object.\n\n    Returns:\n        argparse.Namespace: An object containing command line arguments and their values.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"--task\", type=str, required=True, help=\"The task description.\")\n    parser.add_argument(\"--upload-files\", nargs='+', dest=\"upload_files\", help=\"List of files to upload.\")\n    parser.add_argument(\"--model\", type=str, help=\"Model identifier for the task.\")\n    parser.add_argument(\"--record-dir\", type=str, dest=\"record_dir\", help=\"Directory to record task execution logs.\")\n    parser.add_argument(\"--mode\", type=str, default=\"auto\", help=\"Operational mode: 'auto' or 'manual'.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", default=False, help=\"Run in quiet mode; minimal output.\")\n    parser.add_argument(\"--max-subtask-chain-length\", type=int, dest=\"max_subtask_chain_length\",\n                        help=\"Maximum length of subtask chain.\")\n    parser.add_argument(\"--enable-ask-human-for-help\", action=\"store_true\", dest=\"enable_ask_human_for_help\",\n                        help=\"Flag to enable asking for human assistance.\")\n    parser.add_argument(\"--max-plan-refine-chain-length\", type=int, dest=\"max_plan_refine_chain_length\",\n                        help=\"Maximum length of plan refinement chain.\")\n    parser.add_argument(\"--max-plan-tree-depth\", type=int, dest=\"max_plan_tree_depth\",\n                        help=\"Maximum depth of the plan tree.\")\n    parser.add_argument(\"--max-plan-tree-width\", type=int, dest=\"max_plan_tree_width\",\n                        help=\"Maximum width of the plan tree.\")\n    parser.add_argument(\"--max-retry-times\", type=int, dest=\"max_retry_times\", help=\"Maximum number of retry attempts.\")\n    parser.add_argument(\"--config-file\", type=str, default=os.getenv('CONFIG_FILE', 'assets/config.yml'),\n                        dest=\"config_file\", help=\"Path to the configuration file.\")\n\n    return parser.parse_args()\n",
            "name_column": 4
        },
        "execute_command_line_process": {
            "type": "FunctionDef",
            "name": "execute_command_line_process",
            "md_content": "",
            "code_start_line": 41,
            "code_end_line": 66,
            "parent": null,
            "have_return": false,
            "code_content": "def execute_command_line_process(args: argparse.Namespace, quiet_mode: bool = False) -> None:\n    \"\"\"\n    Execute the command line process based on the parsed arguments. If quiet mode is enabled,\n    redirect stdout to a file specified by the recorder's record_root_dir.\n\n    Args:\n        args (argparse.Namespace): Parsed command line arguments.\n        quiet_mode (bool): Whether to run in quiet mode, outputting to a file instead of the terminal.\n    \"\"\"\n    args_dict = vars(args)\n    for key, value in args_dict.items():\n        if value is not None:\n            if key == 'model':\n                ARGS['default_completion_kwargs'] = deepcopy(CONFIG['default_completion_kwargs'])\n                ARGS['default_completion_kwargs']['model'] = value\n            else:\n                ARGS[key] = value\n\n    # Redirect stdout to a file if quiet mode is true\n    if quiet_mode:\n        from XAgent.running_recorder import recorder\n        record_file_path = os.path.join(recorder.record_root_dir, \"command_line.ansi\")\n        with open(record_file_path, \"w\", encoding=\"utf-8\") as file, redirect_stdout(file):\n            start_command_line(args_dict)\n    else:\n        start_command_line(args_dict)\n",
            "name_column": 4
        },
        "start_command_line": {
            "type": "FunctionDef",
            "name": "start_command_line",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 83,
            "parent": null,
            "have_return": false,
            "code_content": "def start_command_line(args_dict: dict) -> None:\n    \"\"\"\n    Start the command line interface with the provided arguments.\n\n    Args:\n        args_dict (dict): A dictionary of command line arguments.\n    \"\"\"\n    param = CommandLineParam(\n        task=args_dict['task'],\n        upload_files=args_dict.get('upload_files'),\n        role=\"Assistant\",\n        mode=args_dict[\"mode\"],\n    )\n    cmd = CommandLine(param)\n    cmd.start()\n",
            "name_column": 4
        }
    },
    "command.py": {
        "get_db": {
            "type": "FunctionDef",
            "name": "get_db",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 45,
            "parent": null,
            "have_return": false,
            "code_content": "def get_db():\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n",
            "name_column": 4
        },
        "CommandLineParam": {
            "type": "ClassDef",
            "name": "CommandLineParam",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 85,
            "parent": null,
            "have_return": false,
            "code_content": "class CommandLineParam:\n    \"\"\"Command line parameters.\n    \n    Attributes:\n            task: Task description.\n            role: Role name (default is \"Assistant\").\n            plan: List of steps to perform (default is empty list).\n            upload_files: List of files to upload (default is empty list).\n            download_files: List of files to download (default is empty list).\n            record_dir: Directory to store records (default is `None`).\n            mode: Run mode. Can be \"auto\" (default is \"auto\").\n            max_wait_seconds: Maximum wait time in seconds (default is 600).\n            description: Description of the interaction (default is \"XAgent-Test\").\n            agent: Agent name (default is \"XAgent\").\n    \"\"\"\n    def __init__(self,\n                 task,\n                role=\"Assistant\",\n                plan=[],\n                upload_files: List[str] = [],\n                download_files: List[str] = [],\n                record_dir: str = None,\n                mode: str = \"auto\",\n                max_wait_seconds: int = 600,\n                description: str = \"XAgent-Test\",\n                agent: str = \"XAgent\",\n                ):\n        self.task = task\n        self.plan = plan\n        self.role = role\n        self.upload_files = upload_files\n        self.download_files = download_files\n        self.record_dir = record_dir\n        # auto is supported only in cmd\n        self.mode = \"auto\"\n        self.max_wait_seconds = max_wait_seconds\n        self.description = description\n        self.agent = agent\n",
            "name_column": 6
        },
        "CommandLine": {
            "type": "ClassDef",
            "name": "CommandLine",
            "md_content": "",
            "code_start_line": 88,
            "code_end_line": 290,
            "parent": null,
            "have_return": false,
            "code_content": "class CommandLine():\n    \"\"\"\n    A command-line interface for interacting with XAgentServer.\n\n    Attributes:\n        env: An instance of the XAgentServer environment.\n        client_id: A unique identifier for the client, generated as a hexadecimal UUID.\n        date_str: The current date as a string in YYYY-MM-DD format.\n        log_dir: The directory where the logs are stored.\n        logger: An instance of the Logger used for logging interactions.\n        interactionDB: A database interface for interacting with either a persistent\n            database (SQLite, MySQL, PostgreSQL) or a local storage file, depending\n            on the configuration of `env`.\n    \"\"\"\n\n    def __init__(self, args: CommandLineParam = None):\n        \"\"\"\n        Initialize the CommandLine instance.\n\n        Args:\n            args (CommandLineParam) : parameters.\n            task is required,\n            mode options: [\"auto\"]\n        \"\"\"\n\n        self.args = args\n        self.client_id = uuid.uuid4().hex\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\"interact.log\")\n\n        self.logger.typewriter_log(\n            title=f\"XAgentServer is running on cmd mode\",\n            title_color=Fore.RED)\n        self.logger.info(title=f\"XAgentServer log:\",\n                         title_color=Fore.RED, message=f\"{self.log_dir}\")\n        self.interrupt = self.args.mode != \"auto\"\n        self.init_conv_env()\n        self.max_wait_seconds = self.args.max_wait_seconds\n        self.scheduler = AsyncIOScheduler()\n        self.input = None\n        if self.interrupt:\n            self.input = CommandLineInput(\n                do_interrupt=True,\n                max_wait_seconds=self.max_wait_seconds,\n                logger=self.logger)\n\n    def init_conv_env(self):\n        \"\"\"initialize the conversation environment, \n        Share the same database resource with webui.\n        If you have initiated a session on the front end but it has not been executed, \n        this ID will be shared.\n        \"\"\"\n        user_id = \"guest\"\n        token = \"xagent\"\n        description = self.args.description\n        upload_files = self.args.upload_files\n        record_dir = self.args.record_dir\n        agent = self.args.agent\n        goal = self.args.task\n        mode = self.args.mode\n        plan = self.args.plan\n\n        with get_db() as db:\n            interaction = InteractionCRUD.get_ready_interaction(\n                db=db, user_id=user_id)\n            self.continue_flag = True\n            upload_files = upload_files if upload_files else []\n            file_list = []\n            for file in upload_files:\n                file_list.append({\n                    \"uuid\": file,\n                    \"name\": file\n                })\n            if interaction is None:\n\n                base = InteractionBase(interaction_id=self.client_id,\n                                       user_id=user_id,\n                                       create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       description=description,\n                                       agent=agent,\n                                       mode=mode,\n                                       file_list=file_list,\n                                       recorder_root_dir=\"\",\n                                       status=\"ready\",\n                                       message=\"ready...\",\n                                       current_step=\"-1\",\n                                       update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       call_method=\"cmd\")\n                InteractionCRUD.create_interaction(db=db, base=base)\n            else:\n                self.client_id = interaction.interaction_id\n            \n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args={\n                    \"goal\": goal,\n                    \"plan\": plan\n                    },\n            )\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\n\n\n    def run(self):\n        \"\"\"\n        Runs the interaction with the XAgentServer with the provided arguments.\n        \"\"\"\n\n        # Create a new raw data to record\n        with get_db() as db:\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=self.interrupt,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data={\"goal\": self.args.task, \"plan\": self.args.plan},\n                human_file_list=self.args.upload_files,\n                is_send=True,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n            \n            parameter = InteractionCRUD.get_init_parameter(\n                db=db, interaction_id=self.client_id)\n        \n        self.task_handler(parameter=parameter)\n\n    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            with get_db() as db:\n                base = InteractionCRUD.get_interaction(db=db,\n                                                    interaction_id=self.client_id)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=base.interaction_id,\n                                                        status=\"running\",\n                                                        message=\"running\",\n                                                        current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\",\n                call_method=\"cmd\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            with get_db() as db:\n                InteractionCRUD.insert_error(\n                    db=db, interaction_id=self.client_id, message=str(e))\n                redis.set_key(self.client_id + \"_send\", 1)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=self.client_id,\n                                                        status=\"failed\",\n                                                        message=str(e),\n                                                        current_step=current_step)\n        \n    def start(self):\n\n        self.run()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 103,
            "code_end_line": 137,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def __init__(self, args: CommandLineParam = None):\n        \"\"\"\n        Initialize the CommandLine instance.\n\n        Args:\n            args (CommandLineParam) : parameters.\n            task is required,\n            mode options: [\"auto\"]\n        \"\"\"\n\n        self.args = args\n        self.client_id = uuid.uuid4().hex\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\"interact.log\")\n\n        self.logger.typewriter_log(\n            title=f\"XAgentServer is running on cmd mode\",\n            title_color=Fore.RED)\n        self.logger.info(title=f\"XAgentServer log:\",\n                         title_color=Fore.RED, message=f\"{self.log_dir}\")\n        self.interrupt = self.args.mode != \"auto\"\n        self.init_conv_env()\n        self.max_wait_seconds = self.args.max_wait_seconds\n        self.scheduler = AsyncIOScheduler()\n        self.input = None\n        if self.interrupt:\n            self.input = CommandLineInput(\n                do_interrupt=True,\n                max_wait_seconds=self.max_wait_seconds,\n                logger=self.logger)\n",
            "name_column": 8
        },
        "init_conv_env": {
            "type": "FunctionDef",
            "name": "init_conv_env",
            "md_content": "",
            "code_start_line": 139,
            "code_end_line": 193,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def init_conv_env(self):\n        \"\"\"initialize the conversation environment, \n        Share the same database resource with webui.\n        If you have initiated a session on the front end but it has not been executed, \n        this ID will be shared.\n        \"\"\"\n        user_id = \"guest\"\n        token = \"xagent\"\n        description = self.args.description\n        upload_files = self.args.upload_files\n        record_dir = self.args.record_dir\n        agent = self.args.agent\n        goal = self.args.task\n        mode = self.args.mode\n        plan = self.args.plan\n\n        with get_db() as db:\n            interaction = InteractionCRUD.get_ready_interaction(\n                db=db, user_id=user_id)\n            self.continue_flag = True\n            upload_files = upload_files if upload_files else []\n            file_list = []\n            for file in upload_files:\n                file_list.append({\n                    \"uuid\": file,\n                    \"name\": file\n                })\n            if interaction is None:\n\n                base = InteractionBase(interaction_id=self.client_id,\n                                       user_id=user_id,\n                                       create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       description=description,\n                                       agent=agent,\n                                       mode=mode,\n                                       file_list=file_list,\n                                       recorder_root_dir=\"\",\n                                       status=\"ready\",\n                                       message=\"ready...\",\n                                       current_step=\"-1\",\n                                       update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       call_method=\"cmd\")\n                InteractionCRUD.create_interaction(db=db, base=base)\n            else:\n                self.client_id = interaction.interaction_id\n            \n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args={\n                    \"goal\": goal,\n                    \"plan\": plan\n                    },\n            )\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "",
            "code_start_line": 196,
            "code_end_line": 228,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def run(self):\n        \"\"\"\n        Runs the interaction with the XAgentServer with the provided arguments.\n        \"\"\"\n\n        # Create a new raw data to record\n        with get_db() as db:\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=self.interrupt,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data={\"goal\": self.args.task, \"plan\": self.args.plan},\n                human_file_list=self.args.upload_files,\n                is_send=True,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n            \n            parameter = InteractionCRUD.get_init_parameter(\n                db=db, interaction_id=self.client_id)\n        \n        self.task_handler(parameter=parameter)\n",
            "name_column": 8
        },
        "task_handler": {
            "type": "FunctionDef",
            "name": "task_handler",
            "md_content": "",
            "code_start_line": 230,
            "code_end_line": 286,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            with get_db() as db:\n                base = InteractionCRUD.get_interaction(db=db,\n                                                    interaction_id=self.client_id)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=base.interaction_id,\n                                                        status=\"running\",\n                                                        message=\"running\",\n                                                        current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\",\n                call_method=\"cmd\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            with get_db() as db:\n                InteractionCRUD.insert_error(\n                    db=db, interaction_id=self.client_id, message=str(e))\n                redis.set_key(self.client_id + \"_send\", 1)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=self.client_id,\n                                                        status=\"failed\",\n                                                        message=str(e),\n                                                        current_step=current_step)\n",
            "name_column": 8
        },
        "start": {
            "type": "FunctionDef",
            "name": "start",
            "md_content": "",
            "code_start_line": 288,
            "code_end_line": 290,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def start(self):\n\n        self.run()\n",
            "name_column": 8
        }
    },
    "command_input.py": {
        "timer": {
            "type": "FunctionDef",
            "name": "timer",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "def timer(func):\n    \"\"\"\n    Decorator function to time the execution of a function.\n\n    Args:\n        func (Function): The function to be timed.\n\n    Returns:\n        wrapper (Function): The wrapped function with added timing functionality.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n        except:\n            pass\n    return wrapper\n",
            "name_column": 4
        },
        "CommandLineInput": {
            "type": "ClassDef",
            "name": "CommandLineInput",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 153,
            "parent": null,
            "have_return": true,
            "code_content": "class CommandLineInput:\n    \"\"\"\n    Class for handling command line input.\n\n    This child class extends from BaseInput and implements methods to handle and manage command line input data.\n\n    Attributes:\n        do_interrupt (bool): If True, input will be interrupted.\n        max_wait_seconds (int): Maximum wait time for input in seconds.\n    \"\"\"\n    def __init__(self,\n                 do_interrupt: bool = False,\n                 max_wait_seconds: int = 600,\n                 logger=None):\n        self.do_interrupt = do_interrupt\n        self.max_wait_seconds = max_wait_seconds\n        self.logger = logger\n\n    def run(self, input_data):\n        \"\"\"\n        Run the command line input method.\n\n        Args:\n            input_data (Any): The original input data to be processed.\n\n        Returns:\n            data (Any): The processed input data.\n        \"\"\"\n        if self.do_interrupt:\n            data = self.interrupt(input_data)\n        else:\n            data = input_data\n        return data\n    \n    def get_each_input(self, key, value, res, timeout):\n        \"\"\"\n        Returns the input from the command line for a single key-value pair.\n\n        Args:\n            key (str): The key for which to get input.\n            value (Any): The current value associated with the key.\n            res (dict): The result dictionary where inputs collected will be stored.\n            timeout (int): Timeout in seconds for the input.\n\n        Returns:\n            Any: The input data.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"Now, ASK For {key}, Origin Input: {value}\",\n            Fore.RED,\n            f\"\"\n        )\n        self.logger.typewriter_log(\n            f\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\",\n            Fore.GREEN\n        )\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\n', timeout=timeout)\n        if temp == \"-1\":\n            return value\n        else:\n            return temp\n        \n    def get_input(self, origin_data):\n        \"\"\"\n        Get input for all fields of the original data from the command line.\n\n        Args:\n            origin_data (dict): The original data for which to get input.\n\n        Returns:\n            dict: The dictionary with updated inputs.\n        \"\"\"\n        self.logger.typewriter_log(\n                \"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\",\n                Fore.RED\n            )\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\n', timeout=60)\n        res = {\"args\": {}}\n        if update in ['y', 'Y', 'yes']:\n            execute_time = self.max_wait_seconds\n            if isinstance(origin_data, dict):\n                args = origin_data.get(\"args\", \"\")\n                self.logger.typewriter_log(\n                    f\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\",\n                    Fore.RED,\n                )\n                for key, value in args.items():\n                    if key == \"done\":\n                        res[key] = False\n                        continue\n                    start_time = time.time()\n                    res[\"args\"][key] = self.get_each_input(key, value, res, execute_time)\n                    end_time = time.time()\n                    execute_time = math.floor(execute_time - (end_time - start_time))\n            self.logger.info(f\"modify the input, receive the data: {res}\")\n        else:\n            res = origin_data\n            self.logger.info(\"skip this step\")\n        self.logger.info(\"continue the loop\")\n        res[\"done\"] = True\n        return res\n    \n    def interrupt(self, input_data):\n        \"\"\"\n        Interrupts the current input process and returns the current data.\n\n        Args:\n            input_data (dict): The original input data.\n\n        Returns:\n            dict: The current data collected so far.\n\n        Raises:\n            XAgentIOTimeoutError: If the input times out.\n        \"\"\"\n        try:\n            data = self.get_input(input_data)\n            return data\n        except TimeoutOccurred:\n            self.logger.error(f\"Waiting timemout, close connection!\")\n            raise XAgentTimeoutError(\"timeout!\")",
            "name_column": 6
        },
        "wrapper": {
            "type": "FunctionDef",
            "name": "wrapper",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 29,
            "parent": "timer",
            "have_return": false,
            "code_content": "    def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n        except:\n            pass\n",
            "name_column": 8
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 43,
            "code_end_line": 49,
            "parent": "CommandLineInput",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 do_interrupt: bool = False,\n                 max_wait_seconds: int = 600,\n                 logger=None):\n        self.do_interrupt = do_interrupt\n        self.max_wait_seconds = max_wait_seconds\n        self.logger = logger\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 65,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def run(self, input_data):\n        \"\"\"\n        Run the command line input method.\n\n        Args:\n            input_data (Any): The original input data to be processed.\n\n        Returns:\n            data (Any): The processed input data.\n        \"\"\"\n        if self.do_interrupt:\n            data = self.interrupt(input_data)\n        else:\n            data = input_data\n        return data\n",
            "name_column": 8
        },
        "get_each_input": {
            "type": "FunctionDef",
            "name": "get_each_input",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 93,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def get_each_input(self, key, value, res, timeout):\n        \"\"\"\n        Returns the input from the command line for a single key-value pair.\n\n        Args:\n            key (str): The key for which to get input.\n            value (Any): The current value associated with the key.\n            res (dict): The result dictionary where inputs collected will be stored.\n            timeout (int): Timeout in seconds for the input.\n\n        Returns:\n            Any: The input data.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"Now, ASK For {key}, Origin Input: {value}\",\n            Fore.RED,\n            f\"\"\n        )\n        self.logger.typewriter_log(\n            f\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\",\n            Fore.GREEN\n        )\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\n', timeout=timeout)\n        if temp == \"-1\":\n            return value\n        else:\n            return temp\n",
            "name_column": 8
        },
        "get_input": {
            "type": "FunctionDef",
            "name": "get_input",
            "md_content": "",
            "code_start_line": 95,
            "code_end_line": 133,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def get_input(self, origin_data):\n        \"\"\"\n        Get input for all fields of the original data from the command line.\n\n        Args:\n            origin_data (dict): The original data for which to get input.\n\n        Returns:\n            dict: The dictionary with updated inputs.\n        \"\"\"\n        self.logger.typewriter_log(\n                \"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\",\n                Fore.RED\n            )\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\n', timeout=60)\n        res = {\"args\": {}}\n        if update in ['y', 'Y', 'yes']:\n            execute_time = self.max_wait_seconds\n            if isinstance(origin_data, dict):\n                args = origin_data.get(\"args\", \"\")\n                self.logger.typewriter_log(\n                    f\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\",\n                    Fore.RED,\n                )\n                for key, value in args.items():\n                    if key == \"done\":\n                        res[key] = False\n                        continue\n                    start_time = time.time()\n                    res[\"args\"][key] = self.get_each_input(key, value, res, execute_time)\n                    end_time = time.time()\n                    execute_time = math.floor(execute_time - (end_time - start_time))\n            self.logger.info(f\"modify the input, receive the data: {res}\")\n        else:\n            res = origin_data\n            self.logger.info(\"skip this step\")\n        self.logger.info(\"continue the loop\")\n        res[\"done\"] = True\n        return res\n",
            "name_column": 8
        },
        "interrupt": {
            "type": "FunctionDef",
            "name": "interrupt",
            "md_content": "",
            "code_start_line": 135,
            "code_end_line": 153,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def interrupt(self, input_data):\n        \"\"\"\n        Interrupts the current input process and returns the current data.\n\n        Args:\n            input_data (dict): The original input data.\n\n        Returns:\n            dict: The current data collected so far.\n\n        Raises:\n            XAgentIOTimeoutError: If the input times out.\n        \"\"\"\n        try:\n            data = self.get_input(input_data)\n            return data\n        except TimeoutOccurred:\n            self.logger.error(f\"Waiting timemout, close connection!\")\n            raise XAgentTimeoutError(\"timeout!\")",
            "name_column": 8
        }
    },
    "setup.py": {},
    "start_server.py": {},
    "ToolServer/ToolServerManager/config.py": {
        "ManagerConfig": {
            "type": "ClassDef",
            "name": "ManagerConfig",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 63,
            "parent": null,
            "have_return": true,
            "code_content": "class ManagerConfig:\n    \"\"\"\n    This class manages configuration settings for the application.\n    Configuration settings are initially loaded from a yaml file. \n    However, if an environment variable exists with the same name as a configuration setting, \n    the value from the environment variable will be used instead.\n\n    Attributes:\n        cfg: A dictionary containing all configuration settings.\n    \"\"\"\n\n    def __init__(self, config_file_path=\"./assets/config/manager.yml\"):\n        \"\"\"\n        Initializes a new instance of the ManagerConfig class.\n\n        Args:\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \n            Defaults to \"./assets/config.yml\".\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path,\"r\",encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\n\n    def __getitem__(self, key):\n        \"\"\"\n        Returns the value of a configuration setting.\n\n        Args:\n            key (str): The name of the configuration setting.\n\n        Returns:\n            The value of the configuration setting. \n        \"\"\"\n        return self.cfg[key]\n\n    def dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns all configuration settings.\n\n        Returns:\n            A dictionary containing all configuration settings.\n        \"\"\"\n        return self.cfg\n\n    def update(self, new_config: Dict) -> None:\n        \"\"\"\n        Updates configuration settings with the values from another dictionary.\n\n        Args:\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\n\n        Returns:\n            None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": "ManagerConfig",
            "have_return": false,
            "code_content": "    def __init__(self, config_file_path=\"./assets/config/manager.yml\"):\n        \"\"\"\n        Initializes a new instance of the ManagerConfig class.\n\n        Args:\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \n            Defaults to \"./assets/config.yml\".\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path,\"r\",encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 42,
            "parent": "ManagerConfig",
            "have_return": true,
            "code_content": "    def __getitem__(self, key):\n        \"\"\"\n        Returns the value of a configuration setting.\n\n        Args:\n            key (str): The name of the configuration setting.\n\n        Returns:\n            The value of the configuration setting. \n        \"\"\"\n        return self.cfg[key]\n",
            "name_column": 8
        },
        "dict": {
            "type": "FunctionDef",
            "name": "dict",
            "md_content": "",
            "code_start_line": 44,
            "code_end_line": 51,
            "parent": "ManagerConfig",
            "have_return": true,
            "code_content": "    def dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns all configuration settings.\n\n        Returns:\n            A dictionary containing all configuration settings.\n        \"\"\"\n        return self.cfg\n",
            "name_column": 8
        },
        "update": {
            "type": "FunctionDef",
            "name": "update",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 63,
            "parent": "ManagerConfig",
            "have_return": false,
            "code_content": "    def update(self, new_config: Dict) -> None:\n        \"\"\"\n        Updates configuration settings with the values from another dictionary.\n\n        Args:\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\n\n        Returns:\n            None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerManager/models.py": {
        "ToolServerNode": {
            "type": "ClassDef",
            "name": "ToolServerNode",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 15,
            "parent": null,
            "have_return": false,
            "code_content": "class ToolServerNode(Document):\n    \"\"\"\n    A class that represents a node in the database. \n    \"\"\"\n    id: str\n    short_id: str\n    status: str\n    health: str\n    last_req_time: datetime\n    ip: str\n    port: int\n",
            "name_column": 6
        },
        "NodeChecker": {
            "type": "ClassDef",
            "name": "NodeChecker",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 20,
            "parent": null,
            "have_return": false,
            "code_content": "class NodeChecker(Document):\n    manager_id: str\n    interval: float\n    pid: int",
            "name_column": 6
        }
    },
    "ToolServer/ToolServerManager/connections.py": {},
    "ToolServer/ToolServerManager/main.py": {
        "startup": {
            "type": "AsyncFunctionDef",
            "name": "startup",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 53,
            "parent": null,
            "have_return": false,
            "code_content": "async def startup():\n    \"\"\"\n    Event handler triggered on startup of the app. Sets up necessary configurations \n    like checking and creating table nodes if not exists in databse, creating subprocess \n    to update node status, and registering path to node. \n    \"\"\"\n    \n    from beanie import init_beanie\n    await init_beanie(database=db,\n                      document_models=[ToolServerNode,NodeChecker],)\n    \n    # create subprocess to update node status\n    if CONFIG['builtin_monitor']:\n        from node_checker import check_nodes_status_loop\n        \n        async for checker in NodeChecker.find_all():\n            if not psutil.pid_exists(checker.pid):\n                checker.delete()\n\n        checker = NodeChecker(\n            manager_id=MANAGER_ID,\n            interval=float(CONFIG['node'].get('health_check_interval',1)),\n            pid=os.getpid()\n            )\n        await checker.save()\n\n        asyncio.create_task(check_nodes_status_loop())\n            \n\n    # register path to node\n    for path in CONFIG['redirect_to_node_path']['post']:\n        app.add_api_route(path, route_to_node, methods=[\"POST\"])\n        \n    for path in CONFIG['redirect_to_node_path']['get']:\n        app.add_api_route(path, route_to_node, methods=[\"GET\"])\n",
            "name_column": 10
        },
        "shutdown": {
            "type": "AsyncFunctionDef",
            "name": "shutdown",
            "md_content": "",
            "code_start_line": 56,
            "code_end_line": 63,
            "parent": null,
            "have_return": false,
            "code_content": "async def shutdown():\n    \"\"\"\n    Event handler on shutdown of the app. Specifically closes the database cursor if \n    the database type os sqlite3.\n    \"\"\"\n    async for checker in NodeChecker.find(NodeChecker.manager_id == MANAGER_ID):\n        await checker.delete()\n    db.client.close()\n",
            "name_column": 10
        },
        "alive": {
            "type": "AsyncFunctionDef",
            "name": "alive",
            "md_content": "",
            "code_start_line": 66,
            "code_end_line": 73,
            "parent": null,
            "have_return": true,
            "code_content": "async def alive():\n    \"\"\"\n    Endpoint to check if the service is running.\n\n    Returns:\n        str: \"alive\"\n    \"\"\"\n    return \"alive\"\n",
            "name_column": 10
        },
        "wait_for_node_startup": {
            "type": "AsyncFunctionDef",
            "name": "wait_for_node_startup",
            "md_content": "",
            "code_start_line": 75,
            "code_end_line": 106,
            "parent": null,
            "have_return": true,
            "code_content": "async def wait_for_node_startup(node_id:str):\n    \"\"\"\n    Wait for the startup of node with id node_id. It probes the node status every seconds until \n    creation_wait_seconds reached.\n    \n    Args:\n        node_id (str): The unique identifier of the node whose startup is to be waited for.\n\n    Returns:\n        bool: True if node has started successfully, False if time out occured before node startup.\n    \n    Raises:\n        HTTPException: If node is not found in the databse.\n    \"\"\"\n    MAX_PROBE_TIMES = CONFIG['node']['creation_wait_seconds']\n    probe_times = 0\n    while probe_times < MAX_PROBE_TIMES:\n        node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n            \n        if node is None:\n            raise HTTPException(status_code=503, detail=\"Failed to detect node status! Node not found in db!\")\n        \n        if CONFIG['node']['health_check']:\n            if node.health == 'healthy':\n                return True\n        else:\n            if node.status == \"running\":\n                return True\n            \n        probe_times += 1\n        await asyncio.sleep(1)\n    return False\n",
            "name_column": 10
        },
        "read_cookie_info": {
            "type": "AsyncFunctionDef",
            "name": "read_cookie_info",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 150,
            "parent": null,
            "have_return": true,
            "code_content": "async def read_cookie_info():\n    \"\"\"\n    Fetch server version and node info, create docker container and set the response cookies \n    with the key \"node_id\" and value as the id of the created container. Also, adds the created \n    node's details to the databse and waits for the node to startup.\n\n    Returns:\n        JSONResponse: A response object with status, headers and cookies set accordingly.\n\n    Raises:\n        HTTPException: If node creation timeout occurs.\n    \"\"\"\n    # append server version info\n    content = {\"message\": \"add cookie\",\"version\":CONFIG['version']}\n    response = JSONResponse(content=content)\n    response.headers[\"Server\"] = \"ToolServerManager/\" + CONFIG['version']\n    \n    # create a docker container\n    container = docker_client.containers.run(\n        device_requests=[docker.types.DeviceRequest(**req) for req in CONFIG['node']['device_requests']] if CONFIG['node']['device_requests'] else None,\n        **(CONFIG['node']['creation_kwargs']),)\n    logger.info(\"Node created: \" + container.id)\n    response.set_cookie(key=\"node_id\", value=container.id)\n    container.reload()\n    \n    node = ToolServerNode(\n        id=container.id,\n        short_id=container.short_id,\n        status=container.attrs[\"State\"][\"Status\"],\n        ip=container.attrs[\"NetworkSettings\"][\"Networks\"][CONFIG['node']['creation_kwargs']['network']][\"IPAddress\"],\n        port=CONFIG['node'].get('port',31942),\n        last_req_time=datetime.datetime.utcnow(),\n        health=container.attrs['State']['Health']['Status'] if CONFIG['node']['health_check'] else None\n    )\n    await node.insert()\n\n    # probe node status every seconds until creation_wait_seconds reached\n    if await wait_for_node_startup(container.id):\n        return response\n    else:\n        logger.warning(\"Node status detection timeout: \" + container.id)\n        raise HTTPException(status_code=503, detail=\"Node creation timeout!\")\n",
            "name_column": 10
        },
        "reconnect_session": {
            "type": "AsyncFunctionDef",
            "name": "reconnect_session",
            "md_content": "",
            "code_start_line": 153,
            "code_end_line": 179,
            "parent": null,
            "have_return": true,
            "code_content": "async def reconnect_session(node_id:str = Cookie(None)):\n    \"\"\"\n    Reconnect session of a node. Fetches node info and restarts the node if it exists.\n\n    Args:\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\n\n    Returns:\n        str: Success message if node restarts successfully.\n    \n    Raises:\n        HTTPException: If node restart timeout occurs.\n    \"\"\"\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        return \"invalid node_id: \" + str(node_id)\n    # restart node\n    container = docker_client.containers.get(node_id)\n    if container is not None:\n        container.restart()\n        logger.info(\"Node restarted: \" + node_id)\n    \n    if await wait_for_node_startup(node_id):\n        return \"Reconnect session: \" + str(node_id)\n    else:\n        logger.warning(\"Node restart timeout: \" + node_id)\n        raise HTTPException(status_code=503, detail=\"Node restart timeout!\")\n",
            "name_column": 10
        },
        "close_session": {
            "type": "AsyncFunctionDef",
            "name": "close_session",
            "md_content": "",
            "code_start_line": 182,
            "code_end_line": 200,
            "parent": null,
            "have_return": true,
            "code_content": "async def close_session(node_id:str = Cookie(None)):\n    \"\"\"\n    Close session of a node. Fetches node info and stops the node if it exists and is not already exited.\n\n    Args:\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\n\n    Returns:\n        str: Success message if node stops successfully.\n    \"\"\"\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        return \"invalid node_id: \" + str(node_id)\n    # stop node\n    container = docker_client.containers.get(node_id)\n    if container is not None and container.attrs[\"State\"][\"Status\"] != \"exit\":\n        container.stop()\n        logger.info(\"Node stopped: \" + node_id)\n    return \"Close session: \" + str(node_id)\n",
            "name_column": 10
        },
        "release_session": {
            "type": "AsyncFunctionDef",
            "name": "release_session",
            "md_content": "",
            "code_start_line": 203,
            "code_end_line": 226,
            "parent": null,
            "have_return": true,
            "code_content": "async def release_session(node_id:str = Cookie(None)):\n    \"\"\"\n    Release session of a node. Fetches node info and kills the node if it exists and is not already exited. \n    Also, removes the node.\n\n    Args:\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\n\n    Returns:\n        str: Success message if node is successfully killed and removed.\n    \"\"\"\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        return \"invalid node_id: \" + str(node_id)\n    \n    # delete node in docker\n    container = docker_client.containers.get(node_id)\n    if container is not None:\n        if container.attrs[\"State\"][\"Status\"] != \"exited\":\n            container.kill()\n            logger.info(\"Node killed: \" + node_id)\n        container.remove()\n        logger.info(\"Node deleted: \" + node_id)\n    return \"Release session: \" + str(node_id)\n",
            "name_column": 10
        },
        "route_to_node": {
            "type": "AsyncFunctionDef",
            "name": "route_to_node",
            "md_content": "",
            "code_start_line": 228,
            "code_end_line": 269,
            "parent": null,
            "have_return": true,
            "code_content": "async def route_to_node(requset:Request,*,node_id:str = Cookie(None)):\n    \"\"\"\n    Routes a request to a specific node. Fetches the node info, checks if it is valid and running. Updates latest \n    request time in the database and then sends a post request to the node.\n    \n    Args:\n        request (Request): The request object containing all request information.\n\n    Returns:\n        Response: The response object containing all response information received from the node.\n\n    Raises:\n        HTTPException: If node_id is not valid or if the node is not running or not responding.\n    \"\"\"\n    # logger.info(\"accept node_id:\",node_id)\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        raise HTTPException(status_code=403,detail=\"invalid node_id: \" + str(node_id)) \n    \n    if node.status != \"running\":\n        raise HTTPException(status_code=503,detail=\"node is not running: \" + str(node_id)) \n\n    # update latest_req_time in db\n    node.last_req_time = datetime.datetime.utcnow()\n    await node.replace()\n        \n    #post request to node\n    method = requset.method\n    headers = dict(requset.headers)\n    body = await requset.body()\n    url = \"http://\" + node.ip +\":\"+str(node.port) + requset.url.path\n    logger.info(\"Request to node: \" + url)\n    \n    async with httpx.AsyncClient(timeout=None) as client:\n        try:\n            response = await client.request(method,url,headers=headers,data=body)\n        except httpx.RequestError:\n            traceback.print_exc()\n            raise HTTPException(status_code=503, detail=\"node is not responding\")\n    logger.info('Response from node: ' + str(response.status_code))\n    res = Response(content=response.content, status_code=response.status_code, headers=response.headers)\n    return res\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerManager/node_checker.py": {
        "check_nodes_status": {
            "type": "AsyncFunctionDef",
            "name": "check_nodes_status",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 54,
            "parent": null,
            "have_return": false,
            "code_content": "async def check_nodes_status():\n    \"\"\"\n    Check the status of all existing nodes from the selected database 'sqlite3' or 'mongodb'.\n    If a node doesn't exist in Docker, it will be deleted from the database. \n\n    Raises:\n        docker.errors.NotFound: Raised when a Node is not found in Docker\n        docker.errors.APIError: Raised when it fails to get Node info from Docker\n    \"\"\"\n    # Check if each node exists in Docker\n    async for node in ToolServerNode.find_all():\n        container = None\n        try:\n            container = docker_client.containers.get(node.id)\n        except docker.errors.NotFound:\n            # Delete from db if not found in Docker\n            await node.delete()\n            logger.info(\"Node deleted from db: \" + node.id + '(not in docker)')\n            continue\n        except docker.errors.APIError:\n            logger.warning(\"Failed to get node info from docker: \" + node['node_id'])\n            continue\n\n        if container is not None:\n            # Update the node state in db\n            node_status = container.attrs[\"State\"][\"Status\"]\n \n            if node_status != node.status:\n                logger.info(f\"Node {node.short_id} status updated: \" + node.status + \" -> \" + node_status)\n            node.status = node_status\n                \n            if CONFIG['node']['health_check']:\n                health = container.attrs['State']['Health']['Status']\n                if health != node.health:\n                    logger.info(f\"Node {node.short_id} health updated: \" + node.health + \" -> \" + health)\n                node.health = health\n                \n            await node.replace()\n\n            # Check if node is running\n            if node_status == \"running\":\n                if datetime.datetime.utcnow() - node.last_req_time >= datetime.timedelta(minutes=CONFIG['node']['idling_close_minutes']):\n                    container.stop()\n                    logger.info(\"Stopping node: \" + node.id + \" due to idling time used up\")\n",
            "name_column": 10
        },
        "check_nodes_status_loop": {
            "type": "AsyncFunctionDef",
            "name": "check_nodes_status_loop",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 68,
            "parent": null,
            "have_return": false,
            "code_content": "async def check_nodes_status_loop():\n    \"\"\"\n    An infinite loop that checks the status of the nodes and waits 1 second before each iteration.\n    \"\"\"\n    logger.info(\"Nodes status checker started.\")\n    while True:\n        try:\n            await check_nodes_status()\n        except:\n            import traceback\n            traceback.print_exc()\n        await asyncio.sleep(CONFIG['node'].get('health_check_interval',1))\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerNode/config.py": {
        "NodeConfig": {
            "type": "ClassDef",
            "name": "NodeConfig",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 71,
            "parent": null,
            "have_return": true,
            "code_content": "class NodeConfig:\n    \"\"\"\n    A class used to load and manage the configurations defined in a specified configuration file and the environment variables.\n\n    Methods\n    -------\n    __getitem__(self, key):\n        Fetches a configuration value for a given key.\n    dict():\n        Returns the entire configuration dictionary.\n    update(new_config: Dict):\n        Updates the configuration dictionary with new configurations.\n    \"\"\"\n    def __init__(self,\n                 config_file_path=\"./assets/config/node.yml\",):\n        \"\"\"\n        The constructor for NodeConfig class that loads the configuration details.\n\n        Args:\n          config_file_path (str, optional): The path to the configuration file. Defaults to \"assets/config.yml\".\n\n        Raises:\n          FileNotFoundError: If specified configuration file path could not be located.\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path, \"r\", encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        \n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\n\n    def __getitem__(self, key):\n        \"\"\"\n        Fetches a configuration value for a given key.\n\n        Args:\n          key (str): The configuration key to fetch value for.\n        \n        Returns:\n          Any: The value of the requested configuration key.\n        \n        Raises:\n          KeyError: If the given key is not found in the configuration.\n        \"\"\"\n        return self.cfg[key]\n    \n    def dict(self)-> Dict[str, Any]:\n        \"\"\"\n        Returns the entire configuration dictionary.\n        \n        Returns:\n          Dict[str, Any]: The entire configuration dictionary.\n        \"\"\"\n        return self.cfg\n\n    def update(self, new_config: Dict)-> None:\n        \"\"\"\n        Updates the configuration dictionary with new configurations.\n\n        Args:\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\n\n        Returns:\n          None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 35,
            "parent": "NodeConfig",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 config_file_path=\"./assets/config/node.yml\",):\n        \"\"\"\n        The constructor for NodeConfig class that loads the configuration details.\n\n        Args:\n          config_file_path (str, optional): The path to the configuration file. Defaults to \"assets/config.yml\".\n\n        Raises:\n          FileNotFoundError: If specified configuration file path could not be located.\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path, \"r\", encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        \n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "",
            "code_start_line": 37,
            "code_end_line": 50,
            "parent": "NodeConfig",
            "have_return": true,
            "code_content": "    def __getitem__(self, key):\n        \"\"\"\n        Fetches a configuration value for a given key.\n\n        Args:\n          key (str): The configuration key to fetch value for.\n        \n        Returns:\n          Any: The value of the requested configuration key.\n        \n        Raises:\n          KeyError: If the given key is not found in the configuration.\n        \"\"\"\n        return self.cfg[key]\n",
            "name_column": 8
        },
        "dict": {
            "type": "FunctionDef",
            "name": "dict",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 59,
            "parent": "NodeConfig",
            "have_return": true,
            "code_content": "    def dict(self)-> Dict[str, Any]:\n        \"\"\"\n        Returns the entire configuration dictionary.\n        \n        Returns:\n          Dict[str, Any]: The entire configuration dictionary.\n        \"\"\"\n        return self.cfg\n",
            "name_column": 8
        },
        "update": {
            "type": "FunctionDef",
            "name": "update",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 71,
            "parent": "NodeConfig",
            "have_return": false,
            "code_content": "    def update(self, new_config: Dict)-> None:\n        \"\"\"\n        Updates the configuration dictionary with new configurations.\n\n        Args:\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\n\n        Returns:\n          None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/main.py": {
        "startup": {
            "type": "FunctionDef",
            "name": "startup",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 33,
            "parent": null,
            "have_return": false,
            "code_content": "def startup():\n    \"\"\"\n    Startup function to initialize the required services and variables for the application.\n    \"\"\"\n    try:\n        # start docker service\n        os.system('service docker start')\n    except:\n        pass\n    app.tool_register = ToolRegister()\n    app.doc_embeddings, app.id2tool = build_tool_embeddings(app.tool_register.get_all_tools_dict(include_invisible=True))\n",
            "name_column": 4
        },
        "root": {
            "type": "AsyncFunctionDef",
            "name": "root",
            "md_content": "",
            "code_start_line": 37,
            "code_end_line": 44,
            "parent": null,
            "have_return": true,
            "code_content": "async def root():\n    \"\"\"\n    Root function that returns a message Hello World.\n    \n    Returns:\n        dict: A dictionary containing a welcoming message.\n    \"\"\"\n    return {\"message\": \"Hello World\"}\n",
            "name_column": 10
        },
        "upload_file": {
            "type": "AsyncFunctionDef",
            "name": "upload_file",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 62,
            "parent": null,
            "have_return": true,
            "code_content": "async def upload_file(file:UploadFile):\n    \"\"\"\n    This function allows the user to upload a file to the work directory defined in configuration file.\n\n    Args:\n        file (fastapi.UploadFile): The file to be uploaded.\n    \n    Returns:\n        dict: A message denoting successful upload of the file.\n    \"\"\"\n    upload_file =  file.file.read()\n    file_name = file.filename\n    work_directory = CONFIG['filesystem']['work_directory']\n    with open(os.path.join(work_directory,file_name),'wb') as f:\n        f.write(upload_file)\n    return {\"message\": \"Upload Success!\"}\n",
            "name_column": 10
        },
        "download_file": {
            "type": "AsyncFunctionDef",
            "name": "download_file",
            "md_content": "",
            "code_start_line": 65,
            "code_end_line": 83,
            "parent": null,
            "have_return": true,
            "code_content": "async def download_file(file_path:str=Body(...),file_type:str=Body(default='text/plain')):\n    \"\"\"\n    This function downloads a file from the work directory.\n\n    Args:\n        file_path (str): The path of the file to be downloaded.\n        file_type (str, optional): Type of the file. Defaults to 'text/plain'.\n    \n    Returns:\n        starlette.responses.FileResponse: File response containing the requested file for user to download.\n    \"\"\"\n    work_directory = CONFIG['filesystem']['work_directory']\n    if file_path.startswith(os.path.basename(work_directory)):\n        file_path = file_path[len(os.path.basename(work_directory))+1:]\n    response = FileResponse(\n        path=os.path.join(work_directory,file_path),\n        filename=os.path.basename(file_path),\n        )\n    return response\n",
            "name_column": 10
        },
        "download_workspace": {
            "type": "AsyncFunctionDef",
            "name": "download_workspace",
            "md_content": "",
            "code_start_line": 86,
            "code_end_line": 105,
            "parent": null,
            "have_return": true,
            "code_content": "async def download_workspace():\n    \"\"\"\n    This function downloads the workspace which is a directory consisting of all the uploaded files. \n    \n    Returns:\n        starlette.responses.FileResponse: File response containing the workspace for the user to download. \n    \"\"\"\n    work_directory = CONFIG['filesystem']['work_directory']\n    zip = zipfile.ZipFile('/tmp/workspace.zip','w',zipfile.ZIP_DEFLATED)\n    for path,dirs,files in os.walk(work_directory):\n        fpath= path.replace(work_directory,'')\n        for file in files:\n            zip.write(os.path.join(path,file),os.path.join(fpath,file))\n    \n    zip.close()\n    response = FileResponse(\n        path=os.path.join(work_directory,'/tmp/workspace.zip'),\n        filename='workspace.zip',\n        )\n    return response\n",
            "name_column": 10
        },
        "get_workspace_structure": {
            "type": "AsyncFunctionDef",
            "name": "get_workspace_structure",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 125,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_workspace_structure():\n    \"\"\"\n    This function generates the structure of the workspace directory.\n    \n    Returns:\n        dict: A dictionary depicting the structure of the workspace directory.\n    \"\"\"\n    work_directory = CONFIG['filesystem']['work_directory']\n    def generate_directory_structure(path):\n        result = {'name':os.path.basename(path)}\n        if os.path.isdir(path):\n            result['type'] = 'directory'\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\n        else:\n            result['type'] = 'file'\n        return result\n    return generate_directory_structure(work_directory)\n",
            "name_column": 10
        },
        "get_available_tools": {
            "type": "AsyncFunctionDef",
            "name": "get_available_tools",
            "md_content": "",
            "code_start_line": 128,
            "code_end_line": 140,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_available_tools():\n    \"\"\"\n    This function returns the available tools and environments registered in the ToolRegister.\n    \n    Returns:\n        dict: A dictionary of available tools, environments and the JSON representation of the tools.\n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    return {\n        \"available_envs\": tool_register.get_all_envs(),\n        \"available_tools\": tool_register.get_all_tools(),\n        \"tools_json\": tool_register.get_all_tools_dict(),\n    }\n",
            "name_column": 10
        },
        "retrieving_tools": {
            "type": "AsyncFunctionDef",
            "name": "retrieving_tools",
            "md_content": "",
            "code_start_line": 143,
            "code_end_line": 173,
            "parent": null,
            "have_return": true,
            "code_content": "async def retrieving_tools(question:str=Body(...), top_k:int=Body(default=5)):\n    \"\"\"\n    This function retrieves the tool names based on a query question using the ADA retriever.\n\n    Args:\n        question (str): The query question for which tools are to be retrieved.\n        top_k (int, optional): The number of top similar tools to be retrieved. Defaults to 5.\n\n    Returns:\n        dict: A dictionary with the list of retrieved tools and JSON representations of the tools.\n\n    Raises:\n        HTTPException: If an error occurs during retrieving the tools.\n    \"\"\"\n    try:\n        retrieved_tools = ada_retriever(app.doc_embeddings, app.id2tool, question, top_k)\n    except Exception as e:\n        error_report =  traceback.format_exc()\n        logger.error(error_report)\n        raise HTTPException(status_code=500, detail=f\"Errorhappens when retrieving tools:\\n{e}\\n\\n\" + error_report)\n    \n    tool_register:ToolRegister = app.tool_register\n    tools_json = []\n    for tool_name in retrieved_tools:\n        if tool_name in tool_register.tools:\n            tools_json.append(tool_register.get_tool_dict(tool_name))\n    \n    return {\n        \"retrieved_tools\":retrieved_tools,\n        \"tools_json\":tools_json,\n    }\n",
            "name_column": 10
        },
        "get_json_schema_for_tool": {
            "type": "AsyncFunctionDef",
            "name": "get_json_schema_for_tool",
            "md_content": "",
            "code_start_line": 177,
            "code_end_line": 199,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_json_schema_for_tool(tool_names:List[str]=Body(...)):\n    \"\"\"\n    This function returns the JSON schema for the given list of tools.\n\n    Args:\n        tool_names (List[str]): List of tool names for which JSON schema is required.\n\n    Returns:\n        dict: JSON schema dictionary for all the available tools and list of error names for missing tools. \n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    \n    error_names = []\n    tools_json = []\n    for tool_name in tool_names:\n        if tool_name not in tool_register.tools:\n            error_names.append(tool_name)\n        else:\n            tools_json.append(tool_register.get_tool_dict(tool_name))\n    return {\n        \"tools_json\": tools_json,\n        \"missing_tools\": error_names,\n    }\n",
            "name_column": 10
        },
        "get_json_schema_for_env": {
            "type": "AsyncFunctionDef",
            "name": "get_json_schema_for_env",
            "md_content": "",
            "code_start_line": 202,
            "code_end_line": 224,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_json_schema_for_env(env_names:List[str]=Body(...)):\n    \"\"\"\n    This function returns the JSON schema for the given list of tool environments.\n\n    Args:\n        env_names (List[str]): List of environment names for which JSON schema is required.\n\n    Returns:\n        dict: JSON schema dictionary for all the available environments and list of error names for missing environments. \n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    \n    error_names = []\n    envs_json = []\n    for env_name in env_names:\n        if env_name not in tool_register.envs:\n            error_names.append(env_name)\n        else:\n            envs_json.append(tool_register.get_env_dict(env_name))\n    return {\n        \"envs_json\": envs_json,\n        \"missing_envs\": error_names,\n    }\n",
            "name_column": 10
        },
        "register_new_tool": {
            "type": "AsyncFunctionDef",
            "name": "register_new_tool",
            "md_content": "",
            "code_start_line": 227,
            "code_end_line": 249,
            "parent": null,
            "have_return": true,
            "code_content": "async def register_new_tool(tool_name:str=Body(...), code:str=Body(...)):\n    \"\"\"\n    This function allows the user to register a new tool by providing the tool name and code.\n\n    Args:\n        tool_name (str): The name of the new tool.\n        code (str): The code for the new tool.\n\n    Returns:\n        dict: A dictionary representing the registered tool.\n\n    Raises:\n        HTTPException: If an error occurs during registering the new tool.\n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    try:\n        tool_dict = tool_register.register_tool(tool_name,code)\n    except Exception as e:\n        error_report =  traceback.format_exc()\n        logger.error(error_report)\n        raise HTTPException(status_code=406, detail=f\"Error happens when registering new tool:\\n{e}\\n\\n\" + error_report)\n    \n    return tool_dict\n",
            "name_column": 10
        },
        "execute_tool": {
            "type": "AsyncFunctionDef",
            "name": "execute_tool",
            "md_content": "",
            "code_start_line": 252,
            "code_end_line": 289,
            "parent": null,
            "have_return": true,
            "code_content": "async def execute_tool(tool_name:str=Body(...), arguments:dict=Body(...), env_name:str=Body(default=None)):\n    \"\"\"\n    This function executes a tool with the provided arguments and environment.\n\n    Args:\n        tool_name (str): The name of the tool to be executed.\n        arguments (dict): The arguments for executing the tool.\n        env_name (str, optional): The name of the tool environment in which tool is to be executed. Defaults to None.\n\n    Returns:\n        dict: The result of executing the tool is wrapped in a dictionary.\n\n    Raises:\n        HTTPException: If an error occurs during tool execution.\n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    \n    try:\n        if env_name is not None:\n            tool = tool_register[env_name,tool_name]\n        else:\n            tool = tool_register[tool_name]\n        result = tool(**arguments)\n        if isinstance(result,Coroutine):\n            result = await result\n        result = wrap_tool_response(result)\n    except ToolNotFound as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except OutputNotReady as e:\n        raise HTTPException(status_code=450, detail=e.next_try())\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        trace_info = traceback.format_exc()\n        logger.error(f'Error happens when executing tool {tool_name}! Exception: {e}\\n{trace_info}')\n        raise HTTPException(status_code=500, detail=trace_info)\n    \n    return result\n",
            "name_column": 10
        },
        "generate_directory_structure": {
            "type": "FunctionDef",
            "name": "generate_directory_structure",
            "md_content": "",
            "code_start_line": 117,
            "code_end_line": 124,
            "parent": "get_workspace_structure",
            "have_return": true,
            "code_content": "    def generate_directory_structure(path):\n        result = {'name':os.path.basename(path)}\n        if os.path.isdir(path):\n            result['type'] = 'directory'\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\n        else:\n            result['type'] = 'file'\n        return result\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/labels.py": {
        "ToolLabels": {
            "type": "ClassDef",
            "name": "ToolLabels",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 70,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolLabels:\n    \"\"\"A class representing a tool.\n\n    When invoked, this object runs the associated method using parameters defined in the signature.\n\n    Attributes:\n        name (str): The name of the tool.\n        description (str): Description of the tool.\n        method (Callable): The function/method that the tool executes.\n        signature (dict): Argument keys and values needed by the method to execute.\n        required (list): List of required arguments for the method.\n        enabled (bool): Flag indicating whether the tool is enabled or not.\n        disabled_reason (str): Reason for disabling the tool, if applicable.\n        func_type (str): Type of function for the tool, defaults to 'function'.\n        visible (bool): Flag indicating whether the tool is visible or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        method: Callable[..., Any],\n        signature: dict = {},\n        required: list = [],\n        enabled: bool = True,\n        disabled_reason: Optional[str] = None,\n        func_type: str = 'function',\n        visible: bool = True,\n    ):\n        self.name = name\n        self.description = description\n        self.method = method\n        self.signature = signature\n        self.required = required\n        self.enabled = enabled\n        self.disabled_reason = disabled_reason\n        self.func_type = func_type\n        self.visible = visible\n\n    def dict(self, name_overwrite: str = '') -> dict:\n        \"\"\"Returns the tool information as a dictionary.\n\n        Args:\n            name_overwrite (str): Replacement string for tool name, defaults to empty string.\n\n        Returns:\n            dict: Dictionary of tool attributes.\n        \"\"\"\n        \n        return {\n            \"name\": self.name if name_overwrite == '' else name_overwrite,\n            \"description\": self.description[:1024],\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": self.signature,\n                \"required\": self.required\n            }\n        }\n\n    def __str__(self) -> str:\n        \"\"\"Returns the tool information in a formatted string.\n\n        Returns:\n            str: Formatted string containing tool attributes.\n        \"\"\"\n        return f\"{self.name}: {self.description}, args: {self.signature}\"\n",
            "name_column": 6
        },
        "EnvLabels": {
            "type": "ClassDef",
            "name": "EnvLabels",
            "md_content": "",
            "code_start_line": 73,
            "code_end_line": 149,
            "parent": null,
            "have_return": true,
            "code_content": "class EnvLabels:\n    \"\"\"A class representing an environment.\n\n    Each environment has a set of subtools associated with it. This object manages the collection of tools.\n\n    Attributes:\n        name (str): Name of the environment.\n        description (str): Description of the environment.\n        subtools_labels (dict): Collection of tools associated to the environment.\n        defined_tools (list): List of tool names defined in the environment.\n        cls (Type): Class that the environment pertains to.\n        enabled (bool): Flag indicating whether the environment is enabled or not.\n        disabled_reason (str): Reason for disabling the environment, if applicable.\n        visible (bool): Flag indicating whether the environment is visible or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        subtools_labels: dict[ToolLabels] = {},\n        defined_tools:list[str] = [],\n        cls: Type = None,\n        enabled: bool = True,\n        disabled_reason: Optional[str] = None,\n        visible: bool = True,\n    ):\n        self.name = name\n        self.description = description\n        self.subtools_labels = subtools_labels\n        self.defined_tools = defined_tools\n        self.cls = cls\n        self.enabled = enabled\n        self.disabled_reason = disabled_reason\n        self.visible = visible\n\n    def dict(self,\n             include_invisible=False,\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\n        \"\"\"\n        Returns the environment's tools as a dictionary.\n\n        Args:\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\n            max_show_tools (int): Maximum number of tools to display in the output.\n\n        Returns:\n            dict: Dictionary of environment attributes and associated tools.\n        \"\"\"\n        \n        if include_invisible:\n            tools_name = list(self.subtools_labels.keys())\n        else:\n            if CONFIG['toolregister']['parent_tools_visible']:\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\n            else:\n                tools_name = self.defined_tools\n\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\n            # only show first max_show_tools tools\n            tools_name = tools_name[:max_show_tools]\n            tools_name.append('...')\n\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"total_tools\": len(self.subtools_labels),\n            \"tools\": tools_name,\n        }\n\n    def __str__(self) -> str:\n        \"\"\"Returns the environment information as a formatted string.\n\n        Returns:\n            str: Formatted string containing environment attributes.\n        \"\"\"\n        return f\"{self.name}: {self.description}\"",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 89,
            "code_end_line": 107,
            "parent": "EnvLabels",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        name: str,\n        description: str,\n        subtools_labels: dict[ToolLabels] = {},\n        defined_tools:list[str] = [],\n        cls: Type = None,\n        enabled: bool = True,\n        disabled_reason: Optional[str] = None,\n        visible: bool = True,\n    ):\n        self.name = name\n        self.description = description\n        self.subtools_labels = subtools_labels\n        self.defined_tools = defined_tools\n        self.cls = cls\n        self.enabled = enabled\n        self.disabled_reason = disabled_reason\n        self.visible = visible\n",
            "name_column": 8
        },
        "dict": {
            "type": "FunctionDef",
            "name": "dict",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 141,
            "parent": "EnvLabels",
            "have_return": true,
            "code_content": "    def dict(self,\n             include_invisible=False,\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\n        \"\"\"\n        Returns the environment's tools as a dictionary.\n\n        Args:\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\n            max_show_tools (int): Maximum number of tools to display in the output.\n\n        Returns:\n            dict: Dictionary of environment attributes and associated tools.\n        \"\"\"\n        \n        if include_invisible:\n            tools_name = list(self.subtools_labels.keys())\n        else:\n            if CONFIG['toolregister']['parent_tools_visible']:\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\n            else:\n                tools_name = self.defined_tools\n\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\n            # only show first max_show_tools tools\n            tools_name = tools_name[:max_show_tools]\n            tools_name.append('...')\n\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"total_tools\": len(self.subtools_labels),\n            \"tools\": tools_name,\n        }\n",
            "name_column": 8
        },
        "__str__": {
            "type": "FunctionDef",
            "name": "__str__",
            "md_content": "",
            "code_start_line": 143,
            "code_end_line": 149,
            "parent": "EnvLabels",
            "have_return": true,
            "code_content": "    def __str__(self) -> str:\n        \"\"\"Returns the environment information as a formatted string.\n\n        Returns:\n            str: Formatted string containing environment attributes.\n        \"\"\"\n        return f\"{self.name}: {self.description}\"",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/__init__.py": {},
    "ToolServer/ToolServerNode/core/exceptions.py": {
        "OutputNotReady": {
            "type": "ClassDef",
            "name": "OutputNotReady",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 20,
            "parent": null,
            "have_return": true,
            "code_content": "class OutputNotReady(Exception):\n    \"\"\"The output is not ready.\n        \"\"\"\n    def __init__(self, *args: object,type:str='retry',next_calling:str=None,arguments:dict={}) -> None:\n        super().__init__(*args)\n        self.type = type\n        self.next_calling = next_calling\n        self.arguments = arguments\n        \n    def next_try(self):\n        \"\"\"Prepare the next try by returning a dictionary\n           containing type, next calling event and arguments.\"\"\"\n        return {\n            \"type\":self.type,\n            \"next_calling\":self.next_calling,\n            \"arguments\":self.arguments\n        }\n",
            "name_column": 6
        },
        "ToolNotFound": {
            "type": "ClassDef",
            "name": "ToolNotFound",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 43,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolNotFound(Exception):\n    \"\"\"Custom exception class that is raised when the tool is not found.\n    \n    Args:\n        *args (object): Variable length argument list.\n        tool_name (str): The name of the tool.\n\n    Attributes:\n        tool_name (str): The name of the tool.\n    \"\"\"\n    def __init__(self, *args: object,tool_name:str=None) -> None:\n        super().__init__(*args)\n        self.tool_name = tool_name\n        \n    def __str__(self) -> str:\n        \"\"\"Returns the formatted exception error message with the name of the tool\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nThe tool {self.tool_name} is not found!'\n        else:\n            s = f'The tool {self.tool_name} is not found!'\n        return s \n",
            "name_column": 6
        },
        "EnvNotFound": {
            "type": "ClassDef",
            "name": "EnvNotFound",
            "md_content": "",
            "code_start_line": 46,
            "code_end_line": 69,
            "parent": null,
            "have_return": true,
            "code_content": "class EnvNotFound(Exception):\n    \"\"\"Custom exception class that is raised when the environment variable is not found.\n    \n    Args:\n        *args (object): Variable length argument list.\n        env_name (str): The name of the environment variable.\n\n    Attributes:\n        addition_info (tuple): Additional information.\n        env_name (str): The name of the environment variable.\n    \"\"\"\n    def __init__(self, *args: object,env_name:str=None) -> None:\n        super().__init__(*args)\n        self.addition_info = args\n        self.env_name =  env_name\n        \n    def __str__(self)->str:\n        \"\"\"Returns the formatted exception error message with the name of the environment variable\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nThe env {self.env_name} is not found!'\n        else:\n            s = f'The tool {self.env_name} is not found!'\n        return s \n",
            "name_column": 6
        },
        "ToolRegisterError": {
            "type": "ClassDef",
            "name": "ToolRegisterError",
            "md_content": "",
            "code_start_line": 71,
            "code_end_line": 94,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolRegisterError(Exception):\n    \"\"\"Custom exception class that is raised when registering a tool encounters an error.\n    \n    Args:\n        *args (object): Variable length argument list.\n        tool_name (str): The name of the tool.\n\n    Attributes:\n        addition_info (tuple): Additional information.\n        tool_name (str): The name of the tool.\n    \"\"\"\n    def __init__(self, *args: object,tool_name:str=None) -> None:\n        super().__init__(*args)\n        self.addition_info = args\n        self.tool_name = tool_name\n        \n    def __str__(self)->str:\n        \"\"\"Returns the formatted exception error message with the name of the tool\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nError happens when registering tool {self.tool_name}!'\n        else:\n            s = f'Error happens when registering tool {self.tool_name}!'\n        return s \n",
            "name_column": 6
        },
        "remove_color": {
            "type": "FunctionDef",
            "name": "remove_color",
            "md_content": "",
            "code_start_line": 97,
            "code_end_line": 107,
            "parent": null,
            "have_return": true,
            "code_content": "def remove_color(text):\n    \"\"\"Removes ANSI escape sequences i.e. colors, from the text.\n\n    Args:\n        text (str): The text from which color needs to be removed.\n\n    Returns:\n        str: The filtered text with no color.\n    \"\"\"\n\n    return ansi_escape.sub('', text)\n",
            "name_column": 4
        },
        "ToolExecutionError": {
            "type": "ClassDef",
            "name": "ToolExecutionError",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 118,
            "parent": null,
            "have_return": false,
            "code_content": "class ToolExecutionError(HTTPException):\n    \"\"\"Custom exception class that is raised when the tool execution encounters an error.\n\n    Args:\n        error_msg (str): The error message during tool execution.\n    \"\"\"\n    def __init__(self,error_msg:str):\n        if isinstance(error_msg,str):\n            error_msg = remove_color(error_msg)\n        super().__init__(500,error_msg)",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 115,
            "code_end_line": 118,
            "parent": "ToolExecutionError",
            "have_return": false,
            "code_content": "    def __init__(self,error_msg:str):\n        if isinstance(error_msg,str):\n            error_msg = remove_color(error_msg)\n        super().__init__(500,error_msg)",
            "name_column": 8
        },
        "next_try": {
            "type": "FunctionDef",
            "name": "next_try",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 20,
            "parent": "OutputNotReady",
            "have_return": true,
            "code_content": "    def next_try(self):\n        \"\"\"Prepare the next try by returning a dictionary\n           containing type, next calling event and arguments.\"\"\"\n        return {\n            \"type\":self.type,\n            \"next_calling\":self.next_calling,\n            \"arguments\":self.arguments\n        }\n",
            "name_column": 8
        },
        "__str__": {
            "type": "FunctionDef",
            "name": "__str__",
            "md_content": "",
            "code_start_line": 87,
            "code_end_line": 94,
            "parent": "ToolRegisterError",
            "have_return": true,
            "code_content": "    def __str__(self)->str:\n        \"\"\"Returns the formatted exception error message with the name of the tool\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nError happens when registering tool {self.tool_name}!'\n        else:\n            s = f'Error happens when registering tool {self.tool_name}!'\n        return s \n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/base.py": {
        "BaseEnv": {
            "type": "ClassDef",
            "name": "BaseEnv",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 76,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseEnv:\n    \"\"\"\n    BaseEnv class. It helps to handle functions and function names of the classes and subclasses.\n    This class provides methods to get all functions, defined functions and their names.\n    It also ensures the configuration updates if necessary.\n\n    Attributes:\n        config(Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\n    \"\"\"\n    def __init__(self, config: Dict[str, Any] = {}):\n        \"\"\"Initialize BaseEnv class with specified or default configuration.\n\n        Args:\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\n\n        Notes:\n            The configuration is deep copied to avoid modifications to the original object.\n        \"\"\"\n        self.config = deepcopy(CONFIG)\n        if isinstance(config, dict):\n            self.config.update(config)\n        \n    @classmethod\n    def __get_all_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the class, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names.\n        \"\"\"\n        return [name for name in dir(cls) \n        if not str(name).startswith('_') and callable(getattr(cls, name))]\n\n\n    @classmethod\n    def __get_all_func__(cls) -> list[Callable]:\n        \"\"\"Get all functions of the class, excluding methods starting with '__' characters.\n\n        Returns:\n            list[Callable]: A list that contains functions.\n        \"\"\"\n        func_names = cls.__get_all_func_name__()\n        return list(map(getattr, [cls]*len(func_names), func_names))\n\n    @classmethod\n    def __get_defined_func__(cls) -> list[Callable]:\n        \"\"\"Get all the functions of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[Callable]: A list that contains defined functions of the subclass.\n\n        Notes:\n            This method removes the parent class's methods from the functions list to \n            provide only the functions that are newly defined in the subclass.\n        \"\"\"\n        functions = cls.__get_all_func__()\n        for parent_cls in cls.__bases__:\n            if not issubclass(parent_cls, BaseEnv):\n                continue\n            parent_functions = parent_cls.__get_all_func__()\n            functions = list(filter(lambda x: x not in parent_functions, functions))\n    \n        return functions\n\n    @classmethod\n    def __get_defined_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names of the subclass.\n        \"\"\"\n        functions = cls.__get_defined_func__()\n        return list(map(lambda x: x.__name__, functions))",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 25,
            "parent": "BaseEnv",
            "have_return": false,
            "code_content": "    def __init__(self, config: Dict[str, Any] = {}):\n        \"\"\"Initialize BaseEnv class with specified or default configuration.\n\n        Args:\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\n\n        Notes:\n            The configuration is deep copied to avoid modifications to the original object.\n        \"\"\"\n        self.config = deepcopy(CONFIG)\n        if isinstance(config, dict):\n            self.config.update(config)\n",
            "name_column": 8
        },
        "__get_all_func_name__": {
            "type": "FunctionDef",
            "name": "__get_all_func_name__",
            "md_content": "",
            "code_start_line": 28,
            "code_end_line": 35,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_all_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the class, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names.\n        \"\"\"\n        return [name for name in dir(cls) \n        if not str(name).startswith('_') and callable(getattr(cls, name))]\n",
            "name_column": 8
        },
        "__get_all_func__": {
            "type": "FunctionDef",
            "name": "__get_all_func__",
            "md_content": "",
            "code_start_line": 39,
            "code_end_line": 46,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_all_func__(cls) -> list[Callable]:\n        \"\"\"Get all functions of the class, excluding methods starting with '__' characters.\n\n        Returns:\n            list[Callable]: A list that contains functions.\n        \"\"\"\n        func_names = cls.__get_all_func_name__()\n        return list(map(getattr, [cls]*len(func_names), func_names))\n",
            "name_column": 8
        },
        "__get_defined_func__": {
            "type": "FunctionDef",
            "name": "__get_defined_func__",
            "md_content": "",
            "code_start_line": 49,
            "code_end_line": 66,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_defined_func__(cls) -> list[Callable]:\n        \"\"\"Get all the functions of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[Callable]: A list that contains defined functions of the subclass.\n\n        Notes:\n            This method removes the parent class's methods from the functions list to \n            provide only the functions that are newly defined in the subclass.\n        \"\"\"\n        functions = cls.__get_all_func__()\n        for parent_cls in cls.__bases__:\n            if not issubclass(parent_cls, BaseEnv):\n                continue\n            parent_functions = parent_cls.__get_all_func__()\n            functions = list(filter(lambda x: x not in parent_functions, functions))\n    \n        return functions\n",
            "name_column": 8
        },
        "__get_defined_func_name__": {
            "type": "FunctionDef",
            "name": "__get_defined_func_name__",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 76,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_defined_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names of the subclass.\n        \"\"\"\n        functions = cls.__get_defined_func__()\n        return list(map(lambda x: x.__name__, functions))",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/tools/shell.py": {
        "async_read_pipe": {
            "type": "AsyncFunctionDef",
            "name": "async_read_pipe",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 16,
            "parent": null,
            "have_return": true,
            "code_content": "async def async_read_pipe(pipe: asyncio.StreamReader):\n    ret = b''\n    while True:\n        try:\n            ret += await asyncio.wait_for(pipe.readline(), timeout=0.01)\n        except asyncio.TimeoutError:\n            return ret\n",
            "name_column": 10
        },
        "read_exec_proc_display": {
            "type": "AsyncFunctionDef",
            "name": "read_exec_proc_display",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 23,
            "parent": null,
            "have_return": true,
            "code_content": "async def read_exec_proc_display(exec_proc: asyncio.subprocess.Process):\n    display = \"\"\n    for pipe, name in zip([exec_proc.stderr,exec_proc.stdout], ['stderr','stdout']):\n        ret = await async_read_pipe(pipe)\n        if ret != b'':\n            display += f'\\n{name}:\\n'+ ret.decode()\n    return display\n",
            "name_column": 10
        },
        "shell_command_executor": {
            "type": "AsyncFunctionDef",
            "name": "shell_command_executor",
            "md_content": "",
            "code_start_line": 26,
            "code_end_line": 109,
            "parent": null,
            "have_return": true,
            "code_content": "async def shell_command_executor(command: str = '', run_async: bool = False, shell_id: int = None, kill:bool = False):\n    \"\"\"The shell tool that execute shell command in root privilege, return the output and error. \n    You can use this tool to install packages, download files, run programs, etc.\n    Set run_async=True to run the command in a new thread and return instantly if your command is time costly like install packages, host services. \n    Example:\n    ```\n    In: shell_command_executor(command='echo \"hello world\"')\n    Out: \"hello world\"\n    In: shell_command_executor(command='sleep 10', run_async=True)\n    Out: {'shell_id': 0} # You can use this id to read the output and error later.\n    In: shell_command_executor(shell_id=0, kill=True)\n    Out: \"\" # The shell 0 will be killed.\n    ```\n\n    :param string? command: The shell command to be executed, must avoid command requiring additional user input. Default is empty string.\n    :param boolean? run_async: Whether to run the command asynchronously, default is False. If True, call this tool again with shell_id to get the final output and error. \n    :param integer? shell_id: The id of shell to execute command, default is None, which means running in a new shell. Change this to execute command in the same shell.\n    :param boolean? kill: If True, kill the shell which runs the command after execution. Default is False. Don't use any other kill command!\n    \"\"\"\n    if shell_id is not None:\n        exec_proc = ALL_SHELLS.get(shell_id, None)\n        if exec_proc is None:\n            raise ToolExecutionError(\n                {'Error': 'Shell not found or has been closed.'})\n        if exec_proc.returncode is not None:\n            print(exec_proc.returncode)\n            ALL_SHELLS.pop(shell_id)\n            raise ToolExecutionError({'Error': 'Shell has been closed.'})\n\n    else:\n        exec_proc = await asyncio.create_subprocess_shell(\n            'bash',\n            stderr=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stdin=asyncio.subprocess.PIPE,\n            cwd=CONFIG['filesystem']['work_directory'])\n        shell_id = max(ALL_SHELLS.keys(), default=-1) + 1\n        ALL_SHELLS[shell_id] = exec_proc\n\n    if not run_async:\n        try:\n            ret = await asyncio.wait_for(exec_proc.communicate(command.encode()), timeout=CONFIG['shell']['timeout'])\n        except asyncio.TimeoutError:\n            des = \"Timeout while executing command.\"\n            if kill:\n                des += \" Shell has been killed.\"\n                exec_proc.kill()\n            display = await read_exec_proc_display(exec_proc)\n            if display != \"\":\n                des += \" But get some response:\" + display\n                \n            raise ToolExecutionError(des)\n            \n        ALL_SHELLS.pop(shell_id)\n\n        result = {\n            'ReturnCode': exec_proc.returncode,\n            'display': ''\n        }\n        if ret[1] != b'':\n            result['display'] += f'\\nstderr:\\n'+ret[1].decode()\n        if ret[0] != b'':\n            result['display'] = f'\\nstdout:\\n'+ret[0].decode()\n            \n        if result['ReturnCode'] != 0 and not kill:\n            raise ToolExecutionError(result)\n        return result\n    else:\n        if command[-1] != '\\n':\n            command += '\\n'\n        exec_proc.stdin.write(command.encode())\n        await exec_proc.stdin.drain()\n        await asyncio.sleep(5)\n        result = {'shell_id': shell_id , 'display':await read_exec_proc_display(exec_proc)}\n        if result['display'] == \"\":\n            await asyncio.sleep(30)\n            result['display'] = await read_exec_proc_display(exec_proc)\n        if kill:\n            exec_proc.kill()\n            ALL_SHELLS.pop(shell_id)\n            result['status'] = 'shell thread has been killed'\n        else:\n            result['status'] = 'shell still running, no return code'\n        return result\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerNode/core/tools/__init__.py": {},
    "ToolServer/ToolServerNode/core/register/wrapper.py": {
        "generate_tool_labels": {
            "type": "FunctionDef",
            "name": "generate_tool_labels",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 83,
            "parent": null,
            "have_return": true,
            "code_content": "def generate_tool_labels(\n    name: str = None,\n    enabled: bool = True,\n    disabled_reason: Optional[str] = None,\n    func: Callable[..., Any] = None,\n    visible:bool = True,\n)->Union[ToolLabels,None]:\n    \"\"\"\n    Generate and return tool labels for the provided function. If the tool is not enabled,\n    then a debug log message is printed and None is returned.\n\n    Args:\n        name (str, optional): The name of the tool. If it's not specified, the function's name is used.\n        enabled (bool, optional): Determines if the tool is enabled or not. Defaults to True.\n        disabled_reason (Optional[str], optional): The reason why the tool is disabled. Defaults to None.\n        func (Callable[..., Any], optional): The function for which the tool labels are generated. Defaults to None.\n        visible(bool, optional): The visibility status of the tool. Defaults to True.\n\n    Returns:\n        Union[ToolLabels,None]: A ToolLabels object containing tool information or None if tool is not enabled. \n    \"\"\"\n\n    if not enabled:\n        if disabled_reason is not None:\n            logger.debug(f\"tool '{func.__name__}' is disabled: {disabled_reason}\")\n        return None\n\n    # check if the method have full annotations\n    auto_signature = {}\n    func_desc =  docstring_parser.parse(func.__doc__)\n    required = []\n    for arg in func_desc.params:\n        auto_signature[arg.arg_name] = {\n            'type':arg.type_name,           # TODO support self defined type\n            'description':arg.description,\n        }\n        if arg.default is not None:\n            auto_signature[arg.arg_name]['default'] = arg.default\n        if not arg.is_optional:\n            required.append(arg.arg_name)\n\n    # for arg in inspect.getargs(func.__code__).args:\n    #     if arg in auto_signature:\n    #         continue\n    #     if arg in ['self','cls','config','return']:\n    #         continue\n    #     # if arg not in func.__annotations__:\n    #     #     raise SyntaxError(f'Signature is None and the annotation of varable {arg} in func {func.__name__} is not found!')\n    #     auto_signature[arg] = {\n    #         'type':'string',\n    #         'description':''                # TODO try to generate description\n    #     }\n\n    tool_name = func.__name__ if name is None else name\n    description = ''\n    if func_desc.short_description is not None:\n        description = func_desc.short_description\n    if func_desc.long_description is not None:\n        description += '\\n' + func_desc.long_description\n\n    return ToolLabels(\n        name=tool_name,\n        description=description,\n        method=func,\n        signature=auto_signature,\n        required=required,\n        enabled=enabled,\n        disabled_reason=disabled_reason,\n        visible=visible,\n    )\n",
            "name_column": 4
        },
        "toolwrapper": {
            "type": "FunctionDef",
            "name": "toolwrapper",
            "md_content": "",
            "code_start_line": 85,
            "code_end_line": 167,
            "parent": null,
            "have_return": true,
            "code_content": "def toolwrapper(\n    name: str = None,\n    enabled: bool = True,\n    disabled_reason: Optional[str] = None,\n    parent_tools_visible: bool = CONFIG['toolregister']['parent_tools_visible'],\n    visible:bool = True,\n)->Union[Type,Callable[..., Any]]:\n    \"\"\"The tool decorator for class, used to create tool objects from ordinary class.\"\"\"\n\n    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\n        if inspect.isclass(obj):\n            cls = obj\n            cls_name = name if name is not None else cls.__name__\n            if not issubclass(cls,BaseEnv):\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\n            \n            description = cls.__doc__ if cls.__doc__ is not None else ''\n            if not visible:\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\'s defination to show all tools.\\n' + description\n            \n            \n            subtools_labels = {}\n            if BaseEnv not in cls.__bases__:\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\n                if not parent_tools_visible:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\'s defination to show them.\\n' + description\n                else:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\n' + description\n                for parent in cls.__bases__:\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\n                        subtools_labels.update(parent.env_labels.subtools_labels)\n            \n            cls_func_names = cls.__get_defined_func_name__()            \n            for func_name in cls_func_names:\n                origin_func = getattr(cls,func_name)\n                tool_labels = generate_tool_labels(\n                    name=func_name,\n                    enabled=enabled,\n                    disabled_reason=disabled_reason,\n                    func=origin_func,\n                    visible=visible)\n                if tool_labels is None:\n                    continue\n                \n                # label classmethod, staticmethod and instance method\n                #check if the function is a classmethod\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\n                    tool_labels.func_type = 'classmethod'\n                # check if the function is a staticmethod\n                if 'self' in inspect.getargs(origin_func.__code__).args:\n                    tool_labels.func_type = 'instancemethod'\n                else:   \n                    tool_labels.func_type = 'staticmethod'\n                \n                # tool_labels.dependent_cls = cls\n                origin_func.tool_labels = tool_labels\n                subtools_labels[tool_labels.name] = tool_labels\n            \n\n            cls.env_labels = EnvLabels(\n                name=cls_name,\n                description=description,\n                subtools_labels=subtools_labels,\n                defined_tools=cls_func_names,\n                cls=cls,\n                enabled=enabled,\n                disabled_reason=disabled_reason,\n                visible=visible\n            )\n            return cls\n        elif inspect.isfunction(obj):\n            func = obj\n            tool_labels = generate_tool_labels(\n                name=name,\n                enabled=enabled, \n                disabled_reason=disabled_reason,\n                func=func,\n                visible=visible)\n            func.tool_labels = tool_labels\n            return func\n        else:\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\n    return decorator\n",
            "name_column": 4
        },
        "decorator": {
            "type": "FunctionDef",
            "name": "decorator",
            "md_content": "",
            "code_start_line": 94,
            "code_end_line": 166,
            "parent": "toolwrapper",
            "have_return": true,
            "code_content": "    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\n        if inspect.isclass(obj):\n            cls = obj\n            cls_name = name if name is not None else cls.__name__\n            if not issubclass(cls,BaseEnv):\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\n            \n            description = cls.__doc__ if cls.__doc__ is not None else ''\n            if not visible:\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\'s defination to show all tools.\\n' + description\n            \n            \n            subtools_labels = {}\n            if BaseEnv not in cls.__bases__:\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\n                if not parent_tools_visible:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\'s defination to show them.\\n' + description\n                else:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\n' + description\n                for parent in cls.__bases__:\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\n                        subtools_labels.update(parent.env_labels.subtools_labels)\n            \n            cls_func_names = cls.__get_defined_func_name__()            \n            for func_name in cls_func_names:\n                origin_func = getattr(cls,func_name)\n                tool_labels = generate_tool_labels(\n                    name=func_name,\n                    enabled=enabled,\n                    disabled_reason=disabled_reason,\n                    func=origin_func,\n                    visible=visible)\n                if tool_labels is None:\n                    continue\n                \n                # label classmethod, staticmethod and instance method\n                #check if the function is a classmethod\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\n                    tool_labels.func_type = 'classmethod'\n                # check if the function is a staticmethod\n                if 'self' in inspect.getargs(origin_func.__code__).args:\n                    tool_labels.func_type = 'instancemethod'\n                else:   \n                    tool_labels.func_type = 'staticmethod'\n                \n                # tool_labels.dependent_cls = cls\n                origin_func.tool_labels = tool_labels\n                subtools_labels[tool_labels.name] = tool_labels\n            \n\n            cls.env_labels = EnvLabels(\n                name=cls_name,\n                description=description,\n                subtools_labels=subtools_labels,\n                defined_tools=cls_func_names,\n                cls=cls,\n                enabled=enabled,\n                disabled_reason=disabled_reason,\n                visible=visible\n            )\n            return cls\n        elif inspect.isfunction(obj):\n            func = obj\n            tool_labels = generate_tool_labels(\n                name=name,\n                enabled=enabled, \n                disabled_reason=disabled_reason,\n                func=func,\n                visible=visible)\n            func.tool_labels = tool_labels\n            return func\n        else:\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/register/register.py": {
        "get_func_name": {
            "type": "FunctionDef",
            "name": "get_func_name",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 26,
            "parent": null,
            "have_return": true,
            "code_content": "def get_func_name(func:Callable,env:BaseEnv=None)->str:\n    if env is None or not hasattr(env,'env_labels'):\n        if hasattr(func,'tool_labels'):\n            return func.tool_labels.name\n        else:\n            return func.__name__\n    else:\n        if hasattr(func,'tool_labels'):\n            return env.env_labels.name + '_' + func.tool_labels.name\n        else:\n            return env.env_labels.name + '_' + func.__name__\n",
            "name_column": 4
        },
        "ToolRegister": {
            "type": "ClassDef",
            "name": "ToolRegister",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 204,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolRegister:\n    def __init__(self,\n                 config:dict = {},\n                 ):\n        self.config = deepcopy(CONFIG)\n        for k in config:\n            self.config[k] = config[k]\n        self.toolregister_cfg = self.config['toolregister']\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\n        self.tool_creation_context = {}\n        self.tool_creation_context_load_code = []\n        for k in self.toolregister_cfg['tool_creation_context']:\n            # load\n            load_code = f\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\"\n            exec(load_code)\n            self.tool_creation_context[k] = eval(k)\n            self.tool_creation_context_load_code.append(load_code)\n        # load modules\n        self.tools = {}\n        self.envs = {}\n        for module_name in ['core.envs','core.tools']:            \n            sub_modules = importlib.import_module(module_name).__all__\n            for module in sub_modules:\n                for attr_name in dir(module):\n                    attr = getattr(module,attr_name)\n                    self.check_and_register(attr)\n            \n        # load extensions\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\n            for extension in self.config['enabled_extensions']:\n                self.dynamic_extension_load(extension)\n        \n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\n        # print(self.tools)\n    def check_and_register(self,attr:Any):\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\n            tool_name = get_func_name(attr)\n            if tool_name in self.tools:\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\n                return None\n            \n            self.tools[tool_name] = attr\n            logger.info(f'Register tool {tool_name}!')\n            return attr\n            \n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\n            # attr is a cls, need get instance\n            if attr.env_labels.name in self.envs:\n                return\n            if not issubclass(attr,BaseEnv):\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\n            env = attr(config=self.config.dict())\n            env_tools = {}\n            \n            if self.toolregister_cfg['parent_tools_visible']:\n                func_names = env.__get_all_func_name__()\n            else:\n                func_names = env.__get_defined_func_name__()\n            \n            for func_name in func_names:\n                func = getattr(env,func_name)\n                if hasattr(func,'tool_labels'):\n                    env_tools[get_func_name(func,env)] = func\n            \n            env_keys = set(env_tools.keys())\n            tools_keys = set(self.tools.keys())\n            if env_keys & tools_keys:\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\n                for tool_name in env_keys & tools_keys:\n                    env_tools.pop(tool_name)\n\n            self.tools.update(env_tools)\n            \n            self.envs[attr.env_labels.name] = env\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\n            \n            return env\n            \n        return None\n\n    def register_tool(self,tool_name:str,code:str)->str:\n        try:\n            exec(code,self.tool_creation_context)\n        except Exception as e:\n            error_report =  traceback.format_exc()\n            logger.error(error_report)\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\n\\n' + error_report,tool_name=tool_name)\n        \n        try:\n            tool_func = eval(tool_name,self.tool_creation_context)\n        except:\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\n        \n        tool_func = self.check_and_register(tool_func)\n        if tool_func is None:\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\n        \n        # write the tool into file under extensions/tools\n        code = '\\n'.join(self.tool_creation_context_load_code) +'\\n# Tool Creation Context Load Ended.\\n'+ code\n        tool_file = f'extensions/tools/{tool_name}.py'\n        with open(tool_file,'w') as f:\n            f.write(code)\n        \n        return self.get_tool_dict(tool_name)\n    \n    def dynamic_extension_load(self,extension:str)->bool:\n        '''Load extension dynamically.\n        \n        :param string extension: The load path of the extension.\n        :return boolean: True if success, False if failed.\n        '''\n        try:\n            module = importlib.import_module(extension)\n            for attr_name in dir(module):\n                attr = getattr(module,attr_name)\n                self.check_and_register(attr)\n        except Exception as e:\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\n            # logger.error(traceback.format_exc())\n            return False\n        \n        return True\n        \n    def get_tool_dict(self,tool_name:str)->dict:\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\n    \n    def get_env_dict(self,env_name:str)->dict:\n        if env_name not in self.envs:\n            raise EnvNotFound(env_name=env_name)\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\n    \n    def get_all_envs(self)->list[dict]:\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\n    \n    def get_all_tools(self,include_invisible=False)->list[str]:\n        if include_invisible:\n            return [tool_name  for tool_name in self.tools]\n        else:\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\n    \n    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\n    \n    def __getitem__(self, key)->Callable[..., Any]:\n        # two stage index, first find env, then find tool\n        if isinstance(key,str):\n            if key not in self.tools:\n                # check if the tool is a env subtool which not visible\n                try:\n                    tool_name = key.split('_')\n                    env_name = tool_name[0]\n                    tool_name = '_'.join(tool_name[1:])\n                    return self[env_name,tool_name]\n                except:\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\n                        # try to find tool in unloaded extensions\n                        return self.tools[key]\n                    else:\n                        raise ToolNotFound(tool_name=key)\n            return self.tools[key]\n        elif isinstance(key,tuple):\n            if len(key) != 2:\n                raise NotImplementedError(f'Key {key} is not valid!')\n            env_name,tool_name = key\n            if env_name not in self.envs:\n                # try to find env in unloaded extensions\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\n                    env = self.envs[env_name]\n                raise EnvNotFound(env_name=env_name)\n            env = self.envs[env_name]\n            if tool_name not in env.env_labels.subtools_labels:\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\n            else:\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\n                return func\n        raise NotImplementedError(f'Key {key} is not valid!')",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 30,
            "code_end_line": 61,
            "parent": "ToolRegister",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 config:dict = {},\n                 ):\n        self.config = deepcopy(CONFIG)\n        for k in config:\n            self.config[k] = config[k]\n        self.toolregister_cfg = self.config['toolregister']\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\n        self.tool_creation_context = {}\n        self.tool_creation_context_load_code = []\n        for k in self.toolregister_cfg['tool_creation_context']:\n            # load\n            load_code = f\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\"\n            exec(load_code)\n            self.tool_creation_context[k] = eval(k)\n            self.tool_creation_context_load_code.append(load_code)\n        # load modules\n        self.tools = {}\n        self.envs = {}\n        for module_name in ['core.envs','core.tools']:            \n            sub_modules = importlib.import_module(module_name).__all__\n            for module in sub_modules:\n                for attr_name in dir(module):\n                    attr = getattr(module,attr_name)\n                    self.check_and_register(attr)\n            \n        # load extensions\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\n            for extension in self.config['enabled_extensions']:\n                self.dynamic_extension_load(extension)\n        \n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\n",
            "name_column": 8
        },
        "check_and_register": {
            "type": "FunctionDef",
            "name": "check_and_register",
            "md_content": "",
            "code_start_line": 63,
            "code_end_line": 107,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def check_and_register(self,attr:Any):\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\n            tool_name = get_func_name(attr)\n            if tool_name in self.tools:\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\n                return None\n            \n            self.tools[tool_name] = attr\n            logger.info(f'Register tool {tool_name}!')\n            return attr\n            \n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\n            # attr is a cls, need get instance\n            if attr.env_labels.name in self.envs:\n                return\n            if not issubclass(attr,BaseEnv):\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\n            env = attr(config=self.config.dict())\n            env_tools = {}\n            \n            if self.toolregister_cfg['parent_tools_visible']:\n                func_names = env.__get_all_func_name__()\n            else:\n                func_names = env.__get_defined_func_name__()\n            \n            for func_name in func_names:\n                func = getattr(env,func_name)\n                if hasattr(func,'tool_labels'):\n                    env_tools[get_func_name(func,env)] = func\n            \n            env_keys = set(env_tools.keys())\n            tools_keys = set(self.tools.keys())\n            if env_keys & tools_keys:\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\n                for tool_name in env_keys & tools_keys:\n                    env_tools.pop(tool_name)\n\n            self.tools.update(env_tools)\n            \n            self.envs[attr.env_labels.name] = env\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\n            \n            return env\n            \n        return None\n",
            "name_column": 8
        },
        "register_tool": {
            "type": "FunctionDef",
            "name": "register_tool",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 132,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def register_tool(self,tool_name:str,code:str)->str:\n        try:\n            exec(code,self.tool_creation_context)\n        except Exception as e:\n            error_report =  traceback.format_exc()\n            logger.error(error_report)\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\n\\n' + error_report,tool_name=tool_name)\n        \n        try:\n            tool_func = eval(tool_name,self.tool_creation_context)\n        except:\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\n        \n        tool_func = self.check_and_register(tool_func)\n        if tool_func is None:\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\n        \n        # write the tool into file under extensions/tools\n        code = '\\n'.join(self.tool_creation_context_load_code) +'\\n# Tool Creation Context Load Ended.\\n'+ code\n        tool_file = f'extensions/tools/{tool_name}.py'\n        with open(tool_file,'w') as f:\n            f.write(code)\n        \n        return self.get_tool_dict(tool_name)\n",
            "name_column": 8
        },
        "dynamic_extension_load": {
            "type": "FunctionDef",
            "name": "dynamic_extension_load",
            "md_content": "",
            "code_start_line": 134,
            "code_end_line": 150,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def dynamic_extension_load(self,extension:str)->bool:\n        '''Load extension dynamically.\n        \n        :param string extension: The load path of the extension.\n        :return boolean: True if success, False if failed.\n        '''\n        try:\n            module = importlib.import_module(extension)\n            for attr_name in dir(module):\n                attr = getattr(module,attr_name)\n                self.check_and_register(attr)\n        except Exception as e:\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\n            # logger.error(traceback.format_exc())\n            return False\n        \n        return True\n",
            "name_column": 8
        },
        "get_tool_dict": {
            "type": "FunctionDef",
            "name": "get_tool_dict",
            "md_content": "",
            "code_start_line": 152,
            "code_end_line": 153,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_tool_dict(self,tool_name:str)->dict:\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\n",
            "name_column": 8
        },
        "get_env_dict": {
            "type": "FunctionDef",
            "name": "get_env_dict",
            "md_content": "",
            "code_start_line": 155,
            "code_end_line": 158,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_env_dict(self,env_name:str)->dict:\n        if env_name not in self.envs:\n            raise EnvNotFound(env_name=env_name)\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\n",
            "name_column": 8
        },
        "get_all_envs": {
            "type": "FunctionDef",
            "name": "get_all_envs",
            "md_content": "",
            "code_start_line": 160,
            "code_end_line": 161,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_all_envs(self)->list[dict]:\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\n",
            "name_column": 8
        },
        "get_all_tools": {
            "type": "FunctionDef",
            "name": "get_all_tools",
            "md_content": "",
            "code_start_line": 163,
            "code_end_line": 167,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_all_tools(self,include_invisible=False)->list[str]:\n        if include_invisible:\n            return [tool_name  for tool_name in self.tools]\n        else:\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\n",
            "name_column": 8
        },
        "get_all_tools_dict": {
            "type": "FunctionDef",
            "name": "get_all_tools_dict",
            "md_content": "",
            "code_start_line": 169,
            "code_end_line": 170,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "",
            "code_start_line": 172,
            "code_end_line": 204,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def __getitem__(self, key)->Callable[..., Any]:\n        # two stage index, first find env, then find tool\n        if isinstance(key,str):\n            if key not in self.tools:\n                # check if the tool is a env subtool which not visible\n                try:\n                    tool_name = key.split('_')\n                    env_name = tool_name[0]\n                    tool_name = '_'.join(tool_name[1:])\n                    return self[env_name,tool_name]\n                except:\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\n                        # try to find tool in unloaded extensions\n                        return self.tools[key]\n                    else:\n                        raise ToolNotFound(tool_name=key)\n            return self.tools[key]\n        elif isinstance(key,tuple):\n            if len(key) != 2:\n                raise NotImplementedError(f'Key {key} is not valid!')\n            env_name,tool_name = key\n            if env_name not in self.envs:\n                # try to find env in unloaded extensions\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\n                    env = self.envs[env_name]\n                raise EnvNotFound(env_name=env_name)\n            env = self.envs[env_name]\n            if tool_name not in env.env_labels.subtools_labels:\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\n            else:\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\n                return func\n        raise NotImplementedError(f'Key {key} is not valid!')",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/register/__init__.py": {},
    "ToolServer/ToolServerNode/core/envs/web.py": {
        "WebEnv": {
            "type": "ClassDef",
            "name": "WebEnv",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 126,
            "parent": null,
            "have_return": true,
            "code_content": "class WebEnv(BaseEnv):\n    \"\"\"Web Environment providing web interface and browsering.\n    \"\"\"\n    def __init__(self,config:dict = {}):\n        super().__init__(config=config)\n        self.bing_cfg = self.config['bing']\n        if self.bing_cfg['api_key'] is None:\n            logger.warning(\"Bing API key is not provided, rollback to duckduckgo.\")\n        \n        self.web_cfg = self.config['web']\n        self.headers = {\n            \"User-Agent\":self.web_cfg['user_agent']\n        }\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\n\n    def _check_url_valid(self,url:str):\n        local_prefixes = [\n            \"file:///\",\n            \"file://127.0.0.1\",\n            \"file://localhost\",\n            \"http://localhost\",\n            \"https://localhost\",\n            \"http://2130706433\",\n            \"https://2130706433\",\n            \"http://127.0.0.1\",\n            \"https://127.0.0.1\",\n            \"https://0.0.0.0\",\n            \"http://0.0.0.0\",\n            \"http://0000\",\n            \"https://0000\",\n        ]\n        if any(url.startswith(prefix) for prefix in local_prefixes):\n            raise ValueError(f\"URL {url} is a local url, blocked!\")\n        if not (url.startswith(\"http\") or url.startswith(\"file\")):\n            raise ValueError(f\"URL {url} is not a http or https url, please give a valid url!\")\n        \n    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\n        \"\"\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\n    \n        :param string search_query: The search query.\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\n        :return string: The results of the search.\n        \"\"\"\n        \n        api_key = self.bing_cfg[\"api_key\"]\n        endpoint = self.bing_cfg[\"endpoint\"]\n        if region is None:\n            region = 'en-US'\n        if api_key is None:\n            pages = [{\n                'name':ret['title'],\n                'snippet':ret['body'],\n                'url':ret['href']\n            } for ret in DDGS().text(search_query, region='wt-wt')]\n            \n        else:\n            result = await self.client.get(endpoint,\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\n                        params={'q': search_query, 'mkt': region },\n                        timeout=10)\n            result.raise_for_status()\n            result = result.json()\n            pages = result[\"webPages\"][\"value\"]\n            \n        search_results = []\n\n        for idx in range(min(len(pages),num_results)):\n            try:\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\n            except httpx.HTTPStatusError as e:\n                page = e.response.text\n            except Exception as e:\n                page = str(e)\n                \n            message = {\n                'name':pages[idx]['name'],\n                'snippet':pages[idx]['snippet'],\n                'page':page\n            }\n            search_results.append(message)\n\n        return search_results\n    \n    async def browse_website(self,url:str,goals_to_browse:str)->str:\n        \"\"\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\n        \n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \"<URL of the second news article>\", give real url!!! Example: 'https://www.deepmind.com/'\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\n        :return string: The content of the website, with formatted text.\n        \"\"\"\n        # self._check_url_valid(url)\n        res = await self.client.get(url)\n        if res.status_code in [301,302,307,308]:\n            res = await self.client.get(res.headers['location'])\n        else:\n            res.raise_for_status()\n        \n        soup = BeautifulSoup(res.text,\"html.parser\")\n        text = soup.get_text()\n        lines = (line.strip() for line in text.splitlines())\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        text = \"\\n\".join(chunk for chunk in chunks if chunk)\n        \n        links = soup.find_all('a')\n        if len(links) > 0:\n            text += '\\n\\nLinks:\\n'\n            for link in links:\n                if link.string != None and link.get('href')!= None:\n                    # print(''.join(link.string.split()),link.get('href'))\n                    striped_link_string = link.string.strip()\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\n                        text += f\"{striped_link_string} ({link.get('href')})\\n\"\n        \n        return text",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 15,
            "code_end_line": 25,
            "parent": "WebEnv",
            "have_return": false,
            "code_content": "    def __init__(self,config:dict = {}):\n        super().__init__(config=config)\n        self.bing_cfg = self.config['bing']\n        if self.bing_cfg['api_key'] is None:\n            logger.warning(\"Bing API key is not provided, rollback to duckduckgo.\")\n        \n        self.web_cfg = self.config['web']\n        self.headers = {\n            \"User-Agent\":self.web_cfg['user_agent']\n        }\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\n",
            "name_column": 8
        },
        "_check_url_valid": {
            "type": "FunctionDef",
            "name": "_check_url_valid",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 46,
            "parent": "WebEnv",
            "have_return": false,
            "code_content": "    def _check_url_valid(self,url:str):\n        local_prefixes = [\n            \"file:///\",\n            \"file://127.0.0.1\",\n            \"file://localhost\",\n            \"http://localhost\",\n            \"https://localhost\",\n            \"http://2130706433\",\n            \"https://2130706433\",\n            \"http://127.0.0.1\",\n            \"https://127.0.0.1\",\n            \"https://0.0.0.0\",\n            \"http://0.0.0.0\",\n            \"http://0000\",\n            \"https://0000\",\n        ]\n        if any(url.startswith(prefix) for prefix in local_prefixes):\n            raise ValueError(f\"URL {url} is a local url, blocked!\")\n        if not (url.startswith(\"http\") or url.startswith(\"file\")):\n            raise ValueError(f\"URL {url} is not a http or https url, please give a valid url!\")\n",
            "name_column": 8
        },
        "search_and_browse": {
            "type": "AsyncFunctionDef",
            "name": "search_and_browse",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 94,
            "parent": "WebEnv",
            "have_return": true,
            "code_content": "    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\n        \"\"\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\n    \n        :param string search_query: The search query.\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\n        :return string: The results of the search.\n        \"\"\"\n        \n        api_key = self.bing_cfg[\"api_key\"]\n        endpoint = self.bing_cfg[\"endpoint\"]\n        if region is None:\n            region = 'en-US'\n        if api_key is None:\n            pages = [{\n                'name':ret['title'],\n                'snippet':ret['body'],\n                'url':ret['href']\n            } for ret in DDGS().text(search_query, region='wt-wt')]\n            \n        else:\n            result = await self.client.get(endpoint,\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\n                        params={'q': search_query, 'mkt': region },\n                        timeout=10)\n            result.raise_for_status()\n            result = result.json()\n            pages = result[\"webPages\"][\"value\"]\n            \n        search_results = []\n\n        for idx in range(min(len(pages),num_results)):\n            try:\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\n            except httpx.HTTPStatusError as e:\n                page = e.response.text\n            except Exception as e:\n                page = str(e)\n                \n            message = {\n                'name':pages[idx]['name'],\n                'snippet':pages[idx]['snippet'],\n                'page':page\n            }\n            search_results.append(message)\n\n        return search_results\n",
            "name_column": 14
        },
        "browse_website": {
            "type": "AsyncFunctionDef",
            "name": "browse_website",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 126,
            "parent": "WebEnv",
            "have_return": true,
            "code_content": "    async def browse_website(self,url:str,goals_to_browse:str)->str:\n        \"\"\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\n        \n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \"<URL of the second news article>\", give real url!!! Example: 'https://www.deepmind.com/'\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\n        :return string: The content of the website, with formatted text.\n        \"\"\"\n        # self._check_url_valid(url)\n        res = await self.client.get(url)\n        if res.status_code in [301,302,307,308]:\n            res = await self.client.get(res.headers['location'])\n        else:\n            res.raise_for_status()\n        \n        soup = BeautifulSoup(res.text,\"html.parser\")\n        text = soup.get_text()\n        lines = (line.strip() for line in text.splitlines())\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        text = \"\\n\".join(chunk for chunk in chunks if chunk)\n        \n        links = soup.find_all('a')\n        if len(links) > 0:\n            text += '\\n\\nLinks:\\n'\n            for link in links:\n                if link.string != None and link.get('href')!= None:\n                    # print(''.join(link.string.split()),link.get('href'))\n                    striped_link_string = link.string.strip()\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\n                        text += f\"{striped_link_string} ({link.get('href')})\\n\"\n        \n        return text",
            "name_column": 14
        }
    },
    "ToolServer/ToolServerNode/core/envs/filesystem.py": {
        "FileSystemEnv": {
            "type": "ClassDef",
            "name": "FileSystemEnv",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 206,
            "parent": null,
            "have_return": true,
            "code_content": "class FileSystemEnv(BaseEnv):\n    \"\"\"Provide a file system operation environment for Agent.\n    \"\"\"\n    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.ignored_list = filesystem_config[\"ignored_list\"]\n        self.work_directory = filesystem_config[\"work_directory\"]\n        self.max_entry_nums_for_level = filesystem_config[\"max_entry_nums_for_level\"]\n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n        \n    def _check_ignorement(self,path:str)->bool:\n        for pattern in self.ignored_list:\n            if fnmatch.fnmatch(path,pattern):\n                return True\n        return False\n    \n    def _is_path_within_workspace(self,path:str)->bool:\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\n                                            os.path.realpath(self.work_directory)])\n        return common_prefix == os.path.realpath(self.work_directory)\n    \n    def _is_path_exist(self,path:str)->bool:\n        \"\"\"Check if the path exists in the workspace.\n        \n        :param string path: The path to be checked.\n        :return bool: `True` if the path exists, else `False`.\n        \"\"\"\n\n        full_path = os.path.join(self.work_directory, path)\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"Path {path} is not within workspace.\")\n        return os.path.exists(full_path)\n\n    def print_filesys_struture(self,return_root=False)->str:\n        \"\"\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\n\n        This function recursively walks through all the directories in the workspace\n        and return them in a tree-like structure, \n        displaying all the files under each directory.\n        \n        Example:\n        ```\n        - root/\n            - sub_directory1/\n                - file1.txt\n                - file2.txt\n            - sub_directory2/\n                - file3.txt\n        ```\n\n        :return string: The tree-like structure of the workspace.\n        \"\"\"\n        full_repr = ''\n        if return_root:\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\n'\n\n        folder_counts =  defaultdict(lambda: 0)\n        for root, dirs, files in os.walk(self.work_directory):\n            if self._check_ignorement(root):\n                continue\n            level = root.replace(self.work_directory, '').count(os.sep)\n            indent = ' ' * 4 * (level)\n            \n            folder_counts[root] += 1\n            if folder_counts[root] > self.max_entry_nums_for_level:\n                full_repr += f'{indent}`wrapped`\\n'\n            \n            full_repr += f'{indent}- {os.path.basename(root)}/\\n'\n            \n            idx = 0\n            subindent = ' ' * 4 * (level + 1) + '- '\n            for f in files:\n                if self._check_ignorement(f):\n                    continue\n                \n                idx += 1\n                if idx > self.max_entry_nums_for_level:\n                    full_repr += f'{subindent}`wrapped`\\n'\n                    break\n                full_repr += f'{subindent}{f}\\n'\n\n\n        return full_repr\n    \n    def read_from_file(self,filepath:str,line_number:int = 1)->str:\n        \"\"\"Open and read the textual file content in the workspace, you will see the content of the target file.\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\n        \n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\n        :return string: The content of the file.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)        \n        else:\n            full_path = filepath\n                \n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        if not os.path.exists(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n\n        content = ''\n        with open(full_path, 'r') as f:\n            lines = f.readlines(int(1e5))\n            \n        read_count = 0\n        if not (abs(line_number) - 1 < len(lines)):\n            raise ValueError(f\"Line number {line_number} is out of range.\")\n        index = line_number if line_number >= 0 else len(lines) + line_number\n        if index == 0:\n            index = 1\n            \n        if line_number == 0:\n            indexed_lines = lines\n        elif line_number > 0:\n            indexed_lines = lines[line_number-1:]\n        else:\n            indexed_lines = lines[line_number:]\n            \n        for line in indexed_lines:\n            content += f'{index}'.rjust(5) + ': '\n            content += line\n            read_count += len(line)\n            index += 1\n        return content\n\n    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\n        \"\"\"Write or modify the textual file lines based on `content` provided. \n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\n        \n        Example:\n        ```\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\nA new line!')\n        Out[0]: '1: Hello World!\\\\n2: A new line!'\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\n        Out[1]: '1: Hello World!\\\\n2: Hello World 1!\\\\n3: A new line!'\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\n        Out[2]: '1: Hello World!\\\\n2: Hello World 2!\\\\n3: A new line!'\n        ```\n        \n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\n        :param string content: The new content to be replaced with the old content.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)\n        else:\n            full_path = filepath\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        \n        if not os.path.exists(full_path):\n            if line_number is None or line_number==0 or line_number == 1:\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\n                open(full_path, 'w+').close()\n            else:\n                raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        elif not os.path.isfile(full_path):\n            raise ValueError(f\"File {filepath} is not a file.\")\n            \n        # protential overflow\n        if truncating:\n            lines = []\n        else:\n            with open(full_path, 'r') as f:\n                lines = f.readlines()\n        \n        \n        new_lines = content.splitlines(keepends=True)\n        if line_number is None:\n            lines.extend(new_lines)\n        else:\n            if line_number >= 1:\n                line_number -= 1\n            if overwrite:\n                lines[line_number: line_number+len(new_lines)] = new_lines\n            else:\n                lines[line_number: line_number] = new_lines \n\n        for idx, _ in enumerate(lines):\n            if not lines[idx].endswith('\\n'):\n                lines[idx] += '\\n'\n                \n        with open(full_path, 'w+') as f:\n            f.writelines(lines)\n            \n        return self.read_from_file(filepath)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 21,
            "parent": "FileSystemEnv",
            "have_return": false,
            "code_content": "    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.ignored_list = filesystem_config[\"ignored_list\"]\n        self.work_directory = filesystem_config[\"work_directory\"]\n        self.max_entry_nums_for_level = filesystem_config[\"max_entry_nums_for_level\"]\n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n",
            "name_column": 8
        },
        "_check_ignorement": {
            "type": "FunctionDef",
            "name": "_check_ignorement",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 27,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def _check_ignorement(self,path:str)->bool:\n        for pattern in self.ignored_list:\n            if fnmatch.fnmatch(path,pattern):\n                return True\n        return False\n",
            "name_column": 8
        },
        "_is_path_within_workspace": {
            "type": "FunctionDef",
            "name": "_is_path_within_workspace",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 32,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def _is_path_within_workspace(self,path:str)->bool:\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\n                                            os.path.realpath(self.work_directory)])\n        return common_prefix == os.path.realpath(self.work_directory)\n",
            "name_column": 8
        },
        "_is_path_exist": {
            "type": "FunctionDef",
            "name": "_is_path_exist",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 44,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def _is_path_exist(self,path:str)->bool:\n        \"\"\"Check if the path exists in the workspace.\n        \n        :param string path: The path to be checked.\n        :return bool: `True` if the path exists, else `False`.\n        \"\"\"\n\n        full_path = os.path.join(self.work_directory, path)\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"Path {path} is not within workspace.\")\n        return os.path.exists(full_path)\n",
            "name_column": 8
        },
        "print_filesys_struture": {
            "type": "FunctionDef",
            "name": "print_filesys_struture",
            "md_content": "",
            "code_start_line": 46,
            "code_end_line": 95,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def print_filesys_struture(self,return_root=False)->str:\n        \"\"\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\n\n        This function recursively walks through all the directories in the workspace\n        and return them in a tree-like structure, \n        displaying all the files under each directory.\n        \n        Example:\n        ```\n        - root/\n            - sub_directory1/\n                - file1.txt\n                - file2.txt\n            - sub_directory2/\n                - file3.txt\n        ```\n\n        :return string: The tree-like structure of the workspace.\n        \"\"\"\n        full_repr = ''\n        if return_root:\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\n'\n\n        folder_counts =  defaultdict(lambda: 0)\n        for root, dirs, files in os.walk(self.work_directory):\n            if self._check_ignorement(root):\n                continue\n            level = root.replace(self.work_directory, '').count(os.sep)\n            indent = ' ' * 4 * (level)\n            \n            folder_counts[root] += 1\n            if folder_counts[root] > self.max_entry_nums_for_level:\n                full_repr += f'{indent}`wrapped`\\n'\n            \n            full_repr += f'{indent}- {os.path.basename(root)}/\\n'\n            \n            idx = 0\n            subindent = ' ' * 4 * (level + 1) + '- '\n            for f in files:\n                if self._check_ignorement(f):\n                    continue\n                \n                idx += 1\n                if idx > self.max_entry_nums_for_level:\n                    full_repr += f'{subindent}`wrapped`\\n'\n                    break\n                full_repr += f'{subindent}{f}\\n'\n\n\n        return full_repr\n",
            "name_column": 8
        },
        "read_from_file": {
            "type": "FunctionDef",
            "name": "read_from_file",
            "md_content": "",
            "code_start_line": 97,
            "code_end_line": 141,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def read_from_file(self,filepath:str,line_number:int = 1)->str:\n        \"\"\"Open and read the textual file content in the workspace, you will see the content of the target file.\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\n        \n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\n        :return string: The content of the file.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)        \n        else:\n            full_path = filepath\n                \n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        if not os.path.exists(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n\n        content = ''\n        with open(full_path, 'r') as f:\n            lines = f.readlines(int(1e5))\n            \n        read_count = 0\n        if not (abs(line_number) - 1 < len(lines)):\n            raise ValueError(f\"Line number {line_number} is out of range.\")\n        index = line_number if line_number >= 0 else len(lines) + line_number\n        if index == 0:\n            index = 1\n            \n        if line_number == 0:\n            indexed_lines = lines\n        elif line_number > 0:\n            indexed_lines = lines[line_number-1:]\n        else:\n            indexed_lines = lines[line_number:]\n            \n        for line in indexed_lines:\n            content += f'{index}'.rjust(5) + ': '\n            content += line\n            read_count += len(line)\n            index += 1\n        return content\n",
            "name_column": 8
        },
        "write_to_file": {
            "type": "FunctionDef",
            "name": "write_to_file",
            "md_content": "",
            "code_start_line": 143,
            "code_end_line": 206,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\n        \"\"\"Write or modify the textual file lines based on `content` provided. \n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\n        \n        Example:\n        ```\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\nA new line!')\n        Out[0]: '1: Hello World!\\\\n2: A new line!'\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\n        Out[1]: '1: Hello World!\\\\n2: Hello World 1!\\\\n3: A new line!'\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\n        Out[2]: '1: Hello World!\\\\n2: Hello World 2!\\\\n3: A new line!'\n        ```\n        \n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\n        :param string content: The new content to be replaced with the old content.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)\n        else:\n            full_path = filepath\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        \n        if not os.path.exists(full_path):\n            if line_number is None or line_number==0 or line_number == 1:\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\n                open(full_path, 'w+').close()\n            else:\n                raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        elif not os.path.isfile(full_path):\n            raise ValueError(f\"File {filepath} is not a file.\")\n            \n        # protential overflow\n        if truncating:\n            lines = []\n        else:\n            with open(full_path, 'r') as f:\n                lines = f.readlines()\n        \n        \n        new_lines = content.splitlines(keepends=True)\n        if line_number is None:\n            lines.extend(new_lines)\n        else:\n            if line_number >= 1:\n                line_number -= 1\n            if overwrite:\n                lines[line_number: line_number+len(new_lines)] = new_lines\n            else:\n                lines[line_number: line_number] = new_lines \n\n        for idx, _ in enumerate(lines):\n            if not lines[idx].endswith('\\n'):\n                lines[idx] += '\\n'\n                \n        with open(full_path, 'w+') as f:\n            f.writelines(lines)\n            \n        return self.read_from_file(filepath)\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/envs/__init__.py": {},
    "ToolServer/ToolServerNode/core/envs/pycoding.py": {
        "PythonNotebook": {
            "type": "ClassDef",
            "name": "PythonNotebook",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 178,
            "parent": null,
            "have_return": true,
            "code_content": "class PythonNotebook(BaseEnv):\n    \"\"\"Python Notebook Environment. Provide a notebook interface to run python code.\"\"\"\n    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.work_directory = filesystem_config[\"work_directory\"]\n        \n        self.nb_cfg = self.config['notebook']\n        \n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n\n        # make a new notebook\n        self.nb = nbformat.v4.new_notebook(\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\n    \n    async def _running(self):\n        if self.nbc.kc is not None:\n            return await ensure_async(self.nbc.kc.is_alive())\n        return False\n    \n    async def _reset(self):\n        if await self._running():\n            await self.nbc._async_cleanup_kernel()\n        self.nbc.create_kernel_manager()\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\n        await self.nbc.async_start_new_kernel_client()\n\n    @staticmethod\n    def _fix_escape(problematic_code: str) -> str:\n        for str_sign in ['\"', \"'\", '\"\"\"', \"'''\"]:\n\n            pattern = rf'{str_sign}(.*?){str_sign}'\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\n            replaced_in_line_strs = []\n            for in_line_str in in_line_strs:\n                replaced_in_line_strs.append(in_line_str.replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\t', '\\\\t'))\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\n\n        return fixed_code\n\n        \n    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\n        \"\"\"Create or replace a notebook cell and execute it, return the output.\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\n        \n        Example:\n        ```\n        In[0]: code='print(\"hello world\")' # This will create a new cell and execute it.\n        Out[0]: ['cell_index: 0', 'hello world']\n        In[1]: code='print(\"hello world\")',cell_index=0 # This will overwrite the first cell and execute it.\n        In[2]: code='print(\"hello world\")',cell_index=-1 # This will overwrite the last cell and execute it.\n        ```\n        \n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\n        :return string: execution result.\n        \"\"\"\n        # code = self._fix_escape(code)\n        if reset or not await self._running():\n            await self._reset()\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\n            cell_index = len(self.nb.cells)-1\n        else:\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\n        \n        try:\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\n        except CellExecutionError as e:\n            pass\n        except DeadKernelError as e:\n            await self._reset()\n            \n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\n        \n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\n        \n    def print_notebook(self)->str:\n        \"\"\"print all notebook cells' content and output.\n        \n        :return string: all notebook cells description.\n        \"\"\"\n        ret = ''\n        for i,cell in enumerate(self.nb.cells):\n            ret += f'= Cell {i} =\\n'\n            if cell['cell_type'] == 'code':\n                ret += f'{cell[\"source\"]}\\n'\n                if len(cell['outputs']) != 0:\n                    ret += f'= Output {i} =\\n'\n                    ret += f'{self._format_outputs(cell[\"outputs\"])}\\n'\n        return ret\n    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\n        ret = None\n        if len(outputs) == 0:\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\n        elif len(outputs) == 1:\n            if cell_index is not None:\n                ret = {\n                    'type':'composite',\n                    'data':[\n                        f'cell_index: {cell_index}',\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\n                    ]\n                }\n            else:\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\n        else:\n            ret = {\n                'type':'composite',\n                'data':[\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\n                ]\n            }\n            if cell_index is not None:\n                ret['data'].insert(0,f'cell_index: {cell_index}')\n        return ret\n        \n    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\n        def format_single_data(data,data_type:str):\n            if data_type.startswith('image/'):\n                return {\n                    'type': 'binary',\n                    'media_type':data_type,\n                    'data': data if return_binary else '`Wrapped`'\n                }\n            elif data_type.startswith('text/'):\n                return ''.join(data)\n            elif data_type.startswith('application/'):\n                return data\n            return data\n            \n        ret = None\n        match output['output_type']:\n            case 'execute_result' | 'display_data':\n                keys = list(output['data'].keys())\n                if 'text/html' in keys and 'text/plain' in keys:\n                    keys.remove('text/html') # remove html\n                if len(keys) == 1:\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\n                elif len(keys) > 1:\n                    ret = {\n                        'type': 'composite',\n                        'data':[]\n                    }\n                    for k in keys:\n                        ret['data'].append(format_single_data(output['data'][k],k))\n                    \n            case 'error':\n                if reraise:\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\n'+'\\n'.join(output['traceback']))\n                else:\n                    return '\\n'.join(output['traceback'])\n            case 'stream':\n                ret = output['text']\n            case _:\n                ret = output\n        return ret\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 18,
            "code_end_line": 32,
            "parent": "PythonNotebook",
            "have_return": false,
            "code_content": "    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.work_directory = filesystem_config[\"work_directory\"]\n        \n        self.nb_cfg = self.config['notebook']\n        \n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n\n        # make a new notebook\n        self.nb = nbformat.v4.new_notebook(\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\n",
            "name_column": 8
        },
        "_running": {
            "type": "AsyncFunctionDef",
            "name": "_running",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 37,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    async def _running(self):\n        if self.nbc.kc is not None:\n            return await ensure_async(self.nbc.kc.is_alive())\n        return False\n",
            "name_column": 14
        },
        "_reset": {
            "type": "AsyncFunctionDef",
            "name": "_reset",
            "md_content": "",
            "code_start_line": 39,
            "code_end_line": 44,
            "parent": "PythonNotebook",
            "have_return": false,
            "code_content": "    async def _reset(self):\n        if await self._running():\n            await self.nbc._async_cleanup_kernel()\n        self.nbc.create_kernel_manager()\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\n        await self.nbc.async_start_new_kernel_client()\n",
            "name_column": 14
        },
        "_fix_escape": {
            "type": "FunctionDef",
            "name": "_fix_escape",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 59,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def _fix_escape(problematic_code: str) -> str:\n        for str_sign in ['\"', \"'\", '\"\"\"', \"'''\"]:\n\n            pattern = rf'{str_sign}(.*?){str_sign}'\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\n            replaced_in_line_strs = []\n            for in_line_str in in_line_strs:\n                replaced_in_line_strs.append(in_line_str.replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\t', '\\\\t'))\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\n\n        return fixed_code\n",
            "name_column": 8
        },
        "execute_cell": {
            "type": "AsyncFunctionDef",
            "name": "execute_cell",
            "md_content": "",
            "code_start_line": 62,
            "code_end_line": 97,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\n        \"\"\"Create or replace a notebook cell and execute it, return the output.\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\n        \n        Example:\n        ```\n        In[0]: code='print(\"hello world\")' # This will create a new cell and execute it.\n        Out[0]: ['cell_index: 0', 'hello world']\n        In[1]: code='print(\"hello world\")',cell_index=0 # This will overwrite the first cell and execute it.\n        In[2]: code='print(\"hello world\")',cell_index=-1 # This will overwrite the last cell and execute it.\n        ```\n        \n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\n        :return string: execution result.\n        \"\"\"\n        # code = self._fix_escape(code)\n        if reset or not await self._running():\n            await self._reset()\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\n            cell_index = len(self.nb.cells)-1\n        else:\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\n        \n        try:\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\n        except CellExecutionError as e:\n            pass\n        except DeadKernelError as e:\n            await self._reset()\n            \n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\n        \n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\n",
            "name_column": 14
        },
        "print_notebook": {
            "type": "FunctionDef",
            "name": "print_notebook",
            "md_content": "",
            "code_start_line": 99,
            "code_end_line": 112,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def print_notebook(self)->str:\n        \"\"\"print all notebook cells' content and output.\n        \n        :return string: all notebook cells description.\n        \"\"\"\n        ret = ''\n        for i,cell in enumerate(self.nb.cells):\n            ret += f'= Cell {i} =\\n'\n            if cell['cell_type'] == 'code':\n                ret += f'{cell[\"source\"]}\\n'\n                if len(cell['outputs']) != 0:\n                    ret += f'= Output {i} =\\n'\n                    ret += f'{self._format_outputs(cell[\"outputs\"])}\\n'\n        return ret\n",
            "name_column": 8
        },
        "_format_outputs": {
            "type": "FunctionDef",
            "name": "_format_outputs",
            "md_content": "",
            "code_start_line": 113,
            "code_end_line": 137,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\n        ret = None\n        if len(outputs) == 0:\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\n        elif len(outputs) == 1:\n            if cell_index is not None:\n                ret = {\n                    'type':'composite',\n                    'data':[\n                        f'cell_index: {cell_index}',\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\n                    ]\n                }\n            else:\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\n        else:\n            ret = {\n                'type':'composite',\n                'data':[\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\n                ]\n            }\n            if cell_index is not None:\n                ret['data'].insert(0,f'cell_index: {cell_index}')\n        return ret\n",
            "name_column": 8
        },
        "_format_output": {
            "type": "FunctionDef",
            "name": "_format_output",
            "md_content": "",
            "code_start_line": 139,
            "code_end_line": 178,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\n        def format_single_data(data,data_type:str):\n            if data_type.startswith('image/'):\n                return {\n                    'type': 'binary',\n                    'media_type':data_type,\n                    'data': data if return_binary else '`Wrapped`'\n                }\n            elif data_type.startswith('text/'):\n                return ''.join(data)\n            elif data_type.startswith('application/'):\n                return data\n            return data\n            \n        ret = None\n        match output['output_type']:\n            case 'execute_result' | 'display_data':\n                keys = list(output['data'].keys())\n                if 'text/html' in keys and 'text/plain' in keys:\n                    keys.remove('text/html') # remove html\n                if len(keys) == 1:\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\n                elif len(keys) > 1:\n                    ret = {\n                        'type': 'composite',\n                        'data':[]\n                    }\n                    for k in keys:\n                        ret['data'].append(format_single_data(output['data'][k],k))\n                    \n            case 'error':\n                if reraise:\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\n'+'\\n'.join(output['traceback']))\n                else:\n                    return '\\n'.join(output['traceback'])\n            case 'stream':\n                ret = output['text']\n            case _:\n                ret = output\n        return ret\n",
            "name_column": 8
        },
        "format_single_data": {
            "type": "FunctionDef",
            "name": "format_single_data",
            "md_content": "",
            "code_start_line": 140,
            "code_end_line": 151,
            "parent": "_format_output",
            "have_return": true,
            "code_content": "        def format_single_data(data,data_type:str):\n            if data_type.startswith('image/'):\n                return {\n                    'type': 'binary',\n                    'media_type':data_type,\n                    'data': data if return_binary else '`Wrapped`'\n                }\n            elif data_type.startswith('text/'):\n                return ''.join(data)\n            elif data_type.startswith('application/'):\n                return data\n            return data\n",
            "name_column": 12
        }
    },
    "ToolServer/ToolServerNode/utils/retriever.py": {
        "standardizing": {
            "type": "FunctionDef",
            "name": "standardizing",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "def standardizing(string: str) -> str:\n    \"\"\"\n    Return a standardized string by replacing non-alphanumeric characters with underscores,\n    reducing multiple underscores to one, and converting all characters to lowercase.\n\n    Args:\n        string: The input string to be standardized.\n\n    Returns: \n        A standardized version of the input string.\n    \"\"\"\n    string = STANDARDIZING_PATTERN.sub(\"_\", string)\n    string = re.sub(r\"(_)\\1+\",\"_\", string)\n    string = string.strip(\"_\").lower()\n    return string\n",
            "name_column": 4
        },
        "ada_retriever": {
            "type": "FunctionDef",
            "name": "ada_retriever",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 59,
            "parent": null,
            "have_return": true,
            "code_content": "def ada_retriever(doc_embeddings: list, id2tool:dict, question: str, top_k: int=5) -> list:\n    \"\"\"\n    Retrieve tools related to the provided question.\n\n    Args:\n        doc_embeddings: The list of document embeddings.\n        id2tool: A dictionary mapping tool id to tool name.\n        question: The question for the ADA retriever.\n        top_k: The number of top tools to return (default is 5).\n\n    Returns:\n        A list of retrieved tools.\n    \"\"\"\n    cfg = CONFIG['retriver']\n    url = cfg['endpoint']\n    headers = cfg['headers']\n    payload = {'input':question}\n    payload.update(cfg['payload'])\n    \n    response = requests.post(url, json=payload, headers=headers)\n    query_embedding = np.array(response.json()['data'][0]['embedding'])\n\n    similarities = cosine_similarity([query_embedding], doc_embeddings)\n\n    sorted_doc_indices = sorted(range(len(similarities[0])), key=lambda i: similarities[0][i], reverse=True)\n    retrieved_tools = list(map(lambda doc_id: id2tool[str(doc_id)],sorted_doc_indices[:top_k]))\n    \n    return retrieved_tools\n",
            "name_column": 4
        },
        "build_tool_embeddings": {
            "type": "FunctionDef",
            "name": "build_tool_embeddings",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 147,
            "parent": null,
            "have_return": true,
            "code_content": "def build_tool_embeddings(tools_json: list[dict]) -> tuple:\n    \"\"\"\n    Build tool embeddings.\n\n    Args:\n        tools_json: The list of dictionaries containing tool data.\n\n    Returns:\n        A tuple containing a list of document embeddings and a dictionary\n        mapping tool id to tool name.\n    \"\"\"\n    cfg = CONFIG['retriver']\n    if os.path.exists(cfg['id2tool_file']) and os.path.exists(cfg['embedding_file']):\n        id2tool = json.load(open(cfg['id2tool_file'], \"r\"))\n        doc_embedings = np.load(cfg['embedding_file'])\n        if len(id2tool) != len(doc_embedings):\n            logger.error('Embedding file and id2tool file do not match! Rebuild embeddings!')\n            id2tool = {}\n            doc_embedings = []\n    else:\n        id2tool = {}\n        doc_embedings = []\n\n    # check embedding file whether need to be updated\n    # get all current tool names\n    # tool_names = set(map(lambda tool_json: tool_json['name'], tools_json))\n    # cached_tool_names = set(id2tool.values())\n    # if tool_names == cached_tool_names:\n    #     logger.info('No tools change, use cached embeddings!')\n    #     return doc_embedings, id2tool\n    return doc_embedings, id2tool\n    \n    # update embeddings\n    logger.info('Tools change detected, updating embeddings...')\n    url = cfg['endpoint']\n    headers = cfg['headers']\n    \n    new_id2tool = { str(i):tool_json['name'] for i,tool_json in enumerate(tools_json) }\n    json.dump(new_id2tool, open(cfg['id2tool_file'], \"w\"), indent=4)\n\n    def get_embedding(tool_json:dict) -> list:\n        \"\"\"\n        Get embedding for a certain tool.\n\n        Args:\n            tool_json: The dictionary containing tool data.\n\n        Returns:\n            A list of tool embeddings.\n        \"\"\"\n        payload = {'input':json.dumps(tool_json)}\n        payload.update(cfg['payload'])\n        try:\n            response = requests.post(url, json=payload, headers=headers)\n            response.raise_for_status()\n        except Exception as e:\n            logger.error(f'Failed to get embedding for tool {tool_json[\"name\"]}! Error: {e}')\n            return [-1.000001] * cfg['embedding_dim']\n        return response.json()['data'][0]['embedding']\n    \n    uncached_tools = list(filter(lambda tool_json: tool_json['name'] not in cached_tool_names, tools_json))\n    uncached_tools_name = list(map(lambda tool_json: tool_json['name'],uncached_tools))\n    uncached_doc_embedings = []\n    with ThreadPoolExecutor(16) as pool:\n        futures = [pool.submit(get_embedding, tool_json) for tool_json in uncached_tools]\n        \n        for future in tqdm.tqdm(futures,ncols=100):\n            uncached_doc_embedings.append(future.result())\n    \n    new_doc_embedings = []\n    for tool_json in tools_json:\n        if tool_json['name'] not in cached_tool_names:\n            new_doc_embedings.append(\n                uncached_doc_embedings[\n                    uncached_tools_name.index(tool_json['name'])\n                    ])\n        else:\n            for doc_id in id2tool.keys():\n                if id2tool[doc_id] == tool_json['name']:\n                    new_doc_embedings.append(doc_embedings[int(doc_id)])\n                    break\n\n    new_doc_embedings = np.array(new_doc_embedings)\n    np.save(cfg['embedding_file'], new_doc_embedings)\n\n    logger.info('Embeddings updated! New embeddings saved!')\n    return doc_embedings, new_id2tool",
            "name_column": 4
        },
        "get_embedding": {
            "type": "FunctionDef",
            "name": "get_embedding",
            "md_content": "",
            "code_start_line": 101,
            "code_end_line": 119,
            "parent": "build_tool_embeddings",
            "have_return": true,
            "code_content": "    def get_embedding(tool_json:dict) -> list:\n        \"\"\"\n        Get embedding for a certain tool.\n\n        Args:\n            tool_json: The dictionary containing tool data.\n\n        Returns:\n            A list of tool embeddings.\n        \"\"\"\n        payload = {'input':json.dumps(tool_json)}\n        payload.update(cfg['payload'])\n        try:\n            response = requests.post(url, json=payload, headers=headers)\n            response.raise_for_status()\n        except Exception as e:\n            logger.error(f'Failed to get embedding for tool {tool_json[\"name\"]}! Error: {e}')\n            return [-1.000001] * cfg['embedding_dim']\n        return response.json()['data'][0]['embedding']\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/utils/__init__.py": {},
    "ToolServer/ToolServerNode/utils/response.py": {
        "is_base64": {
            "type": "FunctionDef",
            "name": "is_base64",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 20,
            "parent": null,
            "have_return": true,
            "code_content": "def is_base64(s:str) -> bool:\n    \"\"\"\n    Check if the given string is a base64 sting or not.\n\n    Args:\n        s (str): the string to be checked.\n\n    Returns:\n        bool: Returns True if the given string is a base64 string, False otherwise.\n    \"\"\"\n    try:\n        base64.b64decode(s)\n        return True\n    except:\n        return False\n",
            "name_column": 4
        },
        "is_wrapped_response": {
            "type": "FunctionDef",
            "name": "is_wrapped_response",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 36,
            "parent": null,
            "have_return": true,
            "code_content": "def is_wrapped_response(obj:dict) -> bool:\n    \"\"\"\n    Check if the dictionary object is a wrapped response.\n    A dictionary is considered as wrapped response if it has 'type' and 'data' keys,\n    and value of 'type' key is one of ['simple','composite','binary'].\n\n    Args:\n        obj (dict): the dictionary object to be checked.\n\n    Returns:\n        bool: Returns True if the dictionary is a wrapped response, False otherwise.\n    \"\"\"\n    if 'type' in obj and obj['type'] in ['simple','composite','binary'] and 'data' in obj:\n        return True\n    return False\n",
            "name_column": 4
        },
        "wrap_tool_response": {
            "type": "FunctionDef",
            "name": "wrap_tool_response",
            "md_content": "",
            "code_start_line": 38,
            "code_end_line": 128,
            "parent": null,
            "have_return": true,
            "code_content": "def wrap_tool_response(obj:Any) -> dict|list|str|int|float|bool:\n    \"\"\"\n    Wrap the tool response in a standardized object structure (depending on its type) to allow decoding.\n    \n    Format\n    ======\n    ```\n    {\n        'type': 'simple',       # for single return value like python basic types\n        'data': obj\n    },\n    {\n        'type': 'binary',       # for single return value like python basic types\n        'media_type':'image/png',   # or other media types\n        'name': 'xxx',             # file name of the binary data\n        'data': obj             # base64 encoded binary data\n    },\n    str,int,float,bool,list is directly returned\n    or\n    {\n        'type': 'composite',    # for multiple return values\n        'data': [\n            {\n                'type': 'simple',\n                'data': obj1\n            },\n            {\n                'type': 'simple',\n                'data': obj2\n            }\n        ]\n    }\n    ```\n    Standardized Structures:\n    - For simple data types (str, int, float, bool), the object is directly returned.\n    - For composite types (tuples), data is wrapped in an object with a composite type.\n    - For binary data, data is base64 encoded and wrapped in an object with a binary type.\n     \n\n    Args:\n        obj (Any): any Python object that needs to be wrapped.\n\n    Returns:\n        Union[dict, list, str, int, float, bool]: the wrapped response.\n        \n    Raises:\n        logger.warning: raises warning if the type of 'obj' is unknown.\n    \"\"\"\n    if isinstance(obj,tuple):\n        if len(obj) == 0:\n            ret = {\n                'type': 'simple',\n                'data': None\n            }\n        elif len(obj) == 1:\n            ret = {\n                'type': 'simple',\n                'data': obj[0]\n            }\n        else:\n            ret = {\n                'type': 'composite',\n                'data': []\n            }\n            for o in obj:\n                ret['data'].append(wrap_tool_response(o))\n    elif isinstance(obj,bytes):\n        ret = {\n            'type': 'binary',\n            'media_type': 'bytes',\n            'name': None,\n            'data': base64.b64encode(obj).decode()\n        }\n    elif isinstance(obj,(str,int,float,bool,list)) or obj is None:\n        ret = obj\n    elif isinstance(obj,dict):\n        # check if already wrapped\n        if is_wrapped_response(obj):\n            ret = obj\n        else:\n            ret = {\n                'type': 'simple',\n                'data': obj\n            }\n    else:\n        logger.warning(f'Unknown type {type(obj)} in wrap_tool_response')\n        ret = {\n            'type': 'simple',\n            'data': obj\n        }\n    return ret",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/utils/import_helper.py": {
        "import_all_modules_in_folder": {
            "type": "FunctionDef",
            "name": "import_all_modules_in_folder",
            "md_content": "",
            "code_start_line": 3,
            "code_end_line": 20,
            "parent": null,
            "have_return": true,
            "code_content": "def import_all_modules_in_folder(file,name):\n    current_dir = os.path.dirname(file)\n    all_modules = []\n    for item in os.listdir(current_dir):\n        item_path = os.path.join(current_dir, item)\n        if os.path.isfile(item_path) and item != '__init__.py' and item.endswith('.py'):\n            module_name = item[:-3]\n        elif os.path.isdir(item_path) and item != '__pycache__' and os.path.exists(os.path.join(item_path, '__init__.py')) and os.path.isfile(os.path.join(item_path, '__init__.py')):\n            module_name = item\n        else:\n            continue\n\n        full_module_path = f\"{name}.{module_name}\"\n        # print(module_name,full_module_path)\n        imported_module = importlib.import_module(full_module_path)\n        globals()[module_name] = imported_module\n        all_modules.append(imported_module)\n    return all_modules",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/utils/openai.py": {
        "OpenaiPoolRequest": {
            "type": "ClassDef",
            "name": "OpenaiPoolRequest",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 93,
            "parent": null,
            "have_return": true,
            "code_content": "class OpenaiPoolRequest:\n    \"\"\"\n    Handles all OpenAI requests by dispatching them to the API endpoints.\n\n    Attributes:\n        openai_cfg: Configuration dictionary containing OpenAI parameters.\n        pool: list of dictionaries, where each dictionary has all the required details of an endpoint.\n    \"\"\"\n    def __init__(self,):\n        \"\"\"\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\n        \"\"\"\n        self.openai_cfg = deepcopy(CONFIG['openai'])\n        \n        self.pool:List[Dict] = []\n        \n        __pool_file = self.openai_cfg['key_pool_json']\n        if os.environ.get('API_POOL_FILE',None) is not None:\n            __pool_file = os.environ.get('API_POOL_FILE')\n        \n        if os.path.exists(__pool_file):\n            self.pool = json.load(open(__pool_file))\n        \n        if os.environ.get('OPENAI_KEY',None) is not None:\n            self.pool.append({\n                'api_key':os.environ.get('OPENAI_KEY'),\n                'organization':os.environ.get('OPENAI_ORG',None),\n                'api_type':os.environ.get('OPENAI_TYPE',None),\n                'api_version':os.environ.get('OPENAI_VER',None)\n            })\n        if len(self.pool) == 0:\n            logger.warning('No openai api key found! Some functions will be disable!')\n\n    @retry(wait=wait_random_exponential(multiplier=1, max=10), stop=stop_after_attempt(5),reraise=True)\n    async def request(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Sends a request to the OpenAI and gets a response.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If the attempt to reach the endpoint exceed limit.\n        \"\"\"\n        \n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\n        chat_args.update(kwargs)\n\n        item = random.choice(self.pool)\n        chat_args['api_key'] = item['api_key']\n        if 'organization' in item:\n            chat_args['organization'] = item['organization']\n        if 'api_type' in item:\n            chat_args['api_type'] = item['api_type']\n        if 'api_version' in item:\n            chat_args['api_version'] = item['api_version']\n\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\n    \n    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Makes a request to the OpenAI by calling the instance of the class.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If there are no API keys available in the pool.\n        \"\"\"\n        if len(self.pool)==0:\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\n        return await self.request(messages,**kwargs)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 45,
            "parent": "OpenaiPoolRequest",
            "have_return": false,
            "code_content": "    def __init__(self,):\n        \"\"\"\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\n        \"\"\"\n        self.openai_cfg = deepcopy(CONFIG['openai'])\n        \n        self.pool:List[Dict] = []\n        \n        __pool_file = self.openai_cfg['key_pool_json']\n        if os.environ.get('API_POOL_FILE',None) is not None:\n            __pool_file = os.environ.get('API_POOL_FILE')\n        \n        if os.path.exists(__pool_file):\n            self.pool = json.load(open(__pool_file))\n        \n        if os.environ.get('OPENAI_KEY',None) is not None:\n            self.pool.append({\n                'api_key':os.environ.get('OPENAI_KEY'),\n                'organization':os.environ.get('OPENAI_ORG',None),\n                'api_type':os.environ.get('OPENAI_TYPE',None),\n                'api_version':os.environ.get('OPENAI_VER',None)\n            })\n        if len(self.pool) == 0:\n            logger.warning('No openai api key found! Some functions will be disable!')\n",
            "name_column": 8
        },
        "request": {
            "type": "AsyncFunctionDef",
            "name": "request",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 75,
            "parent": "OpenaiPoolRequest",
            "have_return": true,
            "code_content": "    async def request(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Sends a request to the OpenAI and gets a response.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If the attempt to reach the endpoint exceed limit.\n        \"\"\"\n        \n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\n        chat_args.update(kwargs)\n\n        item = random.choice(self.pool)\n        chat_args['api_key'] = item['api_key']\n        if 'organization' in item:\n            chat_args['organization'] = item['organization']\n        if 'api_type' in item:\n            chat_args['api_type'] = item['api_type']\n        if 'api_version' in item:\n            chat_args['api_version'] = item['api_version']\n\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\n",
            "name_column": 14
        },
        "__call__": {
            "type": "AsyncFunctionDef",
            "name": "__call__",
            "md_content": "",
            "code_start_line": 77,
            "code_end_line": 93,
            "parent": "OpenaiPoolRequest",
            "have_return": true,
            "code_content": "    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Makes a request to the OpenAI by calling the instance of the class.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If there are no API keys available in the pool.\n        \"\"\"\n        if len(self.pool)==0:\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\n        return await self.request(messages,**kwargs)\n",
            "name_column": 14
        }
    },
    "ToolServer/ToolServerNode/extensions/__init__.py": {},
    "ToolServer/ToolServerNode/extensions/tools/code_interpreter.py": {
        "run_interpreter": {
            "type": "AsyncFunctionDef",
            "name": "run_interpreter",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 47,
            "parent": null,
            "have_return": true,
            "code_content": "async def run_interpreter(code:str=None,command:str=None,filename:str='code.py'):\n    \"\"\"The code interpreter tool that runs code and return the output.\n\n    The `code` will be written to file `filename` and the `command` will be executed in a shell.\n    Example:\n    ```\n    run_interpreter(code='print(\"hello world\")',command='python code.py')\n    ```\n\n    :param string? code: The code to be written, default to `None`, which means no code will be written to file.\n    :param string? command: The shell command to be executed should avoid requiring additional user input, default to `python {filename}`.\n    :param string? filename: The filename to be written in mode `w`, default to `code.py`.\n\n    \"\"\"\n    if code is not None and code != \"\" and filename != \"\":\n        CODE_FS.write_to_file(filename,code)\n\n    if command is None:\n        command = f'python {filename}'\n    exec_proc = await asyncio.create_subprocess_shell(\n        'bash',\n        stderr=asyncio.subprocess.PIPE,\n        stdout=asyncio.subprocess.PIPE,\n        stdin=asyncio.subprocess.PIPE,\n        cwd=CODE_FS.work_directory)\n    \n    ret = await asyncio.wait_for(exec_proc.communicate(command.encode()),timeout=CONFIG['shell']['timeout'])\n    \n    result = {\n        'ReturnCode':exec_proc.returncode,\n    }\n    if ret[1]!=b'':\n        result['Error'] = ret[1].decode()\n    if ret[0]!=b'':\n        result['Output'] = ret[0].decode()\n\n    return result\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerNode/extensions/tools/__init__.py": {},
    "ToolServer/ToolServerNode/extensions/tools/calculator.py": {
        "calculator": {
            "type": "FunctionDef",
            "name": "calculator",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 28,
            "parent": null,
            "have_return": true,
            "code_content": "def calculator(expression:str)->str:\n    \"\"\"It is a simple calculator, which can execute Python expressions: e.g., \"(123 + 234) / 23 * 1.5 - 8\".\n        \n    :param string expression: The python expression you requested.\n    :return string: The execution results of the expression.\n    \"\"\"\n    globals={}\n    locals={}\n    try:\n        # Wrap the code in an eval() call to return the result\n        wrapped_code = f\"__result__ = eval({repr(expression)}, globals(), locals())\"\n        exec(wrapped_code, globals, locals)\n        return locals.get('__result__', None)\n    except Exception as e:\n        try:\n        # If eval fails, attempt to exec the code without returning a result\n            exec(expression, globals, locals)\n            return \"Code executed successfully.\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/extensions/tools/search.py": {
        "bing_search": {
            "type": "FunctionDef",
            "name": "bing_search",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 40,
            "parent": null,
            "have_return": true,
            "code_content": "def bing_search(query:str,region:str = None)->str|list[str]:\n    \"\"\"Return 3 most relevant results of a Bing search using the official Bing API. This tool does not provide website details, use other tools to browse website if you need.\n    \n    :param string query: The search query.\n    :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `en-AU`, `en-CA`, `en-GB`, `de-DE`, `en-IN`, `en-ID`, `es-ES`, `fr-FR`, `it-IT`, `en-MY`, `nl-NL`, `en-NZ`, `en-PH`, `en-SG`, `en-ZA`, `sv-SE`, `tr-TR`.\n    :return string: The results of the search.\n    \"\"\"\n    #     :param int num_results: The number of results to return.\n    \n    num_results = 3\n    endpoint = bing_cfg[\"endpoint\"]\n    api_key = bing_cfg[\"api_key\"]\n    if region is None:\n        region = 'en-US'\n    result = requests.get(endpoint, headers={'Ocp-Apim-Subscription-Key': api_key}, params={'q': query, 'mkt': region }, timeout=10)\n    result.raise_for_status()\n    result = result.json()\n\n    pages = result[\"webPages\"][\"value\"]\n    search_results = []\n\n    for idx in range(min(len(pages),num_results)):\n        message = {\n            'url':pages[idx]['url'],\n            'name':pages[idx]['name'],\n            'snippet':pages[idx]['snippet']\n        }\n        search_results.append(message)\n\n    # Return the list of search result\n    return search_results",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/extensions/envs/shell.py": {
        "read_pipe": {
            "type": "FunctionDef",
            "name": "read_pipe",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 23,
            "parent": null,
            "have_return": true,
            "code_content": "def read_pipe(pipe:Union[io.StringIO,io.BytesIO],text=True)->Union[str,bytes]:\n    \"\"\"Reading the `subprocess.PIPE` when readable.\n    If `text` is `True`, return str, else return bytes.\n    \"\"\"\n    output = '' if text else b''\n    while True:\n        ready_fds,_,_ = select.select( [pipe.fileno()],[],[],0.01)\n        if len(ready_fds) == 0:\n            break\n        output += os.read(ready_fds[0],16384).decode() if text else os.read(ready_fds[0],16384)\n\n    return output\n",
            "name_column": 4
        },
        "ShellEnv": {
            "type": "ClassDef",
            "name": "ShellEnv",
            "md_content": "",
            "code_start_line": 26,
            "code_end_line": 129,
            "parent": null,
            "have_return": true,
            "code_content": "class ShellEnv(BaseEnv):\n    \"\"\"Provide and maintain an interactive shell environment.\n    \"\"\"\n    def __init__(self,\n                 config:Dict[str,Any]):\n        super().__init__(config)\n        \n        if sys.platform.startswith(\"linux\"):\n            self.shell_program = \"bash\"\n        elif sys.platform.startswith(\"darwin\"):\n            self.shell_program = \"zsh\"\n        else:\n            self.shell_program = \"powershell\"\n        self.work_directory = self.config['filesystem']['work_directory']\n        self._restart()\n\n    @property\n    def running(self)->bool:\n        \"\"\"`True` if shell is running, else `False`\n        \"\"\"\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\n            if self.running_proc.poll() is None:\n                return True\n        return False\n    \n    def _restart(self,program:str=None,shell:bool=True):\n        f\"\"\"Restart the shell.\n        \n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\n        \"\"\"\n        self._kill()\n        if program is None:\n            program = self.shell_program\n        self.running_proc = subprocess.Popen(\n            program, # adding more shells support\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=self.work_directory,\n            shell=shell,\n            text=True\n        )\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\n    \n    def _terminate(self):\n        \"\"\"Terminate the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.terminate()\n\n    def _kill(self):\n        \"\"\"Kill the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.kill()\n\n    def read_stdout(self, probe: bool = False) -> str:\n        \"\"\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\n        \n        Empty string will be returned if both stdout and stderr are empty.\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\n        \n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\n        \"\"\"\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if probe and len(ready_fds) == 0 :\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        error = read_pipe(self.running_proc.stderr)\n        if error:\n            return error\n\n        return read_pipe(self.running_proc.stdout)\n    \n    \n    def write_stdin(self, content:str) -> str:\n        \"\"\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\n        \n        Example:\n        ```\n        write_stdin('echo \"hello world\"')\n        ```\n        This will execute the command `echo \"hello world\"` in shell and return the output `hello world`.\n        \n        :param string content: The content to be written.\n        \"\"\"\n\n        # removed temporarily, maybe put back later?\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        if not content.endswith(\"\\n\"):\n            content += \"\\n\"\n        self.running_proc.stdin.write(content)\n        self.running_proc.stdin.flush()\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if len(ready_fds) == 0:\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        return 'Instant shell output: ' + self.read_stdout()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 40,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 config:Dict[str,Any]):\n        super().__init__(config)\n        \n        if sys.platform.startswith(\"linux\"):\n            self.shell_program = \"bash\"\n        elif sys.platform.startswith(\"darwin\"):\n            self.shell_program = \"zsh\"\n        else:\n            self.shell_program = \"powershell\"\n        self.work_directory = self.config['filesystem']['work_directory']\n        self._restart()\n",
            "name_column": 8
        },
        "running": {
            "type": "FunctionDef",
            "name": "running",
            "md_content": "",
            "code_start_line": 43,
            "code_end_line": 49,
            "parent": "ShellEnv",
            "have_return": true,
            "code_content": "    def running(self)->bool:\n        \"\"\"`True` if shell is running, else `False`\n        \"\"\"\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\n            if self.running_proc.poll() is None:\n                return True\n        return False\n",
            "name_column": 8
        },
        "_restart": {
            "type": "FunctionDef",
            "name": "_restart",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 68,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def _restart(self,program:str=None,shell:bool=True):\n        f\"\"\"Restart the shell.\n        \n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\n        \"\"\"\n        self._kill()\n        if program is None:\n            program = self.shell_program\n        self.running_proc = subprocess.Popen(\n            program, # adding more shells support\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=self.work_directory,\n            shell=shell,\n            text=True\n        )\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\n",
            "name_column": 8
        },
        "_terminate": {
            "type": "FunctionDef",
            "name": "_terminate",
            "md_content": "",
            "code_start_line": 70,
            "code_end_line": 74,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def _terminate(self):\n        \"\"\"Terminate the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.terminate()\n",
            "name_column": 8
        },
        "_kill": {
            "type": "FunctionDef",
            "name": "_kill",
            "md_content": "",
            "code_start_line": 76,
            "code_end_line": 80,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def _kill(self):\n        \"\"\"Kill the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.kill()\n",
            "name_column": 8
        },
        "read_stdout": {
            "type": "FunctionDef",
            "name": "read_stdout",
            "md_content": "",
            "code_start_line": 82,
            "code_end_line": 101,
            "parent": "ShellEnv",
            "have_return": true,
            "code_content": "    def read_stdout(self, probe: bool = False) -> str:\n        \"\"\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\n        \n        Empty string will be returned if both stdout and stderr are empty.\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\n        \n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\n        \"\"\"\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if probe and len(ready_fds) == 0 :\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        error = read_pipe(self.running_proc.stderr)\n        if error:\n            return error\n\n        return read_pipe(self.running_proc.stdout)\n",
            "name_column": 8
        },
        "write_stdin": {
            "type": "FunctionDef",
            "name": "write_stdin",
            "md_content": "",
            "code_start_line": 104,
            "code_end_line": 129,
            "parent": "ShellEnv",
            "have_return": true,
            "code_content": "    def write_stdin(self, content:str) -> str:\n        \"\"\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\n        \n        Example:\n        ```\n        write_stdin('echo \"hello world\"')\n        ```\n        This will execute the command `echo \"hello world\"` in shell and return the output `hello world`.\n        \n        :param string content: The content to be written.\n        \"\"\"\n\n        # removed temporarily, maybe put back later?\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        if not content.endswith(\"\\n\"):\n            content += \"\\n\"\n        self.running_proc.stdin.write(content)\n        self.running_proc.stdin.flush()\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if len(ready_fds) == 0:\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        return 'Instant shell output: ' + self.read_stdout()\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/extensions/envs/__init__.py": {},
    "ToolServer/ToolServerNode/extensions/envs/rapidapi.py": {
        "generate_arg_doc": {
            "type": "FunctionDef",
            "name": "generate_arg_doc",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def generate_arg_doc(arg_name,arg_type,arg_desc,arg_default=None,arg_optional=None):\n    match arg_type:\n        case 'NUMBER':\n            arg_type = 'integer'\n        case 'STRING':\n            arg_type = 'string'\n        case 'BOOLEAN':\n            arg_type = 'boolean'\n        case 'ARRAY':\n            arg_type = 'array'\n        case 'OBJECT':\n            arg_type = 'object'\n\n    if arg_optional:\n        arg_type += '?'\n    if arg_default:\n        return f':param {arg_type} {arg_name}: {arg_desc} defaults to {arg_default}'\n    else:\n        return f':param {arg_type} {arg_name}: {arg_desc}'\n",
            "name_column": 4
        },
        "convert_rapidapi_desc_to_code": {
            "type": "FunctionDef",
            "name": "convert_rapidapi_desc_to_code",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 81,
            "parent": null,
            "have_return": true,
            "code_content": "def convert_rapidapi_desc_to_code(rapidapi_desc:dict)->list[dict]:\n    tool_desc = {\n        'category':rapidapi_desc['category'],\n        'tool_name':standardizing(rapidapi_desc['tool_name']),\n    }\n    api_infos = {}\n    for api_desc in rapidapi_desc['api_list']:\n        api_name = standardizing(api_desc['name'])\n        if api_name in ['from','class','return','false','true','id','and']:\n            api_name = 'is_'+ api_name\n        api_info = {'api_name':api_name}\n        api_info.update(tool_desc)\n        \n        api_uri = '_'.join(['rapi',tool_desc['tool_name'],api_name])\n        \n        \n        args_doc = []\n        \n        for param in api_desc['required_parameters']:\n            args_doc.append(generate_arg_doc(\n                param['name'],\n                param['type'],\n                param['description'],\n                param['default'] if 'default' in param else None,\n                ))\n        \n        for param in api_desc['optional_parameters']:\n            args_doc.append(generate_arg_doc(\n                param['name'],\n                param['type'],\n                param['description'],\n                param['default'] if 'default' in param else None,\n                True))\n        \n        args_doc = '\\n    '.join(args_doc)\n        code = f\"\"\"async def {api_uri}(self,*args,**kwargs):\n    '''{rapidapi_desc['tool_description']}\n    {api_info['description'] if 'description' in api_info else ''}\n    \n\n    {args_doc}\n    '''\n    return await self._request_rapid_api('{api_uri}',kwargs)\n        \"\"\"\n        api_info['code'] = code\n        \n        api_infos[api_uri] = api_info\n    return api_infos\n",
            "name_column": 4
        },
        "rapid_api_mapper": {
            "type": "FunctionDef",
            "name": "rapid_api_mapper",
            "md_content": "",
            "code_start_line": 83,
            "code_end_line": 103,
            "parent": null,
            "have_return": true,
            "code_content": "def rapid_api_mapper(cls:Type):\n    \"\"\"Dynamic adding api functions to RapidAPIENnv.\"\"\"\n    #reading api list\n    if not os.path.exists(CONFIG['rapidapi']['api_infos_json']):\n        try:\n            api_list = json.load(open(CONFIG['rapidapi']['api_raw_json']))\n        except:\n            raise FileNotFoundError(f'Both api_infos_json and api_raw_json are not found! Failed to setup RapidAPIEnv!')\n        \n        for rapidapi_desc in api_list:\n            API_INFOS.update(convert_rapidapi_desc_to_code(rapidapi_desc))\n        \n        json.dump(API_INFOS,open(CONFIG['rapidapi']['api_infos_json'],'w'),indent=4)\n    else:\n        API_INFOS.update(json.load(open(CONFIG['rapidapi']['api_infos_json'])))\n    \n    for api_uri,api_info in API_INFOS.items():\n        exec(api_info['code'])\n        setattr(cls,api_uri,eval(api_uri))\n    \n    return cls\n",
            "name_column": 4
        },
        "RapidAPIEnv": {
            "type": "ClassDef",
            "name": "RapidAPIEnv",
            "md_content": "",
            "code_start_line": 108,
            "code_end_line": 135,
            "parent": null,
            "have_return": true,
            "code_content": "class RapidAPIEnv(BaseEnv):\n    \"\"\"RapidAPI Env delivers rapid api for tool server.\"\"\"\n    \n    def __init__(self,config:dict={}):\n        super().__init__(config=config)\n        \n        self.rapidapi_cfg = self.config['rapidapi']\n        self.api_key = self.rapidapi_cfg['api_key']\n        self.endpoint = self.rapidapi_cfg['endpoint']\n        \n        self.api_infos = deepcopy(API_INFOS)\n        \n    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\n        api_info = self.api_infos[api_uri]\n        payload = {\n            'category':api_info['category'],\n            'tool_name':api_info['tool_name'],\n            'api_name':api_info['api_name'],\n            'tool_input':arguments,\n            'strip':'truncate',\n            'toolbench_key':self.api_key\n        }\n        async with httpx.AsyncClient() as client:\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\n        \n        response.raise_for_status()\n        \n        return response.json()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 111,
            "code_end_line": 118,
            "parent": "RapidAPIEnv",
            "have_return": false,
            "code_content": "    def __init__(self,config:dict={}):\n        super().__init__(config=config)\n        \n        self.rapidapi_cfg = self.config['rapidapi']\n        self.api_key = self.rapidapi_cfg['api_key']\n        self.endpoint = self.rapidapi_cfg['endpoint']\n        \n        self.api_infos = deepcopy(API_INFOS)\n",
            "name_column": 8
        },
        "_request_rapid_api": {
            "type": "AsyncFunctionDef",
            "name": "_request_rapid_api",
            "md_content": "",
            "code_start_line": 120,
            "code_end_line": 135,
            "parent": "RapidAPIEnv",
            "have_return": true,
            "code_content": "    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\n        api_info = self.api_infos[api_uri]\n        payload = {\n            'category':api_info['category'],\n            'tool_name':api_info['tool_name'],\n            'api_name':api_info['api_name'],\n            'tool_input':arguments,\n            'strip':'truncate',\n            'toolbench_key':self.api_key\n        }\n        async with httpx.AsyncClient() as client:\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\n        \n        response.raise_for_status()\n        \n        return response.json()\n",
            "name_column": 14
        }
    },
    "tests/test_run.py": {
        "mock_argv": {
            "type": "FunctionDef",
            "name": "mock_argv",
            "md_content": "**mock_argv**sys.argv\n\npytestfixturemonkeypatchsys.argvtest_args\"--task\", \"example_task\", \"--upload-files\", \"file1\", \"file2\", \"--model\", \"model1\"monkeypatch.setattr()sys.argv'test_script.py'test_args\n\n\n\n****\n- pytestpytest.fixture\n- mock_argv\n- ",
            "code_start_line": 7,
            "code_end_line": 13,
            "parent": null,
            "have_return": false,
            "code_content": "def mock_argv(monkeypatch):\n    \"\"\"\n    A pytest fixture to mock the command line arguments.\n    It sets the sys.argv to mimic command line input for testing.\n    \"\"\"\n    test_args = [\"--task\", \"example_task\", \"--upload-files\", \"file1\", \"file2\", \"--model\", \"model1\"]\n    monkeypatch.setattr(sys, 'argv', ['test_script.py'] + test_args)\n",
            "name_column": 4
        },
        "test_parse_args": {
            "type": "FunctionDef",
            "name": "test_parse_args",
            "md_content": "**test_parse_args**parse_args\n\nparse_argsargsargs\n\nargs.task\"example_task\"args.upload_files[\"file1\", \"file2\"]args.model\"model1\"\n\n****\n- \n- ",
            "code_start_line": 15,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "def test_parse_args(mock_argv):\n    \"\"\"\n    Test to ensure that the parse_args function correctly parses command line arguments.\n    \"\"\"\n    args = parse_args()\n    assert args.task == \"example_task\", \"Task argument did not match.\"\n    assert args.upload_files == [\"file1\", \"file2\"], \"Upload files argument did not match.\"\n    assert args.model == \"model1\", \"Model argument did not match.\"\n",
            "name_column": 4
        },
        "test_execute_command_line_process_quiet_mode": {
            "type": "FunctionDef",
            "name": "test_execute_command_line_process_quiet_mode",
            "md_content": "**test_execute_command_line_process_quiet_mode**execute_command_line_process'quiet_mode'\n\n\n1. parse_argsargs\n2. execute_command_line_processargsquiet_modeTrue\n3. assert_called_oncemock_start_command_line\n4. \"execute_command_line_process called start_command_line in quiet mode.\"\n\n****\n- execute_command_line_processquiet_mode\n- mock_start_command_linestart_command_line\n- quiet_modeTrueexecute_command_line_processquiet_mode",
            "code_start_line": 25,
            "code_end_line": 32,
            "parent": null,
            "have_return": false,
            "code_content": "def test_execute_command_line_process_quiet_mode(mock_start_command_line, mock_argv):\n    \"\"\"\n    Test to verify if the execute_command_line_process function correctly handles the 'quiet_mode' argument.\n    \"\"\"\n    args = parse_args()\n    execute_command_line_process(args, quiet_mode=True)\n    mock_start_command_line.assert_called_once()\n    print(\"execute_command_line_process called start_command_line in quiet mode.\")\n",
            "name_column": 4
        },
        "test_execute_command_line_process_normal_mode": {
            "type": "FunctionDef",
            "name": "test_execute_command_line_process_normal_mode",
            "md_content": "**test_execute_command_line_process_normal_mode**: execute_command_line_process'quiet_mode'\n\nexecute_command_line_process'quiet_mode'parse_argsargsexecute_command_line_processargsquiet_mode=Falsemock_start_command_line.assert_called_once()mock_start_command_line\"execute_command_line_process called start_command_line in normal mode.\"\n\n****: \n- execute_command_line_process'quiet_mode'\n- execute_command_line_processparse_args\n- mock_start_command_lineexecute_command_line_processstart_command_line\n- \"execute_command_line_process called start_command_line in normal mode.\"execute_command_line_processstart_command_line",
            "code_start_line": 35,
            "code_end_line": 42,
            "parent": null,
            "have_return": false,
            "code_content": "def test_execute_command_line_process_normal_mode(mock_start_command_line, mock_argv):\n    \"\"\"\n    Test to verify if the execute_command_line_process function behaves correctly without the 'quiet_mode' argument.\n    \"\"\"\n    args = parse_args()\n    execute_command_line_process(args, quiet_mode=False)\n    mock_start_command_line.assert_called_once()\n    print(\"execute_command_line_process called start_command_line in normal mode.\")\n",
            "name_column": 4
        },
        "test_start_command_line": {
            "type": "FunctionDef",
            "name": "test_start_command_line",
            "md_content": "**test_start_command_line**start_command_lineCommandLineCommandLineParam\n\nargsstart_command_lineargsstart_command_line\n\nmock_command_linemock_argvmock_command_linecalled_args_\n\ncalled_argscalled_param\n\ncalled_paramtaskargstaskupload_filesmodeargsupload_filesmode\n\nstart_command_lineCommandLineParam\n\n****\n- parse_argsstart_command_line\n- mock_command_linemock_argv\n- ",
            "code_start_line": 45,
            "code_end_line": 58,
            "parent": null,
            "have_return": false,
            "code_content": "def test_start_command_line(mock_command_line, mock_argv):\n    \"\"\"\n    Test to ensure the start_command_line function correctly initializes the CommandLine class\n    with the expected CommandLineParam instance based on the parsed arguments.\n    \"\"\"\n    args = parse_args()\n    start_command_line(vars(args))\n\n    called_args, _ = mock_command_line.call_args\n    called_param = called_args[0]\n    assert called_param.task == args.task, \"CommandLineParam task attribute did not match.\"\n    assert called_param.upload_files == args.upload_files, \"CommandLineParam upload_files attribute did not match.\"\n    assert called_param.mode == args.mode, \"CommandLineParam mode attribute did not match.\"\n    print(\"start_command_line function called with correct CommandLineParam.\")\n",
            "name_column": 4
        }
    },
    "tests/__init__.py": {},
    "tests/test_1106_model_openai.py": {
        "test_1106_model_openai": {
            "type": "FunctionDef",
            "name": "test_1106_model_openai",
            "md_content": "**test_1106_model_openai**: 1106OpenAI\n\nopenai_version\"1.0.0\"OpenAImock.patchOpenAImodel_dump()choices\"finish_reason\"\"index\"\"message\"chatcompletion_requestmodelpromptassert\n\nopenai_version\"1.0.0\"mock.patchChatCompletionchatcompletion_requestmodelpromptassert\n\nopenai_version\n\n****: \n- mock.patchOpenAIChatCompletion\n- assert\n\n****:\nYour OpenAI version is 1.0.0, Successful test",
            "code_start_line": 8,
            "code_end_line": 48,
            "parent": null,
            "have_return": true,
            "code_content": "def test_1106_model_openai():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n",
            "name_column": 4
        }
    },
    "tests/test_model_alias.py": {
        "test_model_alias": {
            "type": "FunctionDef",
            "name": "test_model_alias",
            "md_content": "**test_model_alias**\n\nopenai_version\"1.0.0\"mock.patchOpenAImock_response.model_dump.return_valuemodel_dump()choicesfinish_reasonindexmessagechatcompletion_requestmodelpromptresponseassertresponse\n\nopenai_version\"1.0.0\"mock.patchChatCompletionmock_response_datacreatechatcompletion_requestmodelpromptresponseassertresponse\n\nopenai_version\n\n****\n- mockOpenAI\n- openai_version\n\n****\n```\nYour OpenAI version is 1.0.0, Successful test\n```",
            "code_start_line": 8,
            "code_end_line": 48,
            "parent": null,
            "have_return": true,
            "code_content": "def test_model_alias():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n",
            "name_column": 4
        }
    },
    "XAgentServer/server.py": {
        "XAgentServer": {
            "type": "ClassDef",
            "name": "XAgentServer",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 109,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentServer:\n    \"\"\"XAgent Server Start Class\n    \"\"\"\n\n    def __init__(self, logger: Logger) -> None:\n        self.logger: Logger = logger\n\n    def interact(self, interaction: XAgentInteraction):\n        # query = message\n        \"\"\"\n        XAgent Server Start Function\n        \"\"\"\n        from XAgent.config import CONFIG as config\n        xagent_core = None\n        try:\n            config.reload()\n            args = {}\n            # args\n            args = interaction.parameter.args\n\n            self.logger.info(\n                f\"server is running, the start query is {args.get('goal', '')}\")\n            xagent_param = XAgentParam()\n\n            # build query\n            xagent_param.build_query({\n                \"role_name\": \"Assistant\",\n                \"task\": args.get(\"goal\", \"\"),\n                \"plan\": args.get(\"plan\", [\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\"]),\n            })\n            xagent_param.build_config(config)\n            xagent_core = XAgentCoreComponents()\n            # build XAgent Core Components\n            xagent_core.build(xagent_param, interaction=interaction)\n            json_str = json.dumps(\n                xagent_param.config.to_dict(), indent=2)\n            json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n            self.logger.info(json_str)\n            self.logger.typewriter_log(\n                \"Human-In-The-Loop\",\n                Fore.RED,\n                str(xagent_param.config.enable_ask_human_for_help),\n            )\n\n            file_list = interaction.base.file_list\n            for file in file_list:\n                file_uuid = file.get(\"uuid\", \"\")\n                file_name = file.get(\"name\", \"\")\n                if file_uuid.startswith(\"/\"):\n                    file_path = file_uuid\n                else:\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\n                                         interaction.base.user_id, file_uuid)\n\n                upload_dir = os.path.join(\n                    xagent_core.base_dir, \"upload\")\n                if not os.path.exists(upload_dir):\n                    os.makedirs(upload_dir)\n                # workspace\n                if interaction.call_method == \"web\":\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                else:\n                    if os.path.exists(file_path):\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\n                            # ,\n                            pass\n                        else:\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\n\n                new_file = os.path.join(upload_dir, file_name)\n                try:\n                    xagent_core.toolserver_interface.upload_file(new_file)\n                except Exception as e:\n                    self.logger.typewriter_log(\n                        \"Error happens when uploading file\",\n                        Fore.RED,\n                        f\"{new_file}\\n{e}\",\n                    )\n                    raise XAgentUploadFileError(str(e)) from e\n\n            task_handler = TaskHandler(xagent_core=xagent_core,\n                                       xagent_param=xagent_param)\n            self.logger.info(\"Start outer loop async\")\n            task_handler.outer_loop()\n        except Exception as e:\n            raise XAgentRunningError(str(e)) from e\n        finally:\n            if xagent_core is not None:\n                xagent_core.close()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 25,
            "parent": "XAgentServer",
            "have_return": false,
            "code_content": "    def __init__(self, logger: Logger) -> None:\n        self.logger: Logger = logger\n",
            "name_column": 8
        },
        "interact": {
            "type": "FunctionDef",
            "name": "interact",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 109,
            "parent": "XAgentServer",
            "have_return": false,
            "code_content": "    def interact(self, interaction: XAgentInteraction):\n        # query = message\n        \"\"\"\n        XAgent Server Start Function\n        \"\"\"\n        from XAgent.config import CONFIG as config\n        xagent_core = None\n        try:\n            config.reload()\n            args = {}\n            # args\n            args = interaction.parameter.args\n\n            self.logger.info(\n                f\"server is running, the start query is {args.get('goal', '')}\")\n            xagent_param = XAgentParam()\n\n            # build query\n            xagent_param.build_query({\n                \"role_name\": \"Assistant\",\n                \"task\": args.get(\"goal\", \"\"),\n                \"plan\": args.get(\"plan\", [\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\"]),\n            })\n            xagent_param.build_config(config)\n            xagent_core = XAgentCoreComponents()\n            # build XAgent Core Components\n            xagent_core.build(xagent_param, interaction=interaction)\n            json_str = json.dumps(\n                xagent_param.config.to_dict(), indent=2)\n            json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n            self.logger.info(json_str)\n            self.logger.typewriter_log(\n                \"Human-In-The-Loop\",\n                Fore.RED,\n                str(xagent_param.config.enable_ask_human_for_help),\n            )\n\n            file_list = interaction.base.file_list\n            for file in file_list:\n                file_uuid = file.get(\"uuid\", \"\")\n                file_name = file.get(\"name\", \"\")\n                if file_uuid.startswith(\"/\"):\n                    file_path = file_uuid\n                else:\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\n                                         interaction.base.user_id, file_uuid)\n\n                upload_dir = os.path.join(\n                    xagent_core.base_dir, \"upload\")\n                if not os.path.exists(upload_dir):\n                    os.makedirs(upload_dir)\n                # workspace\n                if interaction.call_method == \"web\":\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                else:\n                    if os.path.exists(file_path):\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\n                            # ,\n                            pass\n                        else:\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\n\n                new_file = os.path.join(upload_dir, file_name)\n                try:\n                    xagent_core.toolserver_interface.upload_file(new_file)\n                except Exception as e:\n                    self.logger.typewriter_log(\n                        \"Error happens when uploading file\",\n                        Fore.RED,\n                        f\"{new_file}\\n{e}\",\n                    )\n                    raise XAgentUploadFileError(str(e)) from e\n\n            task_handler = TaskHandler(xagent_core=xagent_core,\n                                       xagent_param=xagent_param)\n            self.logger.info(\"Start outer loop async\")\n            task_handler.outer_loop()\n        except Exception as e:\n            raise XAgentRunningError(str(e)) from e\n        finally:\n            if xagent_core is not None:\n                xagent_core.close()\n",
            "name_column": 8
        }
    },
    "XAgentServer/interaction.py": {
        "XAgentInteraction": {
            "type": "ClassDef",
            "name": "XAgentInteraction",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 302,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentInteraction(metaclass=abc.ABCMeta):\n    \"\"\"\n    XAgent , : XAgentCE\n    Attributes:\n        base: \n        parameter: \n        interrupt: \n        toolserver: \n        call_method: \n        wait_seconds: \n        \n    Components:\n        logger: \n        db: \n        recorder: \n        toolserver_interface: \n        \n    \n\n    \"\"\"\n\n    def __init__(\n        self,\n        base: InteractionBase,\n        parameter: InteractionParameter,\n        interrupt: bool = False,\n        call_method: str = \"web\",\n        wait_seconds: int = 600,\n    ) -> None:\n        self.base = base\n        self.parameter = parameter\n        # \n        self.current_step = uuid.uuid4().hex\n        self.logger = None\n        self.interrupt = interrupt\n        self.call_method = call_method\n        self.wait_seconds = wait_seconds\n        self.log_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.base.interaction_id)\n        self.human_data = None\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.extract_dir = os.path.join(self.log_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir)\n\n        self.db: Session = None\n        self.toolserver_interface = None\n\n    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\n        \"\"\"register tool server interface\"\"\"\n        self.toolserver_interface = toolserver_interface\n\n    def resister_logger(self, logger: Logger):\n        \"\"\"\n        logger, id, \n        \"\"\"\n\n        self.logger = logger\n        self.logger.info(f\"init interaction: {self.base.interaction_id}\")\n\n    def register_db(self, db: Session):\n        \"\"\"\n        db\n\n        Args:\n            db: Session\n        \"\"\"\n        self.db = db\n\n    def insert_data(self,\n                    data: dict,\n                    status=\"\",\n                    current: str = None,\n                    is_include_pictures: bool = False,):\n        \"\"\"\n        , \n        \"\"\"\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited.\")\n            exit(0)\n        self.current_step = uuid.uuid4().hex\n\n        if status == \"inner\":\n            tool_name = data.get(\"using_tools\", {}).get(\n                \"tool_name\", \"\") if isinstance(data, dict) else \"\"\n\n            if tool_name == \"subtask_submit\":\n                status = StatusEnum.SUBMIT\n\n        # download workspace files\n        self.download_files()\n\n        file_list = os.listdir(self.extract_dir)\n\n        # insert raw\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=current,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=status,\n            do_interrupt=self.interrupt,\n            wait_seconds=0,\n            ask_for_human_help=False,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=self.call_method != 'web',\n            is_receive=False,\n            include_pictures=is_include_pictures,\n        )\n        if status == StatusEnum.FINISHED:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=StatusEnum.FINISHED,\n                message=\"finished\",\n                current_step=self.current_step)\n        else:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=\"running\",\n                message=\"running\",\n                current_step=self.current_step)\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n        if self.call_method == \"web\":\n            redis.set_key(self.base.interaction_id + \"_send\", 1)\n        elif self.call_method == \"cmd\":\n            # print workspace file list\n            file_list_str = \", \".join(file_list) \n            self.logger.typewriter_log(\n                title=f\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\n\",\n                title_color=Fore.GREEN,\n                content=f\"[{file_list_str}] in {self.extract_dir}\"\n            )\n\n    def download_files(self):\n        \"\"\"download files\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        try:\n            save_path = self.toolserver_interface.download_all_files()\n\n            if os.path.exists(save_path):\n                zip_file = zipfile.ZipFile(save_path)\n                zip_list = zip_file.namelist()  # \n                for f in zip_list:\n                    zip_file.extract(f, self.extract_dir)  # \n\n                zip_file.close()\n            return True\n        except zipfile.BadZipFile:\n            return False\n\n    def receive(self, can_modify=None):\n        \"\"\"\n        \n        \"\"\"\n\n        if self.call_method == \"web\":\n            wait = 0\n            while wait < self.wait_seconds:\n                human_data = self.get_human_data()\n                if human_data is not None:\n                    return human_data\n                else:\n                    wait += 2\n                    time.sleep(2)\n\n            raise XAgentTimeoutError(\"\")\n        else:\n            print(can_modify)\n\n    def get_human_data(self):\n        \"\"\"\n        \n        \"\"\"\n        # check alive, ensure the interaction is alive\n        # if The user terminated this action and exited\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n        receive_key = self.base.interaction_id + \"_\" + self.current_step + \"_receive\"\n        is_receive = redis.get_key(receive_key)\n\n        if is_receive:\n            raw = InteractionCRUD.get_raw(\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\n\n            if raw and raw.is_human and raw.is_receive:\n                redis.delete_key(receive_key)\n                return raw.human_data\n\n        return None\n\n    def ask_for_human_help(self, data):\n        \"\"\"\n        Execute the tool and ask for human help\n        \"\"\"\n\n        self.current_step = uuid.uuid4().hex\n        self.download_files()\n        file_list = os.listdir(self.extract_dir)\n        # special: ask for human help and do interrupt\n        # send data\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=self.current_step,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            do_interrupt=True,\n            wait_seconds=0,\n            ask_for_human_help=True,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=False,\n            is_receive=False,\n            include_pictures=False,\n        )\n\n        # insert into mysql\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n\n        # set redis\n        redis.set_key(self.base.interaction_id + \"_send\", 1)\n\n        # set status\n\n        InteractionCRUD.update_interaction_status(\n            db=self.db,\n            interaction_id=self.base.interaction_id,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            message=\"ask for human help\",\n            current_step=self.current_step)\n\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n\n        # wait for human data\n        wait = 0\n        while wait < self.wait_seconds:\n            human_data = self.get_human_data()\n            if human_data is not None:\n                return human_data\n            else:\n                wait += 2\n                time.sleep(2)\n\n        raise XAgentTimeoutError(\"ASK-For-Human-Data: \")\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 79,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        base: InteractionBase,\n        parameter: InteractionParameter,\n        interrupt: bool = False,\n        call_method: str = \"web\",\n        wait_seconds: int = 600,\n    ) -> None:\n        self.base = base\n        self.parameter = parameter\n        # \n        self.current_step = uuid.uuid4().hex\n        self.logger = None\n        self.interrupt = interrupt\n        self.call_method = call_method\n        self.wait_seconds = wait_seconds\n        self.log_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.base.interaction_id)\n        self.human_data = None\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.extract_dir = os.path.join(self.log_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir)\n\n        self.db: Session = None\n        self.toolserver_interface = None\n",
            "name_column": 8
        },
        "register_toolserver_interface": {
            "type": "FunctionDef",
            "name": "register_toolserver_interface",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 83,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\n        \"\"\"register tool server interface\"\"\"\n        self.toolserver_interface = toolserver_interface\n",
            "name_column": 8
        },
        "resister_logger": {
            "type": "FunctionDef",
            "name": "resister_logger",
            "md_content": "",
            "code_start_line": 85,
            "code_end_line": 91,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def resister_logger(self, logger: Logger):\n        \"\"\"\n        logger, id, \n        \"\"\"\n\n        self.logger = logger\n        self.logger.info(f\"init interaction: {self.base.interaction_id}\")\n",
            "name_column": 8
        },
        "register_db": {
            "type": "FunctionDef",
            "name": "register_db",
            "md_content": "",
            "code_start_line": 93,
            "code_end_line": 100,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def register_db(self, db: Session):\n        \"\"\"\n        db\n\n        Args:\n            db: Session\n        \"\"\"\n        self.db = db\n",
            "name_column": 8
        },
        "insert_data": {
            "type": "FunctionDef",
            "name": "insert_data",
            "md_content": "",
            "code_start_line": 102,
            "code_end_line": 175,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def insert_data(self,\n                    data: dict,\n                    status=\"\",\n                    current: str = None,\n                    is_include_pictures: bool = False,):\n        \"\"\"\n        , \n        \"\"\"\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited.\")\n            exit(0)\n        self.current_step = uuid.uuid4().hex\n\n        if status == \"inner\":\n            tool_name = data.get(\"using_tools\", {}).get(\n                \"tool_name\", \"\") if isinstance(data, dict) else \"\"\n\n            if tool_name == \"subtask_submit\":\n                status = StatusEnum.SUBMIT\n\n        # download workspace files\n        self.download_files()\n\n        file_list = os.listdir(self.extract_dir)\n\n        # insert raw\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=current,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=status,\n            do_interrupt=self.interrupt,\n            wait_seconds=0,\n            ask_for_human_help=False,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=self.call_method != 'web',\n            is_receive=False,\n            include_pictures=is_include_pictures,\n        )\n        if status == StatusEnum.FINISHED:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=StatusEnum.FINISHED,\n                message=\"finished\",\n                current_step=self.current_step)\n        else:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=\"running\",\n                message=\"running\",\n                current_step=self.current_step)\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n        if self.call_method == \"web\":\n            redis.set_key(self.base.interaction_id + \"_send\", 1)\n        elif self.call_method == \"cmd\":\n            # print workspace file list\n            file_list_str = \", \".join(file_list) \n            self.logger.typewriter_log(\n                title=f\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\n\",\n                title_color=Fore.GREEN,\n                content=f\"[{file_list_str}] in {self.extract_dir}\"\n            )\n",
            "name_column": 8
        },
        "download_files": {
            "type": "FunctionDef",
            "name": "download_files",
            "md_content": "",
            "code_start_line": 177,
            "code_end_line": 195,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def download_files(self):\n        \"\"\"download files\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        try:\n            save_path = self.toolserver_interface.download_all_files()\n\n            if os.path.exists(save_path):\n                zip_file = zipfile.ZipFile(save_path)\n                zip_list = zip_file.namelist()  # \n                for f in zip_list:\n                    zip_file.extract(f, self.extract_dir)  # \n\n                zip_file.close()\n            return True\n        except zipfile.BadZipFile:\n            return False\n",
            "name_column": 8
        },
        "receive": {
            "type": "FunctionDef",
            "name": "receive",
            "md_content": "",
            "code_start_line": 197,
            "code_end_line": 214,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def receive(self, can_modify=None):\n        \"\"\"\n        \n        \"\"\"\n\n        if self.call_method == \"web\":\n            wait = 0\n            while wait < self.wait_seconds:\n                human_data = self.get_human_data()\n                if human_data is not None:\n                    return human_data\n                else:\n                    wait += 2\n                    time.sleep(2)\n\n            raise XAgentTimeoutError(\"\")\n        else:\n            print(can_modify)\n",
            "name_column": 8
        },
        "get_human_data": {
            "type": "FunctionDef",
            "name": "get_human_data",
            "md_content": "",
            "code_start_line": 216,
            "code_end_line": 237,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def get_human_data(self):\n        \"\"\"\n        \n        \"\"\"\n        # check alive, ensure the interaction is alive\n        # if The user terminated this action and exited\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n        receive_key = self.base.interaction_id + \"_\" + self.current_step + \"_receive\"\n        is_receive = redis.get_key(receive_key)\n\n        if is_receive:\n            raw = InteractionCRUD.get_raw(\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\n\n            if raw and raw.is_human and raw.is_receive:\n                redis.delete_key(receive_key)\n                return raw.human_data\n\n        return None\n",
            "name_column": 8
        },
        "ask_for_human_help": {
            "type": "FunctionDef",
            "name": "ask_for_human_help",
            "md_content": "",
            "code_start_line": 239,
            "code_end_line": 302,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def ask_for_human_help(self, data):\n        \"\"\"\n        Execute the tool and ask for human help\n        \"\"\"\n\n        self.current_step = uuid.uuid4().hex\n        self.download_files()\n        file_list = os.listdir(self.extract_dir)\n        # special: ask for human help and do interrupt\n        # send data\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=self.current_step,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            do_interrupt=True,\n            wait_seconds=0,\n            ask_for_human_help=True,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=False,\n            is_receive=False,\n            include_pictures=False,\n        )\n\n        # insert into mysql\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n\n        # set redis\n        redis.set_key(self.base.interaction_id + \"_send\", 1)\n\n        # set status\n\n        InteractionCRUD.update_interaction_status(\n            db=self.db,\n            interaction_id=self.base.interaction_id,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            message=\"ask for human help\",\n            current_step=self.current_step)\n\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n\n        # wait for human data\n        wait = 0\n        while wait < self.wait_seconds:\n            human_data = self.get_human_data()\n            if human_data is not None:\n                return human_data\n            else:\n                wait += 2\n                time.sleep(2)\n\n        raise XAgentTimeoutError(\"ASK-For-Human-Data: \")\n",
            "name_column": 8
        }
    },
    "XAgentServer/exts/redis_ext.py": {
        "RedisClient": {
            "type": "ClassDef",
            "name": "RedisClient",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 135,
            "parent": null,
            "have_return": true,
            "code_content": "class RedisClient:\n    \"\"\"\n    RedisClient\n    \"\"\"\n\n    def __init__(self):\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\n                            port=XAgentServerEnv.Redis.redis_port,\n                            db=XAgentServerEnv.Redis.redis_db,\n                            password=XAgentServerEnv.Redis.redis_password)\n\n    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\n        \"\"\"redis set key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n            ex (_type_, optional): _description_. Defaults to None.\n            px (_type_, optional): _description_. Defaults to None.\n            nx (bool, optional): _description_. Defaults to False.\n            xx (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        self.client.set(key, value, ex, px, nx, xx)\n\n    def get_key(self, key):\n        \"\"\"redis get key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        value = self.client.get(key)\n        if value:\n            return value.decode(\"utf-8\")\n        else:\n            return None\n\n    def delete_key(self, key):\n        \"\"\"redis delete key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n\n    def get_all_keys(self):\n        \"\"\"redis get all keys\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.keys()\n\n    def delete_all_keys(self):\n        \"\"\"redis delete all keys\n        \"\"\"\n        self.client.flushdb()\n\n    def set_parent_key(self, key, value):\n        \"\"\"redis set parent key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        self.client.set(key, value)\n\n    def get_parent_key(self, key):\n        \"\"\"redis get parent key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n\n    def delete_parent_key(self, key):\n        \"\"\"redis delete parent key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n\n    def set_child_key(self, parent_key, key, value):\n        \"\"\"redis set child key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        parent = self.client.get(parent_key)\n        if parent:\n            parent[key] = value\n        else:\n            parent = {key: value}\n        self.set_key(parent_key, parent)\n        \n    def get_child_key(self, key):\n        \"\"\"redis get child key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n\n    def delete_child_key(self, key):\n        \"\"\"redis delete child key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n\n    def get_child_keys(self, parent_key):\n        \"\"\"\n\n        Args:\n            parent_key (_type_): _description_\n        \"\"\"\n        return self.client.keys(parent_key)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 17,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def __init__(self):\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\n                            port=XAgentServerEnv.Redis.redis_port,\n                            db=XAgentServerEnv.Redis.redis_db,\n                            password=XAgentServerEnv.Redis.redis_password)\n",
            "name_column": 8
        },
        "set_key": {
            "type": "FunctionDef",
            "name": "set_key",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\n        \"\"\"redis set key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n            ex (_type_, optional): _description_. Defaults to None.\n            px (_type_, optional): _description_. Defaults to None.\n            nx (bool, optional): _description_. Defaults to False.\n            xx (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        self.client.set(key, value, ex, px, nx, xx)\n",
            "name_column": 8
        },
        "get_key": {
            "type": "FunctionDef",
            "name": "get_key",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 45,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_key(self, key):\n        \"\"\"redis get key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        value = self.client.get(key)\n        if value:\n            return value.decode(\"utf-8\")\n        else:\n            return None\n",
            "name_column": 8
        },
        "delete_key": {
            "type": "FunctionDef",
            "name": "delete_key",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 53,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_key(self, key):\n        \"\"\"redis delete key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n",
            "name_column": 8
        },
        "get_all_keys": {
            "type": "FunctionDef",
            "name": "get_all_keys",
            "md_content": "",
            "code_start_line": 55,
            "code_end_line": 61,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_all_keys(self):\n        \"\"\"redis get all keys\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.keys()\n",
            "name_column": 8
        },
        "delete_all_keys": {
            "type": "FunctionDef",
            "name": "delete_all_keys",
            "md_content": "",
            "code_start_line": 63,
            "code_end_line": 66,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_all_keys(self):\n        \"\"\"redis delete all keys\n        \"\"\"\n        self.client.flushdb()\n",
            "name_column": 8
        },
        "set_parent_key": {
            "type": "FunctionDef",
            "name": "set_parent_key",
            "md_content": "",
            "code_start_line": 68,
            "code_end_line": 75,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def set_parent_key(self, key, value):\n        \"\"\"redis set parent key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        self.client.set(key, value)\n",
            "name_column": 8
        },
        "get_parent_key": {
            "type": "FunctionDef",
            "name": "get_parent_key",
            "md_content": "",
            "code_start_line": 77,
            "code_end_line": 86,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_parent_key(self, key):\n        \"\"\"redis get parent key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n",
            "name_column": 8
        },
        "delete_parent_key": {
            "type": "FunctionDef",
            "name": "delete_parent_key",
            "md_content": "",
            "code_start_line": 88,
            "code_end_line": 94,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_parent_key(self, key):\n        \"\"\"redis delete parent key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n",
            "name_column": 8
        },
        "set_child_key": {
            "type": "FunctionDef",
            "name": "set_child_key",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 108,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def set_child_key(self, parent_key, key, value):\n        \"\"\"redis set child key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        parent = self.client.get(parent_key)\n        if parent:\n            parent[key] = value\n        else:\n            parent = {key: value}\n        self.set_key(parent_key, parent)\n",
            "name_column": 8
        },
        "get_child_key": {
            "type": "FunctionDef",
            "name": "get_child_key",
            "md_content": "",
            "code_start_line": 110,
            "code_end_line": 119,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_child_key(self, key):\n        \"\"\"redis get child key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n",
            "name_column": 8
        },
        "delete_child_key": {
            "type": "FunctionDef",
            "name": "delete_child_key",
            "md_content": "",
            "code_start_line": 121,
            "code_end_line": 127,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_child_key(self, key):\n        \"\"\"redis delete child key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n",
            "name_column": 8
        },
        "get_child_keys": {
            "type": "FunctionDef",
            "name": "get_child_keys",
            "md_content": "",
            "code_start_line": 129,
            "code_end_line": 135,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_child_keys(self, parent_key):\n        \"\"\"\n\n        Args:\n            parent_key (_type_): _description_\n        \"\"\"\n        return self.client.keys(parent_key)\n",
            "name_column": 8
        }
    },
    "XAgentServer/exts/mail_ext.py": {
        "email_content": {
            "type": "FunctionDef",
            "name": "email_content",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 22,
            "parent": null,
            "have_return": true,
            "code_content": "def email_content(user):\n    html_body = f\"\"\"\n<body style=\"font-family: Arial, sans-serif;background-color: #f5f5f5;margin: 0; padding: 0;\">\n    <div style=\"background-color: #ffffff;margin: 0 auto;padding: 20px;border-radius: 10px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\">\n        <h1 style=\"font-size: 28px;margin-bottom: 20px;\">Hello {user['name']},</h1>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Welcome to XAgent, your personal assistant! Thanks for signing up for XAgent. There are some information about your account:</p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Your XAgent Account: <b>{user[\"email\"]}</b></p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">You need to use this token for authentication on subsequent logins: </p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">You need to use this token for authentication on subsequent logins: </p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Token: <b>{user[\"token\"]}</b></p>\n        \n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Next is an activation link. You need to click on this link to activate your account. After that, you will be able to use XAgent happily:<a href=\"{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\"user_id\"]}&token={user[\"token\"]}\">{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\"user_id\"]}&token={user[\"token\"]}</a>! This Verification link will expire in 7 days.</p>\n        <p>If you have any questions, please contact us at yourxagent@gmail.com .</p>\n        <p style=\"margin-top: 20px;font-size: 14px;color: #999999;text-indent:2em;\">Best wishes!</p>\n        <p style=\"margin-top: 20px;font-size: 14px;color: #999999;\">XAgent Team</p>\n    </div>\n</body>\"\"\"\n    return html_body\n",
            "name_column": 4
        }
    },
    "XAgentServer/exts/exception_ext.py": {
        "XAgentError": {
            "type": "ClassDef",
            "name": "XAgentError",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 8,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentError(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    def __init__(self, message=\"XAgent Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentTimeoutError": {
            "type": "ClassDef",
            "name": "XAgentTimeoutError",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 20,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentTimeoutError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentTimeout!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentCloseError": {
            "type": "ClassDef",
            "name": "XAgentCloseError",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 32,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentCloseError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentClose!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketError",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketTimeoutError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketTimeoutError",
            "md_content": "",
            "code_start_line": 45,
            "code_end_line": 54,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketTimeoutError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Timeout!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketDisconnectError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketDisconnectError",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 66,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketDisconnectError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Disconnect!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketConnectError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketConnectError",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 78,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketConnectError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Connect Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketCloseError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketCloseError",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 90,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketCloseError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Close!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketSendError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketSendError",
            "md_content": "",
            "code_start_line": 93,
            "code_end_line": 102,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketSendError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Send Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketReceiveError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketReceiveError",
            "md_content": "",
            "code_start_line": 105,
            "code_end_line": 114,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketReceiveError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Receive Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentFileError": {
            "type": "ClassDef",
            "name": "XAgentFileError",
            "md_content": "",
            "code_start_line": 117,
            "code_end_line": 126,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentFileError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentDownloadFileError": {
            "type": "ClassDef",
            "name": "XAgentDownloadFileError",
            "md_content": "",
            "code_start_line": 129,
            "code_end_line": 138,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentDownloadFileError(XAgentFileError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"Download File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWorkspaceFileError": {
            "type": "ClassDef",
            "name": "XAgentWorkspaceFileError",
            "md_content": "",
            "code_start_line": 141,
            "code_end_line": 150,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWorkspaceFileError(XAgentFileError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Workspace File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentUploadFileError": {
            "type": "ClassDef",
            "name": "XAgentUploadFileError",
            "md_content": "",
            "code_start_line": 153,
            "code_end_line": 162,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentUploadFileError(XAgentFileError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Workspace Upload File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentDBError": {
            "type": "ClassDef",
            "name": "XAgentDBError",
            "md_content": "",
            "code_start_line": 165,
            "code_end_line": 174,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentDBError(XAgentError):\n    \"\"\"Exception raised because of DB error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent DB Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentAuthError": {
            "type": "ClassDef",
            "name": "XAgentAuthError",
            "md_content": "",
            "code_start_line": 177,
            "code_end_line": 186,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentAuthError(XAgentError):\n    \"\"\"Exception raised because of auth error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Auth Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentRunningError": {
            "type": "ClassDef",
            "name": "XAgentRunningError",
            "md_content": "",
            "code_start_line": 189,
            "code_end_line": 198,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentRunningError(XAgentError):\n    \"\"\"Exception raised because of Running error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Running Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebError": {
            "type": "ClassDef",
            "name": "XAgentWebError",
            "md_content": "",
            "code_start_line": 201,
            "code_end_line": 210,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebError(XAgentError):\n    \"\"\"Exception raised because of Running error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent WEB Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 208,
            "code_end_line": 210,
            "parent": "XAgentWebError",
            "have_return": false,
            "code_content": "    def __init__(self, message=\"XAgent WEB Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 8
        }
    },
    "XAgentServer/database/models.py": {
        "User": {
            "type": "ClassDef",
            "name": "User",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "class User(Base):\n    \"\"\"XAgent Users\"\"\"\n    __tablename__=\"users\"\n\n    id=Column(Integer,primary_key=True,index=True)\n    user_id = Column(String(32), unique=True, index=True)\n    email = Column(String(255), unique=True)\n    name = Column(String(255))\n    token = Column(String(255))\n    available = Column(Boolean, default=True)\n    is_beta = Column(Boolean, default=False)\n    deleted = Column(Boolean, default=False)\n    corporation = Column(Text)\n    industry = Column(Text)\n    position = Column(String(255))\n    create_time = Column(String(255))\n    update_time = Column(String(255))\n",
            "name_column": 6
        },
        "Interaction": {
            "type": "ClassDef",
            "name": "Interaction",
            "md_content": "",
            "code_start_line": 25,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "class Interaction(Base):\n    \"\"\"XAgent Interactions\"\"\"\n    __tablename__ = \"interactions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    interaction_id = Column(String(255))\n    user_id = Column(String(255))\n    create_time = Column(String(255))\n    update_time = Column(String(255))\n    description = Column(Text)\n    agent = Column(String(255))\n    mode = Column(String(255))\n    recorder_root_dir = Column(Text)\n    file_list = Column(JSON)\n    status = Column(String(255))\n    message = Column(Text)\n    current_step = Column(String(255))\n    is_deleted = Column(Boolean, default=False)\n    call_method = Column(String(255), default=\"web\")\n",
            "name_column": 6
        },
        "Parameter": {
            "type": "ClassDef",
            "name": "Parameter",
            "md_content": "",
            "code_start_line": 46,
            "code_end_line": 53,
            "parent": null,
            "have_return": false,
            "code_content": "class Parameter(Base):\n    \"\"\"XAgent Parameters\"\"\"\n    __tablename__ = \"interaction_parameters\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    interaction_id = Column(String(32), unique=True, index=True)\n    parameter_id = Column(String(32))\n    args = Column(JSON)\n",
            "name_column": 6
        },
        "SharedInteraction": {
            "type": "ClassDef",
            "name": "SharedInteraction",
            "md_content": "",
            "code_start_line": 56,
            "code_end_line": 70,
            "parent": null,
            "have_return": false,
            "code_content": "class SharedInteraction(Base):\n    \"\"\"Commnunity Shared Interactions\"\"\"\n    __tablename__ = \"shared_interactions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    interaction_id = Column(String(255))\n    user_name = Column(String(255))\n    create_time = Column(String(255))\n    update_time = Column(String(255))\n    description = Column(Text)\n    agent = Column(String(255))\n    mode = Column(String(255))\n    is_deleted = Column(Boolean, default=False)\n    star = Column(Integer, default=0)\n    is_audit = Column(Boolean, default=False)\n",
            "name_column": 6
        },
        "Raw": {
            "type": "ClassDef",
            "name": "Raw",
            "md_content": "",
            "code_start_line": 73,
            "code_end_line": 115,
            "parent": null,
            "have_return": false,
            "code_content": "class Raw(Base):\n    \"\"\"Raw Data\"\"\"\n    __tablename__ = \"raw\"\n    # id/id\n    id = Column(Integer, primary_key=True, index=True)\n    # node_id\n    node_id = Column(String(255))\n    # id/interaction_id\n    interaction_id = Column(String(255))\n    # /current\n    current = Column(String(128))\n    # step/step\n    step = Column(Integer, default=0)\n    # /agent data\n    data = Column(JSON)\n    # workspace/workspace file list\n    file_list = Column(JSON)\n    # /status\n    status = Column(String(20))\n    # /interrupt or not\n    do_interrupt = Column(Boolean, default=False)\n    # /wait seconds\n    wait_seconds = Column(Integer, default=0)\n    # /ask for human help or not\n    ask_for_human_help = Column(Boolean, default=False)\n    # /create time\n    create_time = Column(String(255))\n    # /update time\n    update_time = Column(String(255))\n    # /is deleted or not\n    is_deleted = Column(Boolean, default=False)\n    # /has human input or not\n    is_human = Column(Boolean, default=False)\n    # /human data\n    human_data = Column(JSON)\n    # /agent file list\n    human_file_list = Column(JSON)\n    # /has send to frontend or not\n    is_send = Column(Boolean, default=False)\n    # /has receive message from frontend or not\n    is_receive = Column(Boolean, default=False)\n    # png/has png or not\n    include_pictures = Column(Boolean, default=False)\n",
            "name_column": 6
        },
        "RunningRecord": {
            "type": "ClassDef",
            "name": "RunningRecord",
            "md_content": "",
            "code_start_line": 118,
            "code_end_line": 138,
            "parent": null,
            "have_return": false,
            "code_content": "class RunningRecord(Base):\n    \"\"\"Running Record\"\"\"\n    __tablename__ = \"running_record\"\n    # id/id\n    id = Column(Integer, primary_key=True, index=True)\n    # record_id/record_id\n    record_id = Column(String(255))\n    # /current\n    current = Column(String(255))\n    # id/node_id\n    node_id = Column(String(255))\n    # /node_type, options: [now_subtask_id, llm_input_pair, tool_server_pair, query, config]\n    node_type = Column(String(255))\n    # data/agent data\n    data = Column(JSON)\n    # /create time\n    create_time = Column(String(255))\n    # /update time\n    update_time = Column(String(255))\n    # /is deleted or not\n    is_deleted = Column(Boolean, default=False)\n",
            "name_column": 6
        }
    },
    "XAgentServer/database/connect.py": {},
    "XAgentServer/database/__init__.py": {},
    "XAgentServer/database/interface/user.py": {
        "UserDBInterface": {
            "type": "ClassDef",
            "name": "UserDBInterface",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 160,
            "parent": null,
            "have_return": true,
            "code_content": "class UserDBInterface(metaclass=abc.ABCMeta):\n    \"\"\"User DB Interface\n\n    Args:\n        UserBaseInterface (_type_): _description_\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\n    \"\"\"\n\n    @classmethod\n    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"get all users\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentUser]: user list\n        \"\"\"\n        users = db.query(User).all()\n        return [XAgentUser.from_db(user) for user in users]\n\n    @classmethod\n    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"get user by user_id or email\n\n        Args:\n            db (Session): db\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentUser | None: user, if user is not exist, return None\n        \"\"\"\n        if email is not None:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n\n        return XAgentUser.from_db(user) if user else None\n\n    @classmethod\n    def is_exist(cls,\n                db: Session,\n                user_id: str | None = None,\n                email: str | None = None):\n        \"\"\"user is exist?\n\n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not email and not user_id:\n            return False\n        if email:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n        return user is not None\n\n    @classmethod\n    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"token is exist?\n        \n        Args:\n            db (Session): db session\n            user_id (str): user id\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not token:\n            return False\n\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        return user is not None\n\n    @classmethod\n    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        user is valid?\n        \n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if email == \"\":\n            return False\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        if user is None:\n            return False\n        if token is None:\n            if user.email == email and user.available:\n                return True\n        if user_id is not None:\n            if user.user_id == user_id and user.token == token and user.available:\n                return True\n        if email is not None:\n            if user.email == email and user.token == token and user.available:\n                return True\n        return False\n\n    @classmethod\n    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \"\"\"\n        db.add(User(**user_dict))\n        db.commit()\n\n    @classmethod\n    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \"\"\"\n        db_user = db.query(User).filter(\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\n\n        db_user.available = user.available\n        db_user.email = user.email\n        db_user.name = user.name\n        db_user.token = user.token\n        db_user.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 6
        },
        "get_user_list": {
            "type": "FunctionDef",
            "name": "get_user_list",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 32,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"get all users\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentUser]: user list\n        \"\"\"\n        users = db.query(User).all()\n        return [XAgentUser.from_db(user) for user in users]\n",
            "name_column": 8
        },
        "get_user": {
            "type": "FunctionDef",
            "name": "get_user",
            "md_content": "",
            "code_start_line": 35,
            "code_end_line": 56,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"get user by user_id or email\n\n        Args:\n            db (Session): db\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentUser | None: user, if user is not exist, return None\n        \"\"\"\n        if email is not None:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n\n        return XAgentUser.from_db(user) if user else None\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 59,
            "code_end_line": 81,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def is_exist(cls,\n                db: Session,\n                user_id: str | None = None,\n                email: str | None = None):\n        \"\"\"user is exist?\n\n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not email and not user_id:\n            return False\n        if email:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n        return user is not None\n",
            "name_column": 8
        },
        "token_is_exist": {
            "type": "FunctionDef",
            "name": "token_is_exist",
            "md_content": "",
            "code_start_line": 84,
            "code_end_line": 103,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"token is exist?\n        \n        Args:\n            db (Session): db session\n            user_id (str): user id\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not token:\n            return False\n\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        return user is not None\n",
            "name_column": 8
        },
        "user_is_valid": {
            "type": "FunctionDef",
            "name": "user_is_valid",
            "md_content": "",
            "code_start_line": 106,
            "code_end_line": 137,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        user is valid?\n        \n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if email == \"\":\n            return False\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        if user is None:\n            return False\n        if token is None:\n            if user.email == email and user.available:\n                return True\n        if user_id is not None:\n            if user.user_id == user_id and user.token == token and user.available:\n                return True\n        if email is not None:\n            if user.email == email and user.token == token and user.available:\n                return True\n        return False\n",
            "name_column": 8
        },
        "add_user": {
            "type": "FunctionDef",
            "name": "add_user",
            "md_content": "",
            "code_start_line": 140,
            "code_end_line": 145,
            "parent": "UserDBInterface",
            "have_return": false,
            "code_content": "    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \"\"\"\n        db.add(User(**user_dict))\n        db.commit()\n",
            "name_column": 8
        },
        "update_user": {
            "type": "FunctionDef",
            "name": "update_user",
            "md_content": "",
            "code_start_line": 148,
            "code_end_line": 160,
            "parent": "UserDBInterface",
            "have_return": false,
            "code_content": "    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \"\"\"\n        db_user = db.query(User).filter(\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\n\n        db_user.available = user.available\n        db_user.email = user.email\n        db_user.name = user.name\n        db_user.token = user.token\n        db_user.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        }
    },
    "XAgentServer/database/interface/interaction.py": {
        "InteractionDBInterface": {
            "type": "ClassDef",
            "name": "InteractionDBInterface",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 559,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionDBInterface(metaclass=abc.ABCMeta):\n    \"\"\"Interaction DB Interface\n    \"\"\"\n\n    @classmethod\n    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\n        \"\"\"search many interactions\n\n        Args:\n            db (Session): db session\n\n        Returns:\n            list[InteractionBase]: interaction list\n        \"\"\"\n        interactions = db.query(Interaction).all()\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\n\n    @classmethod\n    def get_interaction(cls,\n                        db: Session,\n                        interaction_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by interaction_id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_not(True)).first()\n        return InteractionBase.from_db(interaction) if interaction else None\n\n    @classmethod\n    def get_ready_interaction(cls,\n                              db: Session,\n                              user_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by user_id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status == 'ready').first()\n        return InteractionBase.from_db(interaction) if interaction else None\n\n    @classmethod\n    def create_interaction(cls,\n                           db: Session,\n                           base: InteractionBase) -> InteractionBase:\n        \"\"\"\n        create interaction\n\n        Args:\n            db (Session): db session\n            base (InteractionBase): interaction base\n\n        Returns:\n            None\n        \"\"\"\n        db.add(Interaction(**base.to_dict()))\n        db.commit()\n        return None\n\n    @classmethod\n    def add_parameter(cls,\n                      db: Session,\n                      parameter: InteractionParameter):\n        \"\"\"\n        add parameter for interaction\n        \"\"\"\n        db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n\n        return None\n\n    @classmethod\n    def search_interaction_by_user_id(cls,\n                                      db: Session,\n                                      user_id: str,\n                                      page_size: int = 20,\n                                      page_num: int = 1) -> list[dict]:\n        \"\"\"\n        search interaction by user id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n            page_size (int, optional): page size. Defaults to 20.\n            page_num (int, optional): page num. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(Interaction.id)).filter(\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\n\n        interaction_list = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.is_deleted.is_(False),\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\n            page_size).offset((page_num - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = InteractionBase.from_db(interaction).to_dict(\n                exclude=[\"recorder_root_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = [parameter[0]]\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n\n    @classmethod\n    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared interactions from community\n\n        Args:\n            db (Session): db session\n            page_size (int, optional): page size. Defaults to 20.\n            page_index (int, optional): page index. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(SharedInteraction.id)).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).scalar()\n        interaction_list = db.query(SharedInteraction).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).order_by(\n            SharedInteraction.star.desc()).limit(page_size).offset(\n                (page_index - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\n                exclude=[\"record_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = parameter\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n\n    @classmethod\n    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> SharedInteractionBase | None:\n        \"\"\"\n        get shared interaction by interaction id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n\n            SharedInteractionBase | None: shared interaction\n        \"\"\"\n        interaction = db.query(SharedInteraction).filter(\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\n        return SharedInteractionBase.from_db(interaction) if interaction else None\n\n    @classmethod\n    def is_exist(cls,\n                 db: Session,\n                 interaction_id: str) -> bool:\n        \"\"\"\n        check interaction is exist or not\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_(False)).first()\n        return interaction is not None\n\n    @classmethod\n    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n\n        Args:\n            db (Session): db session\n            base_data (dict): interaction data\n\n        Returns:\n            None\n        \"\"\"\n        if \"interaction_id\" not in base_data:\n            raise XAgentError(\"interaction_id is required\")\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == base_data[\"interaction_id\"]).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        for k, v in base_data.items():\n            if k == \"interaction_id\":\n                continue\n            setattr(interaction, k, v)\n        interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            status (str): status\n            message (str): message\n            current_step (int): current step\n\n        Returns:\n            None\n        \"\"\"\n        db_interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if db_interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        db_interaction.status = status\n        db_interaction.message = message\n        db_interaction.current_step = current_step\n        db_interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            parameter (InteractionParameter): parameter\n\n        Returns:\n            None\n        \"\"\"\n        db_parameter = db.query(Parameter).filter(\n            Parameter.interaction_id == interaction_id,\n            Parameter.parameter_id == parameter.parameter_id).first()\n\n        if db_parameter is None:\n            db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n\n    @classmethod\n    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        check user is only running one interaction\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:    \n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status.in_((\"running\", \"waiting\"))).first()\n        return interaction is not None\n\n    @classmethod\n    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get interaction running parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list: parameter list\n        \"\"\"\n        raws = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_human.is_(True),\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\n        return [raw.human_data for raw in raws]\n\n    @classmethod\n    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        interaction.is_deleted = True\n        db.commit()\n\n    @classmethod\n    def add_share(cls, db: Session, shared: SharedInteractionBase):\n        \"\"\"add share interaction\n\n        Args:\n            db (Session): db session\n            shared (SharedInteractionBase): shared interaction from community\n        \"\"\"\n        db.add(SharedInteraction(**shared.to_dict()))\n\n    @classmethod\n    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert an interaction process for recording\n\n        Args:\n            db (Session): db session\n            process (XAgentRaw): interaction process\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            process.interaction_id == process.interaction_id).first()\n        exist_process = db.query(Raw).filter(\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        if exist_process is not None:\n            process.step = exist_process.step + 1\n        else:\n            process.step = 0\n\n        db.add(Raw(**process.to_dict()))\n        db.commit()\n\n    @classmethod\n    def search_many_raws(cls, db: Session, interaction_id: str):\n        \"\"\"search many raws\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list[XAgentRaw]: interaction process list\n        \"\"\"\n        processes = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\n        return processes\n\n    @classmethod\n    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        get raw by interaction id and node id\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        return process\n\n    @classmethod\n    def get_next_send(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get next send process\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            XAgentRaw: interaction process\n        \"\"\"\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\n                                         Raw.is_send.is_(False),\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\n        return processes\n\n    @classmethod\n    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag, if send success, update flag\n        if send flag is True, it means that the process has been sent\n        and no longer needs to be sent\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_send = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag, if receive success, update flag\n        if this flag is True, it means that the process has been received from human\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\n        \"\"\"\n        update human data\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n            human_data (dict): human data\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.is_human = True\n        process.human_data = human_data\n        db.commit()\n\n    @classmethod\n    def insert_error(cls, db: Session, interaction_id: str, message: str):\n        \"\"\"\n        if interaction is failed, insert error message\n        this message will be displayed in the interaction list\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            message (str): error message\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        \"\"\"\n        process = Raw(\n            node_id=uuid.uuid4().hex,\n            interaction_id=interaction_id,\n            current=\"\",\n            step=0,\n            data=message,\n            file_list=[],\n            status=StatusEnum.FAILED,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        )\n        db.add(process)\n        db.commit()\n\n    @classmethod\n    def get_finish_status(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get interaction finish status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_deleted.is_(False),\n            Raw.status == \"finished\").first()\n        return process is not None\n",
            "name_column": 6
        },
        "search_many_interaction": {
            "type": "FunctionDef",
            "name": "search_many_interaction",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 34,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\n        \"\"\"search many interactions\n\n        Args:\n            db (Session): db session\n\n        Returns:\n            list[InteractionBase]: interaction list\n        \"\"\"\n        interactions = db.query(Interaction).all()\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\n",
            "name_column": 8
        },
        "get_interaction": {
            "type": "FunctionDef",
            "name": "get_interaction",
            "md_content": "",
            "code_start_line": 37,
            "code_end_line": 52,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_interaction(cls,\n                        db: Session,\n                        interaction_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by interaction_id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_not(True)).first()\n        return InteractionBase.from_db(interaction) if interaction else None\n",
            "name_column": 8
        },
        "get_ready_interaction": {
            "type": "FunctionDef",
            "name": "get_ready_interaction",
            "md_content": "",
            "code_start_line": 55,
            "code_end_line": 70,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_ready_interaction(cls,\n                              db: Session,\n                              user_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by user_id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status == 'ready').first()\n        return InteractionBase.from_db(interaction) if interaction else None\n",
            "name_column": 8
        },
        "create_interaction": {
            "type": "FunctionDef",
            "name": "create_interaction",
            "md_content": "",
            "code_start_line": 73,
            "code_end_line": 88,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def create_interaction(cls,\n                           db: Session,\n                           base: InteractionBase) -> InteractionBase:\n        \"\"\"\n        create interaction\n\n        Args:\n            db (Session): db session\n            base (InteractionBase): interaction base\n\n        Returns:\n            None\n        \"\"\"\n        db.add(Interaction(**base.to_dict()))\n        db.commit()\n        return None\n",
            "name_column": 8
        },
        "add_parameter": {
            "type": "FunctionDef",
            "name": "add_parameter",
            "md_content": "",
            "code_start_line": 91,
            "code_end_line": 100,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def add_parameter(cls,\n                      db: Session,\n                      parameter: InteractionParameter):\n        \"\"\"\n        add parameter for interaction\n        \"\"\"\n        db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n\n        return None\n",
            "name_column": 8
        },
        "search_interaction_by_user_id": {
            "type": "FunctionDef",
            "name": "search_interaction_by_user_id",
            "md_content": "",
            "code_start_line": 103,
            "code_end_line": 139,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_interaction_by_user_id(cls,\n                                      db: Session,\n                                      user_id: str,\n                                      page_size: int = 20,\n                                      page_num: int = 1) -> list[dict]:\n        \"\"\"\n        search interaction by user id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n            page_size (int, optional): page size. Defaults to 20.\n            page_num (int, optional): page num. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(Interaction.id)).filter(\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\n\n        interaction_list = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.is_deleted.is_(False),\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\n            page_size).offset((page_num - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = InteractionBase.from_db(interaction).to_dict(\n                exclude=[\"recorder_root_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = [parameter[0]]\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n",
            "name_column": 8
        },
        "search_many_shared": {
            "type": "FunctionDef",
            "name": "search_many_shared",
            "md_content": "",
            "code_start_line": 142,
            "code_end_line": 176,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared interactions from community\n\n        Args:\n            db (Session): db session\n            page_size (int, optional): page size. Defaults to 20.\n            page_index (int, optional): page index. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(SharedInteraction.id)).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).scalar()\n        interaction_list = db.query(SharedInteraction).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).order_by(\n            SharedInteraction.star.desc()).limit(page_size).offset(\n                (page_index - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\n                exclude=[\"record_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = parameter\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n",
            "name_column": 8
        },
        "get_shared_interaction": {
            "type": "FunctionDef",
            "name": "get_shared_interaction",
            "md_content": "",
            "code_start_line": 179,
            "code_end_line": 195,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> SharedInteractionBase | None:\n        \"\"\"\n        get shared interaction by interaction id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n\n            SharedInteractionBase | None: shared interaction\n        \"\"\"\n        interaction = db.query(SharedInteraction).filter(\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\n        return SharedInteractionBase.from_db(interaction) if interaction else None\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 198,
            "code_end_line": 214,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def is_exist(cls,\n                 db: Session,\n                 interaction_id: str) -> bool:\n        \"\"\"\n        check interaction is exist or not\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_(False)).first()\n        return interaction is not None\n",
            "name_column": 8
        },
        "update_interaction": {
            "type": "FunctionDef",
            "name": "update_interaction",
            "md_content": "",
            "code_start_line": 217,
            "code_end_line": 239,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n\n        Args:\n            db (Session): db session\n            base_data (dict): interaction data\n\n        Returns:\n            None\n        \"\"\"\n        if \"interaction_id\" not in base_data:\n            raise XAgentError(\"interaction_id is required\")\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == base_data[\"interaction_id\"]).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        for k, v in base_data.items():\n            if k == \"interaction_id\":\n                continue\n            setattr(interaction, k, v)\n        interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_interaction_status": {
            "type": "FunctionDef",
            "name": "update_interaction_status",
            "md_content": "",
            "code_start_line": 242,
            "code_end_line": 270,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            status (str): status\n            message (str): message\n            current_step (int): current step\n\n        Returns:\n            None\n        \"\"\"\n        db_interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if db_interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        db_interaction.status = status\n        db_interaction.message = message\n        db_interaction.current_step = current_step\n        db_interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_interaction_parameter": {
            "type": "FunctionDef",
            "name": "update_interaction_parameter",
            "md_content": "",
            "code_start_line": 273,
            "code_end_line": 294,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            parameter (InteractionParameter): parameter\n\n        Returns:\n            None\n        \"\"\"\n        db_parameter = db.query(Parameter).filter(\n            Parameter.interaction_id == interaction_id,\n            Parameter.parameter_id == parameter.parameter_id).first()\n\n        if db_parameter is None:\n            db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n",
            "name_column": 8
        },
        "is_running": {
            "type": "FunctionDef",
            "name": "is_running",
            "md_content": "",
            "code_start_line": 297,
            "code_end_line": 311,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        check user is only running one interaction\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:    \n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status.in_((\"running\", \"waiting\"))).first()\n        return interaction is not None\n",
            "name_column": 8
        },
        "get_parameter": {
            "type": "FunctionDef",
            "name": "get_parameter",
            "md_content": "",
            "code_start_line": 314,
            "code_end_line": 329,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get interaction running parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list: parameter list\n        \"\"\"\n        raws = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_human.is_(True),\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\n        return [raw.human_data for raw in raws]\n",
            "name_column": 8
        },
        "delete_interaction": {
            "type": "FunctionDef",
            "name": "delete_interaction",
            "md_content": "",
            "code_start_line": 332,
            "code_end_line": 351,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        interaction.is_deleted = True\n        db.commit()\n",
            "name_column": 8
        },
        "add_share": {
            "type": "FunctionDef",
            "name": "add_share",
            "md_content": "",
            "code_start_line": 354,
            "code_end_line": 361,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def add_share(cls, db: Session, shared: SharedInteractionBase):\n        \"\"\"add share interaction\n\n        Args:\n            db (Session): db session\n            shared (SharedInteractionBase): shared interaction from community\n        \"\"\"\n        db.add(SharedInteraction(**shared.to_dict()))\n",
            "name_column": 8
        },
        "insert_raw": {
            "type": "FunctionDef",
            "name": "insert_raw",
            "md_content": "",
            "code_start_line": 364,
            "code_end_line": 391,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert an interaction process for recording\n\n        Args:\n            db (Session): db session\n            process (XAgentRaw): interaction process\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            process.interaction_id == process.interaction_id).first()\n        exist_process = db.query(Raw).filter(\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        if exist_process is not None:\n            process.step = exist_process.step + 1\n        else:\n            process.step = 0\n\n        db.add(Raw(**process.to_dict()))\n        db.commit()\n",
            "name_column": 8
        },
        "search_many_raws": {
            "type": "FunctionDef",
            "name": "search_many_raws",
            "md_content": "",
            "code_start_line": 394,
            "code_end_line": 406,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_many_raws(cls, db: Session, interaction_id: str):\n        \"\"\"search many raws\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list[XAgentRaw]: interaction process list\n        \"\"\"\n        processes = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\n        return processes\n",
            "name_column": 8
        },
        "get_raw": {
            "type": "FunctionDef",
            "name": "get_raw",
            "md_content": "",
            "code_start_line": 409,
            "code_end_line": 415,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        get raw by interaction id and node id\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        return process\n",
            "name_column": 8
        },
        "get_next_send": {
            "type": "FunctionDef",
            "name": "get_next_send",
            "md_content": "",
            "code_start_line": 418,
            "code_end_line": 432,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_next_send(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get next send process\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            XAgentRaw: interaction process\n        \"\"\"\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\n                                         Raw.is_send.is_(False),\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\n        return processes\n",
            "name_column": 8
        },
        "update_send_flag": {
            "type": "FunctionDef",
            "name": "update_send_flag",
            "md_content": "",
            "code_start_line": 435,
            "code_end_line": 458,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag, if send success, update flag\n        if send flag is True, it means that the process has been sent\n        and no longer needs to be sent\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_send = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_receive_flag": {
            "type": "FunctionDef",
            "name": "update_receive_flag",
            "md_content": "",
            "code_start_line": 461,
            "code_end_line": 483,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag, if receive success, update flag\n        if this flag is True, it means that the process has been received from human\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_human_data": {
            "type": "FunctionDef",
            "name": "update_human_data",
            "md_content": "",
            "code_start_line": 486,
            "code_end_line": 509,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\n        \"\"\"\n        update human data\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n            human_data (dict): human data\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.is_human = True\n        process.human_data = human_data\n        db.commit()\n",
            "name_column": 8
        },
        "insert_error": {
            "type": "FunctionDef",
            "name": "insert_error",
            "md_content": "",
            "code_start_line": 512,
            "code_end_line": 541,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def insert_error(cls, db: Session, interaction_id: str, message: str):\n        \"\"\"\n        if interaction is failed, insert error message\n        this message will be displayed in the interaction list\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            message (str): error message\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        \"\"\"\n        process = Raw(\n            node_id=uuid.uuid4().hex,\n            interaction_id=interaction_id,\n            current=\"\",\n            step=0,\n            data=message,\n            file_list=[],\n            status=StatusEnum.FAILED,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        )\n        db.add(process)\n        db.commit()\n",
            "name_column": 8
        },
        "get_finish_status": {
            "type": "FunctionDef",
            "name": "get_finish_status",
            "md_content": "",
            "code_start_line": 544,
            "code_end_line": 559,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_finish_status(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get interaction finish status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_deleted.is_(False),\n            Raw.status == \"finished\").first()\n        return process is not None\n",
            "name_column": 8
        }
    },
    "XAgentServer/database/interface/recorder.py": {
        "RecordDBInterface": {
            "type": "ClassDef",
            "name": "RecordDBInterface",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 99,
            "parent": null,
            "have_return": true,
            "code_content": "class RecordDBInterface(metaclass=abc.ABCMeta):\n    \"\"\"Recorder DB Interface\n\n    Args:\n        RecorderBaseInterface (_type_): _description_\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\n    \"\"\"\n\n    @classmethod\n    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"get all records\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n        records = db.query(RunningRecord).filter(\n            RunningRecord.record_id == record_id).all()\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n\n    @classmethod\n    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None\n                     ) -> XAgentRunningRecord | None:\n        \"\"\"get Recorder by Recorder_id or email\n\n        Args:\n            db (Session): db\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\n        \"\"\"\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\n                                                  RunningRecord.deleted.is_(False)).first()\n\n        return XAgentRunningRecord.from_db(record) if record else None\n\n    @classmethod\n    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"insert Recorder\n\n        Args:\n            db (Session): db\n            record (XAgentRunningRecord): Recorder\n        \"\"\"\n        db_record = RunningRecord(**record.to_dict())\n        db.add(db_record)\n        db.commit()\n        db.refresh(db_record)\n        return db_record\n    \n    @classmethod\n    def get_record_by_type(cls,\n                           db: Session,\n                           record_id: str,\n                           node_id: str = \"\",\n                           node_type: str = \"\") -> list[XAgentRunningRecord]:\n        \"\"\"get Recorder by type\n\n        Args:\n            db (Session): db\n            record_id (str): record id\n            node_id (str): node id\n            node_type (str): node type\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n\n        filters = [RunningRecord.deleted.is_(False)]\n\n        if record_id:\n            filters.append(RunningRecord.record_id == record_id)\n\n        if node_id:\n            filters.append(RunningRecord.node_id == node_id)\n\n        if node_type:\n            filters.append(RunningRecord.node_type == node_type)\n\n        records = db.query(RunningRecord).filter(*filters).all()\n\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n",
            "name_column": 6
        },
        "get_record_list": {
            "type": "FunctionDef",
            "name": "get_record_list",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"get all records\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n        records = db.query(RunningRecord).filter(\n            RunningRecord.record_id == record_id).all()\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n",
            "name_column": 8
        },
        "get_record": {
            "type": "FunctionDef",
            "name": "get_record",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 50,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None\n                     ) -> XAgentRunningRecord | None:\n        \"\"\"get Recorder by Recorder_id or email\n\n        Args:\n            db (Session): db\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\n        \"\"\"\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\n                                                  RunningRecord.deleted.is_(False)).first()\n\n        return XAgentRunningRecord.from_db(record) if record else None\n",
            "name_column": 8
        },
        "insert_record": {
            "type": "FunctionDef",
            "name": "insert_record",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 66,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"insert Recorder\n\n        Args:\n            db (Session): db\n            record (XAgentRunningRecord): Recorder\n        \"\"\"\n        db_record = RunningRecord(**record.to_dict())\n        db.add(db_record)\n        db.commit()\n        db.refresh(db_record)\n        return db_record\n",
            "name_column": 8
        },
        "get_record_by_type": {
            "type": "FunctionDef",
            "name": "get_record_by_type",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 99,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def get_record_by_type(cls,\n                           db: Session,\n                           record_id: str,\n                           node_id: str = \"\",\n                           node_type: str = \"\") -> list[XAgentRunningRecord]:\n        \"\"\"get Recorder by type\n\n        Args:\n            db (Session): db\n            record_id (str): record id\n            node_id (str): node id\n            node_type (str): node type\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n\n        filters = [RunningRecord.deleted.is_(False)]\n\n        if record_id:\n            filters.append(RunningRecord.record_id == record_id)\n\n        if node_id:\n            filters.append(RunningRecord.node_id == node_id)\n\n        if node_type:\n            filters.append(RunningRecord.node_type == node_type)\n\n        records = db.query(RunningRecord).filter(*filters).all()\n\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n",
            "name_column": 8
        }
    },
    "XAgentServer/loggers/logs.py": {
        "JsonFileHandler": {
            "type": "ClassDef",
            "name": "JsonFileHandler",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 24,
            "parent": null,
            "have_return": false,
            "code_content": "class JsonFileHandler(logging.FileHandler):\n    \"\"\"JsonFileHandler\"\"\"\n    def __init__(self, filename, mode=\"a\", encoding=None, delay=False):\n        super().__init__(filename, mode, encoding, delay)\n\n    def emit(self, record):\n        json_data = json.loads(self.format(record))\n        with open(self.baseFilename, \"w\", encoding=\"utf-8\") as f:\n            json.dump(json_data, f, ensure_ascii=False, indent=4)\n",
            "name_column": 6
        },
        "JsonFormatter": {
            "type": "ClassDef",
            "name": "JsonFormatter",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "class JsonFormatter(logging.Formatter):\n    \"\"\"Json Formatter\"\"\"\n    def format(self, record):\n        return record.msg\n",
            "name_column": 6
        },
        "Logger": {
            "type": "ClassDef",
            "name": "Logger",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 191,
            "parent": null,
            "have_return": true,
            "code_content": "class Logger(metaclass=abc.ABCMeta):\n    \"\"\"\n    Logger that handle titles in different colors.\n    Outputs logs in console, activity.log, and errors.log\n    For console handler: simulates typing\n    \"\"\"\n\n    def __init__(self, log_dir: str = None, log_name: str= \"\", log_file: str = \"activity.log\", error_file: str = \"errors.log\"):\n        \"\"\"init\"\"\"\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        # create log directory if it doesn't exist\n        self.log_name = time.strftime(\"%Y-%m-%d\", time.localtime()) if not log_name else log_name\n        self.logger = logging.getLogger(self.log_name)\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        # self.typing_logger = logging.getLogger(self.log_name)\n        # if not self.typing_logger.handlers:\n        #     self.typing_logger.addHandler(self.typing_console_handler)\n        #     self.typing_logger.addHandler(self.file_handler)\n        #     self.typing_logger.addHandler(error_handler)\n        # self.typing_logger.setLevel(logging.DEBUG)\n\n        if self.log_name.endswith(\"_INTERACT\") or not self.logger.handlers:\n            # self.logger.addHandler(self.typing_console_handler)\n            self.logger.addHandler(self.console_handler)\n            self.logger.addHandler(error_handler)\n            self.logger.addHandler(self.file_handler)\n            self.logger.setLevel(logging.DEBUG)\n    \n    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n\n        self.logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n\n    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n\n    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n\n    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n\n    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n\n    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n\n    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n\n    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n\n    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n\n    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 6
        },
        "TypingConsoleHandler": {
            "type": "ClassDef",
            "name": "TypingConsoleHandler",
            "md_content": "",
            "code_start_line": 199,
            "code_end_line": 218,
            "parent": null,
            "have_return": false,
            "code_content": "class TypingConsoleHandler(logging.StreamHandler):\n    def emit(self, record):\n        min_typing_speed = 0.05\n        max_typing_speed = 0.01\n\n        msg = self.format(record)\n        try:\n            words = msg.split()\n            for i, word in enumerate(words):\n                print(word, end=\"\", flush=True)\n                if i < len(words) - 1:\n                    print(\" \", end=\"\", flush=True)\n                typing_speed = random.uniform(min_typing_speed, max_typing_speed)\n                time.sleep(typing_speed)\n                # type faster after each word\n                min_typing_speed = min_typing_speed * 0.95\n                max_typing_speed = max_typing_speed * 0.95\n            print()\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "ConsoleHandler": {
            "type": "ClassDef",
            "name": "ConsoleHandler",
            "md_content": "",
            "code_start_line": 221,
            "code_end_line": 227,
            "parent": null,
            "have_return": false,
            "code_content": "class ConsoleHandler(logging.StreamHandler):\n    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "RecordFormatter": {
            "type": "ClassDef",
            "name": "RecordFormatter",
            "md_content": "",
            "code_start_line": 230,
            "code_end_line": 254,
            "parent": null,
            "have_return": true,
            "code_content": "class RecordFormatter(logging.Formatter):\n    \"\"\"\n    Allows to handle custom placeholders 'title_color' and 'message_no_color'.\n    To use this formatter, make sure to pass 'color', 'title' as log extras.\n    \"\"\"\n\n    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 6
        },
        "remove_color_codes": {
            "type": "FunctionDef",
            "name": "remove_color_codes",
            "md_content": "",
            "code_start_line": 257,
            "code_end_line": 259,
            "parent": null,
            "have_return": true,
            "code_content": "def remove_color_codes(s: str) -> str:\n    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n    return ansi_escape.sub(\"\", s)\n",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 40,
            "code_end_line": 96,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def __init__(self, log_dir: str = None, log_name: str= \"\", log_file: str = \"activity.log\", error_file: str = \"errors.log\"):\n        \"\"\"init\"\"\"\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        # create log directory if it doesn't exist\n        self.log_name = time.strftime(\"%Y-%m-%d\", time.localtime()) if not log_name else log_name\n        self.logger = logging.getLogger(self.log_name)\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        # self.typing_logger = logging.getLogger(self.log_name)\n        # if not self.typing_logger.handlers:\n        #     self.typing_logger.addHandler(self.typing_console_handler)\n        #     self.typing_logger.addHandler(self.file_handler)\n        #     self.typing_logger.addHandler(error_handler)\n        # self.typing_logger.setLevel(logging.DEBUG)\n\n        if self.log_name.endswith(\"_INTERACT\") or not self.logger.handlers:\n            # self.logger.addHandler(self.typing_console_handler)\n            self.logger.addHandler(self.console_handler)\n            self.logger.addHandler(error_handler)\n            self.logger.addHandler(self.file_handler)\n            self.logger.setLevel(logging.DEBUG)\n",
            "name_column": 8
        },
        "emit": {
            "type": "FunctionDef",
            "name": "emit",
            "md_content": "",
            "code_start_line": 222,
            "code_end_line": 227,
            "parent": "ConsoleHandler",
            "have_return": false,
            "code_content": "    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 8
        },
        "format": {
            "type": "FunctionDef",
            "name": "format",
            "md_content": "",
            "code_start_line": 236,
            "code_end_line": 254,
            "parent": "RecordFormatter",
            "have_return": true,
            "code_content": "    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 8
        },
        "typewriter_log": {
            "type": "FunctionDef",
            "name": "typewriter_log",
            "md_content": "",
            "code_start_line": 98,
            "code_end_line": 115,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n\n        self.logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n",
            "name_column": 8
        },
        "debug": {
            "type": "FunctionDef",
            "name": "debug",
            "md_content": "",
            "code_start_line": 117,
            "code_end_line": 123,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n",
            "name_column": 8
        },
        "info": {
            "type": "FunctionDef",
            "name": "info",
            "md_content": "",
            "code_start_line": 125,
            "code_end_line": 131,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n",
            "name_column": 8
        },
        "warn": {
            "type": "FunctionDef",
            "name": "warn",
            "md_content": "",
            "code_start_line": 133,
            "code_end_line": 139,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n",
            "name_column": 8
        },
        "error": {
            "type": "FunctionDef",
            "name": "error",
            "md_content": "",
            "code_start_line": 141,
            "code_end_line": 142,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n",
            "name_column": 8
        },
        "_log": {
            "type": "FunctionDef",
            "name": "_log",
            "md_content": "",
            "code_start_line": 144,
            "code_end_line": 156,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n",
            "name_column": 8
        },
        "set_level": {
            "type": "FunctionDef",
            "name": "set_level",
            "md_content": "",
            "code_start_line": 158,
            "code_end_line": 160,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n",
            "name_column": 8
        },
        "double_check": {
            "type": "FunctionDef",
            "name": "double_check",
            "md_content": "",
            "code_start_line": 162,
            "code_end_line": 171,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n",
            "name_column": 8
        },
        "log_json": {
            "type": "FunctionDef",
            "name": "log_json",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 186,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n",
            "name_column": 8
        },
        "get_log_directory": {
            "type": "FunctionDef",
            "name": "get_log_directory",
            "md_content": "",
            "code_start_line": 188,
            "code_end_line": 191,
            "parent": "Logger",
            "have_return": true,
            "code_content": "    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 8
        }
    },
    "XAgentServer/enums/recorder_type.py": {
        "RecorderTypeEnum": {
            "type": "ClassDef",
            "name": "RecorderTypeEnum",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 20,
            "parent": null,
            "have_return": false,
            "code_content": "class RecorderTypeEnum:\n    \"\"\"XAgent Running Recorder Type Enum\n    \"\"\"\n    QUERY = \"query\"\n    CONFIG = \"config\"\n    LLM_INPUT_PAIR = \"llm_input_pair\"\n    TOOL_SERVER_PAIR = \"tool_server_pair\"\n    NOW_SUBTASK_ID = \"now_subtask_id\"\n    TOOL_CALL = \"tool_call\"\n    PLAN_REFINE = \"plan_refine\"\n    LLM_SERVER_CACHE = \"llm_server_cache\"\n    TOOL_SERVER_CACHE = \"tool_server_cache\"\n    TOOL_CALL_CACHE = \"tool_call_cache\"\n    PLAN_REFINE_CACHE = \"plan_refine_cache\"\n    LLM_INTERFACE_ID = \"llm_interface_id\"\n    TOOL_SERVER_INTERFACE_ID = \"toolserver_interface_id\"\n    TOOL_CALL_ID = \"tool_call_id\"\n",
            "name_column": 6
        }
    },
    "XAgentServer/enums/status.py": {
        "StatusEnum": {
            "type": "ClassDef",
            "name": "StatusEnum",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 16,
            "parent": null,
            "have_return": false,
            "code_content": "class StatusEnum:\n    \"\"\"XAgent Status Enum\n    \"\"\"\n    START = \"start\"\n    SUBTASK = \"subtask\"\n    REFINEMENT = \"refinement\"\n    INNER = \"inner\"\n    FINISHED = \"finished\"\n    FAILED = \"failed\"\n    SUBMIT = \"subtask_submit\"\n    RUNNING = \"running\"\n    ASK_FOR_HUMAN_HELP = \"ask_for_human_help\"\n    CLOSED = \"closed\"\n",
            "name_column": 6
        }
    },
    "XAgentServer/models/user.py": {
        "XAgentUser": {
            "type": "ClassDef",
            "name": "XAgentUser",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 105,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentUser(metaclass=abc.ABCMeta):\n\n    def __init__(self, \n                 user_id: str, \n                 email: str, \n                 name: str, \n                 token: str, \n                 available: bool = True,\n                 corporation: str = None,\n                 industry: str = None,\n                 position: str = None,\n                 create_time: str = None,\n                 update_time: str = None,\n                 deleted: bool = False,\n                 is_beta: bool = False,):\n        self.user_id = user_id\n        self.email = email\n        self.name = name\n        self.token = token\n        self.available = available\n        self.corporation = corporation\n        self.industry = industry\n        self.position = position\n        self.create_time = create_time\n        self.update_time = update_time\n        self.deleted = deleted\n        self.is_beta = is_beta\n\n    def to_dict(self):\n        return {\n            \"user_id\": self.user_id,\n            \"email\": self.email,\n            \"name\": self.name,\n            \"token\": self.token,\n            \"available\": self.available,\n            \"corporation\": self.corporation,\n            \"industry\": self.industry,\n            \"position\": self.position,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"deleted\": self.deleted,\n            \"is_beta\": self.is_beta\n        }\n\n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n\n    @staticmethod\n    def from_dict(user_dict: dict):\n        return XAgentUser(\n            user_id=user_dict[\"user_id\"],\n            email=user_dict[\"email\"],\n            name=user_dict[\"name\"],\n            token=user_dict[\"token\"],\n            available=user_dict[\"available\"],\n            corporation=user_dict[\"corporation\"],\n            industry=user_dict[\"industry\"],\n            position=user_dict[\"position\"],\n            create_time=user_dict[\"create_time\"],\n            update_time=user_dict[\"update_time\"],\n            deleted=user_dict[\"deleted\"],\n            is_beta=user_dict[\"is_beta\"]\n        )\n\n    @staticmethod\n    def from_json(user_json: str):\n        return XAgentUser.from_dict(json.loads(user_json))\n\n    def is_available(self):\n        return self.available\n    \n    @staticmethod\n    def from_db(user: User):\n        user_id = user.user_id\n        email = user.email\n        name = user.name\n        token = user.token\n        available = user.available\n        corporation = user.corporation\n        industry = user.industry\n        position = user.position\n        create_time = user.create_time\n        update_time = user.update_time\n        deleted = user.deleted\n        is_beta = user.is_beta\n        return XAgentUser(\n            user_id=user_id,\n            email=email,\n            name=name,\n            token=token,\n            available=available,\n            corporation=corporation,\n            industry=industry,\n            position=position,\n            create_time=create_time,\n            update_time=update_time,\n            deleted=deleted,\n            is_beta=is_beta\n        )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 33,
            "parent": "XAgentUser",
            "have_return": false,
            "code_content": "    def __init__(self, \n                 user_id: str, \n                 email: str, \n                 name: str, \n                 token: str, \n                 available: bool = True,\n                 corporation: str = None,\n                 industry: str = None,\n                 position: str = None,\n                 create_time: str = None,\n                 update_time: str = None,\n                 deleted: bool = False,\n                 is_beta: bool = False,):\n        self.user_id = user_id\n        self.email = email\n        self.name = name\n        self.token = token\n        self.available = available\n        self.corporation = corporation\n        self.industry = industry\n        self.position = position\n        self.create_time = create_time\n        self.update_time = update_time\n        self.deleted = deleted\n        self.is_beta = is_beta\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 35,
            "code_end_line": 49,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        return {\n            \"user_id\": self.user_id,\n            \"email\": self.email,\n            \"name\": self.name,\n            \"token\": self.token,\n            \"available\": self.available,\n            \"corporation\": self.corporation,\n            \"industry\": self.industry,\n            \"position\": self.position,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"deleted\": self.deleted,\n            \"is_beta\": self.is_beta\n        }\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 52,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_dict": {
            "type": "FunctionDef",
            "name": "from_dict",
            "md_content": "",
            "code_start_line": 55,
            "code_end_line": 69,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def from_dict(user_dict: dict):\n        return XAgentUser(\n            user_id=user_dict[\"user_id\"],\n            email=user_dict[\"email\"],\n            name=user_dict[\"name\"],\n            token=user_dict[\"token\"],\n            available=user_dict[\"available\"],\n            corporation=user_dict[\"corporation\"],\n            industry=user_dict[\"industry\"],\n            position=user_dict[\"position\"],\n            create_time=user_dict[\"create_time\"],\n            update_time=user_dict[\"update_time\"],\n            deleted=user_dict[\"deleted\"],\n            is_beta=user_dict[\"is_beta\"]\n        )\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 72,
            "code_end_line": 73,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def from_json(user_json: str):\n        return XAgentUser.from_dict(json.loads(user_json))\n",
            "name_column": 8
        },
        "is_available": {
            "type": "FunctionDef",
            "name": "is_available",
            "md_content": "",
            "code_start_line": 75,
            "code_end_line": 76,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def is_available(self):\n        return self.available\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 79,
            "code_end_line": 105,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def from_db(user: User):\n        user_id = user.user_id\n        email = user.email\n        name = user.name\n        token = user.token\n        available = user.available\n        corporation = user.corporation\n        industry = user.industry\n        position = user.position\n        create_time = user.create_time\n        update_time = user.update_time\n        deleted = user.deleted\n        is_beta = user.is_beta\n        return XAgentUser(\n            user_id=user_id,\n            email=email,\n            name=name,\n            token=token,\n            available=available,\n            corporation=corporation,\n            industry=industry,\n            position=position,\n            create_time=create_time,\n            update_time=update_time,\n            deleted=deleted,\n            is_beta=is_beta\n        )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/interaction.py": {
        "InteractionBase": {
            "type": "ClassDef",
            "name": "InteractionBase",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 86,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionBase(metaclass=abc.ABCMeta):\n    def __init__(self,\n                interaction_id: str,\n                user_id: str,\n                create_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                file_list: list = [],\n                recorder_root_dir: str = \"\",\n                status: str = \"\",\n                message: str = \"\",\n                current_step: str = \"\",\n                update_time: str = \"\",\n                is_deleted: bool = False,\n                call_method: str = \"web\",\n                ):\n        self.interaction_id = interaction_id\n        self.user_id = user_id\n        self.create_time = create_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.file_list = file_list\n        self.recorder_root_dir = recorder_root_dir\n        self.status = status\n        self.message = message\n        self.current_step = current_step\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.call_method = call_method\n\n    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_id\": self.user_id,\n            \"create_time\": self.create_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"file_list\": self.file_list,\n            \"recorder_root_dir\": self.recorder_root_dir,\n            \"status\": self.status,\n            \"message\": self.message,\n            \"current_step\": self.current_step,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"call_method\": self.call_method,\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n    \n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n    \n    @classmethod\n    def from_json(cls, json_data):\n        return cls(**json_data)\n    \n    @classmethod\n    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.user_id,\n                    interaction.create_time,\n                    interaction.description,\n                    interaction.agent,\n                    interaction.mode,\n                    interaction.file_list,\n                    interaction.recorder_root_dir,\n                    interaction.status,\n                    interaction.message,\n                    interaction.current_step,\n                    interaction.update_time,\n                    interaction.is_deleted,\n                    interaction.call_method,\n                    )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 38,
            "parent": "InteractionBase",
            "have_return": false,
            "code_content": "    def __init__(self,\n                interaction_id: str,\n                user_id: str,\n                create_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                file_list: list = [],\n                recorder_root_dir: str = \"\",\n                status: str = \"\",\n                message: str = \"\",\n                current_step: str = \"\",\n                update_time: str = \"\",\n                is_deleted: bool = False,\n                call_method: str = \"web\",\n                ):\n        self.interaction_id = interaction_id\n        self.user_id = user_id\n        self.create_time = create_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.file_list = file_list\n        self.recorder_root_dir = recorder_root_dir\n        self.status = status\n        self.message = message\n        self.current_step = current_step\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.call_method = call_method\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 40,
            "code_end_line": 61,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_id\": self.user_id,\n            \"create_time\": self.create_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"file_list\": self.file_list,\n            \"recorder_root_dir\": self.recorder_root_dir,\n            \"status\": self.status,\n            \"message\": self.message,\n            \"current_step\": self.current_step,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"call_method\": self.call_method,\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 63,
            "code_end_line": 64,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 68,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        return cls(**json_data)\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 71,
            "code_end_line": 86,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.user_id,\n                    interaction.create_time,\n                    interaction.description,\n                    interaction.agent,\n                    interaction.mode,\n                    interaction.file_list,\n                    interaction.recorder_root_dir,\n                    interaction.status,\n                    interaction.message,\n                    interaction.current_step,\n                    interaction.update_time,\n                    interaction.is_deleted,\n                    interaction.call_method,\n                    )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/raw.py": {
        "XAgentRaw": {
            "type": "ClassDef",
            "name": "XAgentRaw",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 110,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentRaw(metaclass=abc.ABCMeta):\n    \"\"\"XAgent Raw Object\"\"\"\n\n    def __init__(self, node_id: str,\n                 interaction_id: str,\n                 current: str,\n                 step: int,\n                 data: dict,\n                 file_list: list,\n                 status: str,\n                 do_interrupt: bool,\n                 wait_seconds: int,\n                 ask_for_human_help: bool,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 is_human: bool,\n                 human_data: dict,\n                 human_file_list: list,\n                 is_send: bool,\n                 is_receive: bool,\n                 include_pictures: bool = False,):\n        self.node_id = node_id\n        self.interaction_id = interaction_id\n        self.current = current\n        self.step = step\n        self.data = data\n        self.file_list = file_list\n        self.status = status\n        self.do_interrupt = do_interrupt\n        self.wait_seconds = wait_seconds\n        self.ask_for_human_help = ask_for_human_help\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.is_human = is_human\n        self.human_data = human_data\n        self.human_file_list = human_file_list\n        self.is_send = is_send\n        self.is_receive = is_receive\n        self.include_pictures = include_pictures\n\n    def to_dict(self):\n        \"\"\"XAgent Raw Object to dict\"\"\"\n        return {\n            \"node_id\": self.node_id,\n            \"interaction_id\": self.interaction_id,\n            \"current\": self.current,\n            \"step\": self.step,\n            \"data\": self.data,\n            \"file_list\": self.file_list,\n            \"status\": self.status,\n            \"do_interrupt\": self.do_interrupt,\n            \"wait_seconds\": self.wait_seconds,\n            \"ask_for_human_help\": self.ask_for_human_help,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"is_human\": self.is_human,\n            \"human_data\": self.human_data,\n            \"human_file_list\": self.human_file_list,\n            \"is_send\": self.is_send,\n            \"is_receive\": self.is_receive,\n            \"include_pictures\": self.include_pictures\n        }\n\n    def to_json(self):\n        \"\"\"XAgent Raw Object to json\"\"\"\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"XAgent Raw Object from json\"\"\"\n        return cls(**json_data)\n\n    def update(self, update_data: dict):\n        \"\"\"XAgent Raw Object update\"\"\"\n        for k, v in update_data.items():\n            setattr(self, k, v)\n        return self\n\n    @classmethod\n    def from_db(cls, db_data):\n        \"\"\"XAgent Raw Object from db\"\"\"\n        return cls(\n            node_id=db_data.node_id,\n            interaction_id=db_data.interaction_id,\n            current=db_data.current,\n            step=db_data.step,\n            data=db_data.data,\n            file_list=db_data.file_list,\n            status=db_data.status,\n            do_interrupt=db_data.do_interrupt,\n            wait_seconds=db_data.wait_seconds,\n            ask_for_human_help=db_data.ask_for_human_help,\n            create_time=db_data.create_time,\n            update_time=db_data.update_time,\n            is_deleted=db_data.is_deleted,\n            is_human=db_data.is_human,\n            human_data=db_data.human_data,\n            human_file_list=db_data.human_file_list,\n            is_send=db_data.is_send,\n            is_receive=db_data.is_receive,\n            include_pictures=db_data.include_pictures\n        )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 46,
            "parent": "XAgentRaw",
            "have_return": false,
            "code_content": "    def __init__(self, node_id: str,\n                 interaction_id: str,\n                 current: str,\n                 step: int,\n                 data: dict,\n                 file_list: list,\n                 status: str,\n                 do_interrupt: bool,\n                 wait_seconds: int,\n                 ask_for_human_help: bool,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 is_human: bool,\n                 human_data: dict,\n                 human_file_list: list,\n                 is_send: bool,\n                 is_receive: bool,\n                 include_pictures: bool = False,):\n        self.node_id = node_id\n        self.interaction_id = interaction_id\n        self.current = current\n        self.step = step\n        self.data = data\n        self.file_list = file_list\n        self.status = status\n        self.do_interrupt = do_interrupt\n        self.wait_seconds = wait_seconds\n        self.ask_for_human_help = ask_for_human_help\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.is_human = is_human\n        self.human_data = human_data\n        self.human_file_list = human_file_list\n        self.is_send = is_send\n        self.is_receive = is_receive\n        self.include_pictures = include_pictures\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 70,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        \"\"\"XAgent Raw Object to dict\"\"\"\n        return {\n            \"node_id\": self.node_id,\n            \"interaction_id\": self.interaction_id,\n            \"current\": self.current,\n            \"step\": self.step,\n            \"data\": self.data,\n            \"file_list\": self.file_list,\n            \"status\": self.status,\n            \"do_interrupt\": self.do_interrupt,\n            \"wait_seconds\": self.wait_seconds,\n            \"ask_for_human_help\": self.ask_for_human_help,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"is_human\": self.is_human,\n            \"human_data\": self.human_data,\n            \"human_file_list\": self.human_file_list,\n            \"is_send\": self.is_send,\n            \"is_receive\": self.is_receive,\n            \"include_pictures\": self.include_pictures\n        }\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 72,
            "code_end_line": 74,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"XAgent Raw Object to json\"\"\"\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 77,
            "code_end_line": 79,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        \"\"\"XAgent Raw Object from json\"\"\"\n        return cls(**json_data)\n",
            "name_column": 8
        },
        "update": {
            "type": "FunctionDef",
            "name": "update",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 85,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def update(self, update_data: dict):\n        \"\"\"XAgent Raw Object update\"\"\"\n        for k, v in update_data.items():\n            setattr(self, k, v)\n        return self\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 88,
            "code_end_line": 110,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def from_db(cls, db_data):\n        \"\"\"XAgent Raw Object from db\"\"\"\n        return cls(\n            node_id=db_data.node_id,\n            interaction_id=db_data.interaction_id,\n            current=db_data.current,\n            step=db_data.step,\n            data=db_data.data,\n            file_list=db_data.file_list,\n            status=db_data.status,\n            do_interrupt=db_data.do_interrupt,\n            wait_seconds=db_data.wait_seconds,\n            ask_for_human_help=db_data.ask_for_human_help,\n            create_time=db_data.create_time,\n            update_time=db_data.update_time,\n            is_deleted=db_data.is_deleted,\n            is_human=db_data.is_human,\n            human_data=db_data.human_data,\n            human_file_list=db_data.human_file_list,\n            is_send=db_data.is_send,\n            is_receive=db_data.is_receive,\n            include_pictures=db_data.include_pictures\n        )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/shared_interaction.py": {
        "SharedInteractionBase": {
            "type": "ClassDef",
            "name": "SharedInteractionBase",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 68,
            "parent": null,
            "have_return": true,
            "code_content": "class SharedInteractionBase(metaclass=abc.ABCMeta):\n    def __init__(self,\n                interaction_id: str,\n                user_name: str,\n                create_time: str,\n                update_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                is_deleted: bool = False,\n                star: int = 0,\n                is_audit: bool = False\n                ):\n        self.interaction_id = interaction_id\n        self.user_name = user_name\n        self.create_time = create_time\n        self.update_time = update_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.is_deleted = is_deleted\n        self.star = star\n        self.is_audit = is_audit\n\n    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_name\": self.user_name,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"is_deleted\": self.is_deleted,\n            \"star\": self.star,\n            \"is_audit\": self.is_audit\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n        \n    \n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n    \n    @classmethod\n    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                   interaction.user_name,\n                   interaction.create_time,\n                   interaction.update_time,\n                   interaction.description,\n                   interaction.agent,\n                   interaction.mode,\n                   interaction.is_deleted,\n                   interaction.star,\n                   interaction.is_audit\n                   )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 31,
            "parent": "SharedInteractionBase",
            "have_return": false,
            "code_content": "    def __init__(self,\n                interaction_id: str,\n                user_name: str,\n                create_time: str,\n                update_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                is_deleted: bool = False,\n                star: int = 0,\n                is_audit: bool = False\n                ):\n        self.interaction_id = interaction_id\n        self.user_name = user_name\n        self.create_time = create_time\n        self.update_time = update_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.is_deleted = is_deleted\n        self.star = star\n        self.is_audit = is_audit\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 50,
            "parent": "SharedInteractionBase",
            "have_return": true,
            "code_content": "    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_name\": self.user_name,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"is_deleted\": self.is_deleted,\n            \"star\": self.star,\n            \"is_audit\": self.is_audit\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 54,
            "parent": "SharedInteractionBase",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 68,
            "parent": "SharedInteractionBase",
            "have_return": true,
            "code_content": "    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                   interaction.user_name,\n                   interaction.create_time,\n                   interaction.update_time,\n                   interaction.description,\n                   interaction.agent,\n                   interaction.mode,\n                   interaction.is_deleted,\n                   interaction.star,\n                   interaction.is_audit\n                   )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/recorder.py": {
        "XAgentRunningRecord": {
            "type": "ClassDef",
            "name": "XAgentRunningRecord",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 67,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentRunningRecord(metaclass=abc.ABCMeta):\n    \"\"\"XAgent Running Recorder\"\"\"\n    def __init__(self,\n                 record_id: str,\n                 current: str,\n                 node_id: str,\n                 node_type: str,\n                 data: dict,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 ):\n        self.record_id = record_id\n        self.current = current\n        self.node_id = node_id\n        self.node_type = node_type\n        self.data = data\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n\n    def to_dict(self):\n        \"\"\"XAgent Running Recorder to dict\"\"\"\n        return {\n            \"record_id\": self.record_id,\n            \"current\": self.current,\n            \"node_id\": self.node_id,\n            \"node_type\": self.node_type,\n            \"data\": self.data,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n        }\n\n    @classmethod\n    def from_db(cls, db: RunningRecord):\n        \"\"\"From db\"\"\"\n        return cls(\n            record_id=db.record_id,\n            current=db.current,\n            node_id=db.node_id,\n            node_type=db.node_type,\n            data=db.data,\n            create_time=db.create_time,\n            update_time=db.update_time,\n            is_deleted=db.is_deleted,\n        )\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"\"\"dict to XAgent Running Recorder\"\"\"\n        return cls(\n            record_id=data[\"record_id\"],\n            current=data[\"current\"],\n            node_id=data[\"node_id\"],\n            node_type=data[\"node_type\"],\n            data=data[\"data\"],\n            create_time=data[\"create_time\"],\n            update_time=data[\"update_time\"],\n            is_deleted=data[\"is_deleted\"],\n        )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 26,
            "parent": "XAgentRunningRecord",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 record_id: str,\n                 current: str,\n                 node_id: str,\n                 node_type: str,\n                 data: dict,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 ):\n        self.record_id = record_id\n        self.current = current\n        self.node_id = node_id\n        self.node_type = node_type\n        self.data = data\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 28,
            "code_end_line": 39,
            "parent": "XAgentRunningRecord",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        \"\"\"XAgent Running Recorder to dict\"\"\"\n        return {\n            \"record_id\": self.record_id,\n            \"current\": self.current,\n            \"node_id\": self.node_id,\n            \"node_type\": self.node_type,\n            \"data\": self.data,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n        }\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 53,
            "parent": "XAgentRunningRecord",
            "have_return": true,
            "code_content": "    def from_db(cls, db: RunningRecord):\n        \"\"\"From db\"\"\"\n        return cls(\n            record_id=db.record_id,\n            current=db.current,\n            node_id=db.node_id,\n            node_type=db.node_type,\n            data=db.data,\n            create_time=db.create_time,\n            update_time=db.update_time,\n            is_deleted=db.is_deleted,\n        )\n",
            "name_column": 8
        },
        "from_dict": {
            "type": "FunctionDef",
            "name": "from_dict",
            "md_content": "",
            "code_start_line": 56,
            "code_end_line": 67,
            "parent": "XAgentRunningRecord",
            "have_return": true,
            "code_content": "    def from_dict(cls, data: dict):\n        \"\"\"dict to XAgent Running Recorder\"\"\"\n        return cls(\n            record_id=data[\"record_id\"],\n            current=data[\"current\"],\n            node_id=data[\"node_id\"],\n            node_type=data[\"node_type\"],\n            data=data[\"data\"],\n            create_time=data[\"create_time\"],\n            update_time=data[\"update_time\"],\n            is_deleted=data[\"is_deleted\"],\n        )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/global_png.py": {
        "add_to_map": {
            "type": "FunctionDef",
            "name": "add_to_map",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 5,
            "parent": null,
            "have_return": false,
            "code_content": "def add_to_map(key, value):\n    global_map[key] = value\n",
            "name_column": 4
        },
        "lookup_in_map": {
            "type": "FunctionDef",
            "name": "lookup_in_map",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 9,
            "parent": null,
            "have_return": true,
            "code_content": "def lookup_in_map(key):\n    return global_map.get(key)\n",
            "name_column": 4
        }
    },
    "XAgentServer/models/parameter.py": {
        "InteractionParameter": {
            "type": "ClassDef",
            "name": "InteractionParameter",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 39,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionParameter(metaclass=abc.ABCMeta):\n    \"\"\"\n    \n    \"\"\"\n\n    def __init__(self,\n                    interaction_id: str,\n                    parameter_id: str,\n                    args: Union[str, dict, None] = None\n                    ):\n        self.interaction_id = interaction_id\n        self.args = args\n        self.parameter_id = parameter_id\n\n    def to_dict(self):\n        return {\n            \"interaction_id\": self.interaction_id,\n            \"parameter_id\": self.parameter_id,\n            \"args\": self.args,\n        }\n\n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n\n    @classmethod\n    def from_json(cls, json_data):\n        return cls(**json_data)\n    \n    @classmethod\n    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.parameter_id,\n                    interaction.args\n                    )",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 18,
            "parent": "InteractionParameter",
            "have_return": false,
            "code_content": "    def __init__(self,\n                    interaction_id: str,\n                    parameter_id: str,\n                    args: Union[str, dict, None] = None\n                    ):\n        self.interaction_id = interaction_id\n        self.args = args\n        self.parameter_id = parameter_id\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 25,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        return {\n            \"interaction_id\": self.interaction_id,\n            \"parameter_id\": self.parameter_id,\n            \"args\": self.args,\n        }\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 28,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 31,
            "code_end_line": 32,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        return cls(**json_data)\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 35,
            "code_end_line": 39,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.parameter_id,\n                    interaction.args\n                    )",
            "name_column": 8
        }
    },
    "XAgentServer/application/global_val.py": {
        "init_yag": {
            "type": "FunctionDef",
            "name": "init_yag",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": null,
            "have_return": false,
            "code_content": "def init_yag(logger):\n    \"\"\"init yagmail service\n\n    Args:\n        logger (_type_): _description_\n    \"\"\"\n    global yag\n    if XAgentServerEnv.Email.send_email:\n        yag = yagmail.SMTP(user=XAgentServerEnv.Email.email_user,\n                           password=XAgentServerEnv.Email.email_password,\n                           host=XAgentServerEnv.Email.email_host)\n        logger.info(\"init yagmail\")\n",
            "name_column": 4
        },
        "init_executor": {
            "type": "FunctionDef",
            "name": "init_executor",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "def init_executor(logger):\n    \"\"\"init a thread pool executor\n\n    Args:\n        logger (_type_): _description_\n    \"\"\"\n    global executor\n    logger.typewriter_log(\n        title=f\"init a thread pool executor, max_workers: {XAgentServerEnv.workers}\",\n        title_color=Fore.RED)\n    executor = ThreadPoolExecutor(max_workers=XAgentServerEnv.workers)\n",
            "name_column": 4
        }
    },
    "XAgentServer/application/__init__.py": {},
    "XAgentServer/application/dependence.py": {
        "enable_logger": {
            "type": "FunctionDef",
            "name": "enable_logger",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 18,
            "parent": null,
            "have_return": true,
            "code_content": "def enable_logger():\n    \"\"\"logger\"\"\"\n    if not os.path.exists(os.path.join(XAgentServerEnv.base_dir, \"logs\")):\n        os.makedirs(os.path.join(\n            XAgentServerEnv.base_dir, \"logs\"))\n\n    logger = Logger(log_dir=os.path.join(\n        XAgentServerEnv.base_dir, \"logs\"), log_file=\"app.log\", log_name=\"XAgentServerApp\")\n    return logger\n",
            "name_column": 4
        },
        "enable_dependence": {
            "type": "FunctionDef",
            "name": "enable_dependence",
            "md_content": "",
            "code_start_line": 21,
            "code_end_line": 30,
            "parent": null,
            "have_return": false,
            "code_content": "def enable_dependence(logger):\n    \"\"\"dependence\"\"\"\n    logger.typewriter_log(\n        title=\"XAgent Service Init Dependence.\",\n        title_color=Fore.RED)\n    init_yag(logger)\n    init_executor(logger)\n    logger.typewriter_log(\n        title=\"XAgent Service Init Dependence: Complete!\",\n        title_color=Fore.RED)\n",
            "name_column": 4
        },
        "get_db": {
            "type": "FunctionDef",
            "name": "get_db",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "def get_db():\n    \"\"\"db\"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e\n    finally:\n        session.close()\n",
            "name_column": 4
        }
    },
    "XAgentServer/application/main.py": {
        "db_session_middleware": {
            "type": "AsyncFunctionDef",
            "name": "db_session_middleware",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 58,
            "parent": null,
            "have_return": true,
            "code_content": "async def db_session_middleware(request: Request, call_next):\n    \"\"\"\n    Exception middleware\n    \"\"\"\n    # \n    message = \"Internal server error\"\n    response = Response(message, status_code=500)\n    try:\n        response = await call_next(request)\n    except XAgentDBError as error:\n        traceback.print_exc()\n        message = \"XAgent DB Error.\" if XAgentServerEnv.prod else error.message\n        response = JSONResponse(\n            status_code=500,\n            content={\"status\": \"failed\", \"message\": message}\n        )\n    except XAgentFileError as error:\n        traceback.print_exc()\n        message = \"XAgent File Error.\" if XAgentServerEnv.prod else error.message\n        response = JSONResponse(\n            status_code=500,\n            content={\"status\": \"failed\", \"message\": message}\n        )\n    except XAgentAuthError as error:\n        traceback.print_exc()\n        response = JSONResponse(\n            status_code=401,\n            content={\"status\": \"failed\", \"message\": error.message}\n        )\n    except XAgentError as error:\n        traceback.print_exc()\n        message = \"XAgent Error.\" if XAgentServerEnv.prod else error.message\n   \n        response = JSONResponse(\n            status_code=500,\n            content={\"status\": \"failed\", \"message\": message}\n        )\n\n    return response\n",
            "name_column": 10
        },
        "print_start_message": {
            "type": "AsyncFunctionDef",
            "name": "print_start_message",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 100,
            "parent": null,
            "have_return": false,
            "code_content": "async def print_start_message():\n    \"\"\"\n    print start message\n    \"\"\"\n    logger.typewriter_log(\n        title=\"XAgent Server Dependences:\",\n        title_color=Fore.RED,\n        content=\"\"\"\n        Python: 3.10+ \n        FastAPI: Http server\n        Websocket: long connect with client\n        MySQL: save xagent data\n        SqlAlchemy: ORM with MySQL\n        Redis: save status of interaction\n        Threading: run interaction\n        APScheduler: send data to client and keep alive\n        FastAPI APIRouter: manage websocket route\n        XAgentError: XAgentServer.exts.exception_ext\"\"\",\n        )\n    logger.typewriter_log(\n        title=\"XAgent Server Version:\",\n        title_color=Fore.RED,\n        content=\"\"\"\n        V 1.1.0\"\"\",\n        )\n    logger.typewriter_log(\n        title=\"Notes:\",\n        title_color=Fore.RED,\n        content=\"\"\"\n        Since V 1.1.0, \n        Local storage will no longer be supported, replaced by Mysql.\n        The service depends on Redis and Mysql, \n        so you need to install Redis and Mysql before using it.\n        Before you use this service, please ensure that the following services are available:\n            1. Redis on docker, port: 6379, you can start it by docker, default password: xagent\n            2. Mysql on docker, port: 3306, you can start it by docker\n            3. XAgent Tool Server is runnning on port 8080\n            4. Port 8090 is not occupied\n        \"\"\",\n        )\n",
            "name_column": 10
        },
        "startup_event": {
            "type": "AsyncFunctionDef",
            "name": "startup_event",
            "md_content": "",
            "code_start_line": 103,
            "code_end_line": 110,
            "parent": null,
            "have_return": false,
            "code_content": "async def startup_event():\n    \"\"\"start up event\n    \"\"\"\n    logger.info(\"XAgent Service Startup Param:\")\n    for key, item in XAgentServerEnv.__dict__.items():\n        if not key.startswith(\"__\"):\n            logger.info(f\"{' '*10}{key}: {item}\")\n    enable_dependence(logger)\n",
            "name_column": 10
        },
        "startup": {
            "type": "AsyncFunctionDef",
            "name": "startup",
            "md_content": "",
            "code_start_line": 114,
            "code_end_line": 123,
            "parent": null,
            "have_return": false,
            "code_content": "async def startup():\n    \"\"\"\n    start up event\n    \"\"\"\n    await startup_event()\n    if XAgentServerEnv.default_login:\n        logger.typewriter_log(\n            title=\"Default user: Guest, token: xagent, you can use it to login\",\n            title_color=Fore.RED)\n    await print_start_message()\n",
            "name_column": 10
        },
        "shutdown": {
            "type": "AsyncFunctionDef",
            "name": "shutdown",
            "md_content": "",
            "code_start_line": 127,
            "code_end_line": 131,
            "parent": null,
            "have_return": false,
            "code_content": "async def shutdown():\n    \"\"\"\n    shut down event\n    \"\"\"\n    print(\"XAgent Service Shutdown!\")\n",
            "name_column": 10
        },
        "validation_exception_handler": {
            "type": "AsyncFunctionDef",
            "name": "validation_exception_handler",
            "md_content": "",
            "code_start_line": 135,
            "code_end_line": 148,
            "parent": null,
            "have_return": true,
            "code_content": "async def validation_exception_handler(request: Request, exc: RequestValidationError):\n    \"\"\"handle validation exception\n\n    Args:\n        request (Request): _description_\n        exc (RequestValidationError): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return JSONResponse(\n        status_code=400,\n        content={\"status\": \"failed\", \"message\": exc.errors()}\n    )\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/routers/user.py": {
        "register": {
            "type": "AsyncFunctionDef",
            "name": "register",
            "md_content": "",
            "code_start_line": 21,
            "code_end_line": 56,
            "parent": null,
            "have_return": true,
            "code_content": "async def register(email: str = Form(...),\n                   name: str = Form(...),\n                   corporation: str = Form(...),\n                   position: str = Form(...),\n                   industry: str = Form(...),\n                   db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    register user\n    \"\"\"\n    if UserCRUD.is_exist(db=db, email=email):\n        return ResponseBody(success=False, message=\"user is already exist\")\n\n    token = uuid.uuid4().hex\n    user = {\"user_id\": uuid.uuid4().hex, \"email\": email, \"name\": name,\n            \"token\": token, \"available\": False, \"corporation\": corporation,\n            \"position\": position, \"industry\": industry,\n            \"create_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"update_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"is_beta\": False}\n    try:\n\n        contents = email_content(user)\n\n        if XAgentServerEnv.Email.send_email:\n            from XAgentServer.application.global_val import yag\n            yag.send(user[\"email\"], 'XAgent Token Verification', contents)\n        else:\n            user[\"available\"] = True\n        UserCRUD.add_user(db=db, user_dict=user)\n    except smtplib.SMTPAuthenticationError:\n        return ResponseBody(success=False, message=\"email send failed!\", data=None)\n\n    except Exception:\n        return ResponseBody(success=False, message=\"register failed\", data=None)\n\n    return ResponseBody(data=user, success=True, message=\"Register success, we will send a email to you!\")\n",
            "name_column": 10
        },
        "auth": {
            "type": "AsyncFunctionDef",
            "name": "auth",
            "md_content": "",
            "code_start_line": 60,
            "code_end_line": 85,
            "parent": null,
            "have_return": true,
            "code_content": "async def auth(user_id: str = Query(...),\n               token: str = Query(...),\n               db: Session = Depends(get_db)\n               ) -> ResponseBody:\n    \"\"\"\n    user auth\n    \"\"\"\n    user = UserCRUD.get_user(db=db, user_id=user_id)\n    if user is None:\n        return ResponseBody(success=False, message=\"user is not exist\")\n\n    if user.token != token:\n        return ResponseBody(success=False, message=\"token is not correct\")\n    expired_time = datetime.now() - datetime.strptime(\n        user.update_time, \"%Y-%m-%d %H:%M:%S\")\n    if expired_time.seconds > 60 * 60 * 24 * 7:\n        return ResponseBody(success=False, message=\"token is expired\")\n    if not user.available:\n\n        user.available = True\n        user.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        UserCRUD.update_user(db=db, user=user)\n    else:\n        return ResponseBody(success=False, message=\"user is already available!\")\n\n    return ResponseBody(data=user.to_dict(), success=True, message=\"auth success\")\n",
            "name_column": 10
        },
        "login": {
            "type": "AsyncFunctionDef",
            "name": "login",
            "md_content": "",
            "code_start_line": 89,
            "code_end_line": 104,
            "parent": null,
            "have_return": true,
            "code_content": "async def login(email: str = Form(...),\n                token: str = Form(...),\n                db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    login\n    \"\"\"\n    user = UserCRUD.get_user(db=db, email=email)\n    if user is None:\n        return ResponseBody(success=False, message=\"user is not exist\")\n\n    if user.token != token:\n        return ResponseBody(success=False, message=\"token is not correct\")\n    if not user.available:\n        return ResponseBody(success=False, message=\"user is not available\")\n\n    return ResponseBody(data=user.to_dict(), success=True, message=\"login success\")\n",
            "name_column": 10
        },
        "check": {
            "type": "AsyncFunctionDef",
            "name": "check",
            "md_content": "",
            "code_start_line": 108,
            "code_end_line": 120,
            "parent": null,
            "have_return": true,
            "code_content": "async def check(token: str = Form(...), db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    check token is effective\n    \"\"\"\n    if token is None:\n        return ResponseBody(success=False, message=\"token is none\")\n\n    result = UserCRUD.token_is_exist(db=db, token=token, user_id=None)\n\n    if result:\n        return ResponseBody(data=result, success=True, message=\"token is effective\")\n\n    return ResponseBody(data=result, success=True, message=\"token is invalid\")\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/routers/__init__.py": {},
    "XAgentServer/application/routers/conv.py": {
        "user_is_available": {
            "type": "FunctionDef",
            "name": "user_is_available",
            "md_content": "",
            "code_start_line": 31,
            "code_end_line": 44,
            "parent": null,
            "have_return": true,
            "code_content": "def user_is_available(\n        user_id: str = Form(...),\n        token: str = Form(...),\n        db: Session = Depends(get_db)):\n    \"\"\"\n    check user is available    \n    \"\"\"\n    if user_id == \"\":\n        raise XAgentAuthError(\"user_id is empty!\")\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\n        raise XAgentAuthError(\"user is not exist!\")\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\n        raise XAgentAuthError(\"user is not available!\")\n    return user_id\n",
            "name_column": 4
        },
        "get_all_interactions": {
            "type": "AsyncFunctionDef",
            "name": "get_all_interactions",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 60,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_all_interactions(user_id: str = Depends(user_is_available),\n                               page_size: int = Form(...),\n                               page_num: int = Form(...),\n                               db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    get all interactions by user_id\n    \"\"\"\n\n    data = InteractionCRUD.search_interaction_by_user_id(db=db,\n                                                         user_id=user_id,\n                                                         page_size=page_size,\n                                                         page_num=page_num)\n    return ResponseBody(data=data, success=True, message=\"success\")\n",
            "name_column": 10
        },
        "init_conv_env": {
            "type": "FunctionDef",
            "name": "init_conv_env",
            "md_content": "",
            "code_start_line": 64,
            "code_end_line": 92,
            "parent": null,
            "have_return": true,
            "code_content": "def init_conv_env(user_id: str = Depends(user_is_available),\n                  db: Session = Depends(get_db)):\n    \"\"\"\n    initialize conv env\n    \"\"\"\n\n    interaction = InteractionCRUD.get_ready_interaction(db=db, user_id=user_id)\n\n    if interaction is None:\n        interaction_id = uuid.uuid4().hex\n        base = InteractionBase(interaction_id=interaction_id,\n                               user_id=user_id,\n                               create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                               description=\"XAgent\",\n                               agent=\"\",\n                               mode=\"\",\n                               file_list=[],\n                               recorder_root_dir=\"\",\n                               status=\"ready\",\n                               message=\"ready...\",\n                               current_step=\"-1\",\n                               update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                               )\n        InteractionCRUD.create_interaction(db=db, base=base)\n    else:\n        interaction_id = interaction.interaction_id\n\n    return ResponseBody(data={\"id\": interaction_id,\n                              \"t\": str(int(datetime.now().timestamp() * 1000))}, success=True, message=\"success\")\n",
            "name_column": 4
        },
        "get_share_interactions": {
            "type": "AsyncFunctionDef",
            "name": "get_share_interactions",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 106,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_share_interactions(user_id: str = Depends(user_is_available),\n                                 page_size: int = Form(...),\n                                 page_num: int = Form(...),\n                                 db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    get all interactions by user id\n    \"\"\"\n\n    data = InteractionCRUD.search_many_shared(\n        db=db, page_size=page_size, page_index=page_num)\n    return ResponseBody(data=data, success=True, message=\"success\")\n",
            "name_column": 10
        },
        "share_interaction": {
            "type": "AsyncFunctionDef",
            "name": "share_interaction",
            "md_content": "",
            "code_start_line": 110,
            "code_end_line": 168,
            "parent": null,
            "have_return": true,
            "code_content": "async def share_interaction(user_id: str = Depends(user_is_available),\n                            interaction_id: str = Form(...),\n                            db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    update_interaction_description\n    \"\"\"\n    interaction = InteractionCRUD.get_interaction(db=db,\n                                                  interaction_id=interaction_id)\n    if interaction is None:\n        return ResponseBody(success=False,\n                            message=f\"Don't find any interaction by interaction_id: \\\n                                {interaction_id}, Please check your interaction_id!\")\n\n    finish_status = InteractionCRUD.get_finish_status(\n        db=db, interaction_id=interaction_id)\n    if not finish_status:\n        return ResponseBody(success=False, message=\"interaction is not finish!\")\n    user = UserCRUD.get_user(db=db, user_id=user_id)\n    user_name = user.name\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\n                                   \"localstorage\",\n                                   \"interact_records\",\n                                   interaction.create_time[:10],\n                                   interaction_id)\n    workspace_dir = os.path.join(interaction_dir, \"workspace\")\n    zip_file = os.path.join(interaction_dir, \"workspace.zip\")\n    if not os.path.exists(zip_file):\n        if os.path.exists(workspace_dir):\n            files = os.listdir(workspace_dir)\n            # zip workspace\n            with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as z:\n                for f in files:\n                    file = os.path.join(workspace_dir, f)\n                    z.write(file, arcname=f)\n\n    raws = InteractionCRUD.search_many_raws(\n        db=db, interaction_id=interaction_id)\n\n    share_data = {\n        \"user_id\": user_id,\n        \"user_name\": user_name,\n        \"token\": user.token,\n        \"interaction\": json.dumps(interaction.to_dict(), ensure_ascii=False),\n        \"raws\": json.dumps([raw.to_dict() for raw in raws], ensure_ascii=False),\n    }\n\n    with open(zip_file, 'rb') as f:\n        files = {\"files\": f.read()}\n    try:\n        res = requests.post(url=XAgentServerEnv.share_url,\n                            data=share_data,\n                            files=files,\n                            timeout=60)\n\n        data = res.json()\n\n        return ResponseBody(**data)\n    except Exception as e:\n        return ResponseBody(success=False, message=str(e), data=None)\n",
            "name_column": 10
        },
        "community": {
            "type": "FunctionDef",
            "name": "community",
            "md_content": "",
            "code_start_line": 172,
            "code_end_line": 250,
            "parent": null,
            "have_return": true,
            "code_content": "def community(user_id: str = Depends(user_is_available),\n              user_name: str = Form(...),\n              interaction: str = Form(...),\n              raws: str = Form(...),\n              files: UploadFile = File(...),\n              db: Session = Depends(get_db)):\n    \"\"\"\n    community, this api is runing on x-agent.net\n    \"\"\"\n    interaction = json.loads(interaction)\n    raws = json.loads(raws)\n    interaction_id = interaction[\"interaction_id\"]\n    old_share = InteractionCRUD.get_shared_interaction(\n        db=db, interaction_id=interaction_id)\n\n    # \n    if old_share:\n        raise XAgentWebError(\"interaction is exist!\")\n\n    contain_finish = False\n    for raw in raws:\n        if raw[\"status\"] == StatusEnum.FINISHED:\n            contain_finish = True\n            break\n    # finish\n    if not contain_finish:\n        raise XAgentWebError(\"interaction is not finish!\")\n\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\n                                   \"localstorage\",\n                                   \"interact_records\",\n                                   interaction[\"create_time\"][:10],\n                                   interaction_id,\n                                   \"workspace\")\n\n    if not os.path.exists(interaction_dir):\n        os.makedirs(interaction_dir)\n\n    # \n    with open(os.path.join(interaction_dir, \"workspace.zip\"), \"wb\") as f:\n        f.write(files.file.read())\n\n    # \n    with zipfile.ZipFile(file=os.path.join(interaction_dir, \"workspace.zip\"), mode=\"r\") as zip_file:\n        zip_list = zip_file.namelist()  # \n        for f in zip_list:\n            zip_file.extract(f, interaction_dir)  # \n\n    # \n    os.remove(os.path.join(interaction_dir, \"workspace.zip\"))\n\n    base = InteractionBase(**interaction)\n\n    share = SharedInteractionBase(\n        interaction_id=interaction_id,\n        user_name=user_name,\n        create_time=interaction[\"create_time\"],\n        update_time=interaction[\"update_time\"],\n        description=interaction[\"description\"],\n        agent=interaction[\"agent\"],\n        mode=interaction[\"mode\"],\n        is_deleted=False,\n        star=0,\n        is_audit=False\n    )\n\n    InteractionCRUD.create_interaction(db=db, base=base)\n\n    InteractionCRUD.add_share(db=db, share=share)\n\n    for raw in raws:\n        old_raw = InteractionCRUD.get_raw(db=db,\n                                          interaction_id=interaction_id,\n                                          node_id=raw[\"node_id\"])\n        if old_raw is None:\n            xraw = XAgentRaw(**raw)\n            InteractionCRUD.insert_raw(db=db, process=xraw)\n\n    return ResponseBody(data=None, success=True, message=\"success\")\n",
            "name_column": 4
        },
        "delete_interaction": {
            "type": "AsyncFunctionDef",
            "name": "delete_interaction",
            "md_content": "",
            "code_start_line": 254,
            "code_end_line": 264,
            "parent": null,
            "have_return": true,
            "code_content": "async def delete_interaction(user_id: str = Depends(user_is_available),\n                             interaction_id: str = Form(...),\n                             db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    delete\n    \"\"\"\n\n    data = InteractionCRUD.delete_interaction(db=db,\n                                              interaction_id=interaction_id)\n\n    return ResponseBody(data=data, success=True, message=\"success\")\n",
            "name_column": 10
        },
        "update_interaction_parameter": {
            "type": "AsyncFunctionDef",
            "name": "update_interaction_parameter",
            "md_content": "",
            "code_start_line": 268,
            "code_end_line": 293,
            "parent": null,
            "have_return": true,
            "code_content": "async def update_interaction_parameter(user_id: str = Depends(user_is_available),\n                                       mode: str = Form(...),\n                                       agent: str = Form(...),\n                                       file_list: List[str] = Form(...),\n                                       interaction_id: str = Form(...),\n                                       db: Session = Depends(get_db)\n                                       ) -> ResponseBody:\n    \"\"\"\n    update parameter\n\n    \"\"\"\n    if interaction_id == \"\":\n        return ResponseBody(success=False, message=\"interaction_id is empty!\")\n    interaction = InteractionCRUD.get_interaction(db=db,\n                                                  interaction_id=interaction_id)\n    if interaction is None:\n        return ResponseBody(success=False, message=f\"Don't find any interaction by interaction_id:\\\n            {interaction_id}, Please check your interaction_id!\")\n    update_data = {\n        \"interaction_id\": interaction_id,\n        \"agent\": agent,\n        \"mode\": mode,\n        \"file_list\": [json.loads(l) for l in file_list],\n    }\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\n    return ResponseBody(data=update_data, success=True, message=\"success!\")\n",
            "name_column": 10
        },
        "update_interaction_description": {
            "type": "AsyncFunctionDef",
            "name": "update_interaction_description",
            "md_content": "",
            "code_start_line": 297,
            "code_end_line": 318,
            "parent": null,
            "have_return": true,
            "code_content": "async def update_interaction_description(user_id: str = Depends(user_is_available),\n                                         description: str = Form(...),\n                                         interaction_id: str = Form(...),\n                                         db: Session = Depends(get_db)\n                                         ) -> ResponseBody:\n    \"\"\"\n    update description\n\n    \"\"\"\n    if interaction_id == \"\":\n        return ResponseBody(success=False, message=\"interaction_id is empty!\")\n    interaction = InteractionCRUD.get_interaction(db=db,\n                                                  interaction_id=interaction_id)\n    if interaction is None:\n        return ResponseBody(success=False, message=f\"Don't find any interaction by interaction_id:\\\n            {interaction_id}, Please check your interaction_id!\")\n    update_data = {\n        \"interaction_id\": interaction_id,\n        \"description\": description if description else \"XAgent\",\n    }\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\n    return ResponseBody(data=update_data, success=True, message=\"success!\")\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/routers/workspace.py": {
        "user_is_available": {
            "type": "FunctionDef",
            "name": "user_is_available",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 38,
            "parent": null,
            "have_return": true,
            "code_content": "def user_is_available(\n        user_id: str = Form(...),\n        token: str = Form(...),\n        db: Session = Depends(get_db)):\n    \"\"\"\n    check user is available    \n    \"\"\"\n    if user_id == \"\":\n        raise HTTPException(status_code=401, detail=\"user_id is empty!\")\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\n        raise HTTPException(status_code=401, detail=\"user is not exist!\")\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\n        raise HTTPException(\n            status_code=401, detail=\"user is not available!\")\n    return user_id\n",
            "name_column": 4
        },
        "create_upload_files": {
            "type": "AsyncFunctionDef",
            "name": "create_upload_files",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 67,
            "parent": null,
            "have_return": true,
            "code_content": "async def create_upload_files(files: List[UploadFile] = File(...),\n                              user_id: str = Depends(user_is_available)) -> ResponseBody:\n    \"\"\"Upload Files\"\"\"\n\n    if len(files) == 0:\n        return ResponseBody(success=False, message=\"files is empty!\")\n    if len(files) > 5:\n        files = files[:5]\n\n    if not os.path.exists(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id)):\n        os.makedirs(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id))\n\n    for f in files:\n        if f.size > 1024 * 1024 * 1:\n            return ResponseBody(success=False,\n                                message=\"file size is too large, limit is 1MB for each file!\")\n\n    file_list = []\n    for file in files:\n        file_name = uuid.uuid4().hex + os.path.splitext(file.filename)[-1]\n        with open(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id, file_name), \"wb\") as f:\n            f.write(await file.read())\n            file_list.append({\"uuid\": file_name, \"name\": file.filename})\n    return ResponseBody(data={\"user_id\": user_id,\n                              \"file_list\": file_list},\n                        success=True, message=\"upload success\")\n",
            "name_column": 10
        },
        "file": {
            "type": "AsyncFunctionDef",
            "name": "file",
            "md_content": "",
            "code_start_line": 71,
            "code_end_line": 139,
            "parent": null,
            "have_return": true,
            "code_content": "async def file(user_id: str = Depends(user_is_available),\n               interaction_id: str = Form(...),\n               db: Session = Depends(get_db),\n               file_name: str = Form(...)):\n    \"\"\"\n    get download file\n    \"\"\"\n    interaction = InteractionCRUD.get_interaction(db=db, interaction_id=interaction_id)\n\n    if interaction is None:\n        return ResponseBody(success=False, message=\"interaction is not exist!\")\n\n    time_str = interaction.create_time[:10]\n\n    file_path = os.path.join(\n        XAgentServerEnv.base_dir,\n        \"localstorage/interact_records\",\n        time_str,\n        interaction_id,\n        \"workspace\")\n    if not os.path.exists(file_path):\n        return ResponseBody(success=False,\n                            message=\"file is not exist!\")\n\n    file_suffix = file_name.split(\".\")[-1]\n    if file_suffix in [\"jpg\", \"png\",\n                       \"jpeg\", \"gif\", \"bmp\"]:\n        with open(os.path.join(file_path, file_name), \"rb\") as f:\n            data = base64.b64encode(f.read()).decode(\"utf-8\")\n        return ResponseBody(\n            data=f\"data:image/{file_suffix};base64,{data}\",\n            success=True,\n            message=\"get file success!\"\n        )\n\n    if file_suffix in [\"mp4\", \"avi\", \"mkv\",\n                       \"rmvb\", \"rm\", \"flv\", \"3gp\", \"wmv\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"video/\" + file_suffix)\n\n    if file_suffix in [\"mp3\", \"wav\", \"wma\",\n                       \"ogg\", \"aac\", \"flac\", \"ape\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"audio/\" + file_suffix)\n\n    if file_suffix in [\"pdf\", \"doc\", \"docx\",\n                       \"xls\", \"xlsx\", \"ppt\", \"pptx\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"application/\" + file_suffix)\n\n    if file_suffix in [\"json\"]:\n        with open(os.path.join(file_path, file_name), 'r', encoding=\"utf-8\") as f:\n            data = json.load(f)\n\n        return ResponseBody(data=json.dumps(data,\n                                            ensure_ascii=False,\n                                            indent=4),\n                            success=True,\n                            message=\"get file success!\")\n\n    if file_suffix in [\"ipynb\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"application/\" + file_suffix)\n    \n    \n    with open(os.path.join(file_path, file_name), 'r', encoding=\"utf-8\") as f:\n        data = f.read()\n\n    return ResponseBody(data=data, success=True, message=\"get file success!\")\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/core/envs.py": {
        "XAgentServerEnv": {
            "type": "ClassDef",
            "name": "XAgentServerEnv",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 90,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentServerEnv:\n    \"\"\"\n    XAgentServer environment variables\n    if you change value of the environment variable, you need to restart \n    the XAgentServer by running the following command:\n    `python start_server.py`\n    or start a unicorn server by yourself\n    \"\"\"\n    app = \"app:app\"\n    prod: bool = config.get(\"PROD\", \"False\").lower() == \"true\"\n    base_dir = \"XAgentServer\"\n    use_redis: bool = False\n    recorder_root_dir = \"running_records\"\n    # you can set default_login with True,\n    # use the default user \"admin\" with token \"xagent-admin\" to login,\n    default_login: bool = True\n    # only one XAgentServer can be set to check whether the interaction is running.\n    check_running: bool = False\n    host = \"0.0.0.0\"\n    port = 8090\n    debug = True\n    reload = True\n    workers = 1\n    share_url = \"https://x-agent.net/api/conv/community\"\n\n    class DB:\n        \"\"\"\n        database config\n        \"\"\"\n        use_db = True\n        db_url = \"mysql+pymysql://root:xagent@localhost:3306/xagent\"\n\n    class Redis:\n        \"\"\"\n        redis config\n        \"\"\"\n        use_redis = False\n        redis_url = \"redis://localhost\"\n        redis_host = \"localhost\"\n        redis_port = 6379\n        redis_db = 0\n        redis_password = \"xagent\"\n\n    # if you want to use email to send message,\n    # you can set send_email to True and set\n    # email_host,\n    # email_port,\n    # email_user,\n    # email_password,\n    # auth_server\n    class Email:\n        \"\"\"\n        email config\n        \"\"\"\n        send_email = False\n        email_host = \"\"\n        email_port = 465\n        email_user = \"\"\n        email_password = \"\"\n        auth_server = \"\"\n\n    # if you want to use upload function,\n    # you can set upload_dir to the path of the upload directory\n    # and set upload_allowed_types of the allowed types\n    class Upload:\n        \"\"\"\n        upload config\n        \"\"\"\n        upload_dir = \"XAgentServer/localstorage/upload\"\n        if not os.path.exists(upload_dir):\n            os.makedirs(upload_dir)\n        upload_allowed_types = [\"image/png\", \"image/jpeg\",\n                                \"image/gif\", \"text/plain\",\n                                \"application/msword\", \"pdf\",\n                                \"txt\", \"pptx\", \"xlsx\",\n                                \"doc\", \"ppt\", \"xls\",\n                                \"zip\", \"rar\", \"tar\",\n                                \"gz\", \"7z\", \"bz2\",\n                                \"tgz\", \"tbz2\", \"tar.gz\",\n                                \"tar.bz2\"]\n",
            "name_column": 6
        },
        "DB": {
            "type": "ClassDef",
            "name": "DB",
            "md_content": "",
            "code_start_line": 36,
            "code_end_line": 41,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class DB:\n        \"\"\"\n        database config\n        \"\"\"\n        use_db = True\n        db_url = \"mysql+pymysql://root:xagent@localhost:3306/xagent\"\n",
            "name_column": 10
        },
        "Redis": {
            "type": "ClassDef",
            "name": "Redis",
            "md_content": "",
            "code_start_line": 43,
            "code_end_line": 52,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class Redis:\n        \"\"\"\n        redis config\n        \"\"\"\n        use_redis = False\n        redis_url = \"redis://localhost\"\n        redis_host = \"localhost\"\n        redis_port = 6379\n        redis_db = 0\n        redis_password = \"xagent\"\n",
            "name_column": 10
        },
        "Email": {
            "type": "ClassDef",
            "name": "Email",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 70,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class Email:\n        \"\"\"\n        email config\n        \"\"\"\n        send_email = False\n        email_host = \"\"\n        email_port = 465\n        email_user = \"\"\n        email_password = \"\"\n        auth_server = \"\"\n",
            "name_column": 10
        },
        "Upload": {
            "type": "ClassDef",
            "name": "Upload",
            "md_content": "",
            "code_start_line": 75,
            "code_end_line": 90,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class Upload:\n        \"\"\"\n        upload config\n        \"\"\"\n        upload_dir = \"XAgentServer/localstorage/upload\"\n        if not os.path.exists(upload_dir):\n            os.makedirs(upload_dir)\n        upload_allowed_types = [\"image/png\", \"image/jpeg\",\n                                \"image/gif\", \"text/plain\",\n                                \"application/msword\", \"pdf\",\n                                \"txt\", \"pptx\", \"xlsx\",\n                                \"doc\", \"ppt\", \"xls\",\n                                \"zip\", \"rar\", \"tar\",\n                                \"gz\", \"7z\", \"bz2\",\n                                \"tgz\", \"tbz2\", \"tar.gz\",\n                                \"tar.bz2\"]\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/websockets/replayer.py": {
        "ReplayServer": {
            "type": "ClassDef",
            "name": "ReplayServer",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 195,
            "parent": null,
            "have_return": true,
            "code_content": "class ReplayServer(WebSocketEndpoint):\n    \"\"\"Main Websocket Server\n    Extends:\n        WebSocketEndpoint\n    \n    Description:\n        In this websocket, we will receive the args from user,\n        and you can use it to run the interaction.\n        specifically, the args is a dict, \n        and it must contain a key named \"goal\" to tell XAgent what do you want to do.\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        \n    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n            \n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"replay.log\", log_name=f\"{self.client_id}_REPLAY\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(status=\"connect\",\n                                    success=False,\n                                    message=str(exc),\n                                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        \n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"replay\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n                 \n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        \n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n        for row in rows:\n            self.logger.typewriter_log(\n                title=f\"Send data to {self.client_id}: \",\n                title_color=Fore.RED,\n                content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n            )\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n            await self.websocket.send_text(\n                WebsocketResponseBody(status=row.status,\n                                    success=True, message=\"success\",\n                                    data=handle_data(row=row, root_dir=root_dir),\n                                    current=row.current,\n                                    node_id=row.node_id,\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n            # await asyncio.sleep(random.randint(1, 3))\n        if self.scheduler.running:\n            self.scheduler.shutdown()",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 50,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 80,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 83,
            "code_end_line": 129,
            "parent": "ReplayServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"replay.log\", log_name=f\"{self.client_id}_REPLAY\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(status=\"connect\",\n                                    success=False,\n                                    message=str(exc),\n                                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 131,
            "code_end_line": 141,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 144,
            "code_end_line": 165,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"replay\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n",
            "name_column": 14
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 167,
            "code_end_line": 171,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 195,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        \n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n        for row in rows:\n            self.logger.typewriter_log(\n                title=f\"Send data to {self.client_id}: \",\n                title_color=Fore.RED,\n                content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n            )\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n            await self.websocket.send_text(\n                WebsocketResponseBody(status=row.status,\n                                    success=True, message=\"success\",\n                                    data=handle_data(row=row, root_dir=root_dir),\n                                    current=row.current,\n                                    node_id=row.node_id,\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n            # await asyncio.sleep(random.randint(1, 3))\n        if self.scheduler.running:\n            self.scheduler.shutdown()",
            "name_column": 14
        }
    },
    "XAgentServer/application/websockets/recorder.py": {
        "RecorderServer": {
            "type": "ClassDef",
            "name": "RecorderServer",
            "md_content": "",
            "code_start_line": 36,
            "code_end_line": 326,
            "parent": null,
            "have_return": true,
            "code_content": "class RecorderServer(WebSocketEndpoint):\n    \"\"\"Recorder Websocket Server\n    Extends:\n        WebSocketEndpoint\n    \n    Recorder:\n        You can use this to reproduce the recorder you have executed\n        You can find this in XAgent GUI Menu: Settings -> Run Recorder\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n\n    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # this is notice the agent to stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If you have an interaction running, \n            you can't connect to XAgent\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        recorder_dir = parameters.get(\"recorder_dir\", [\"\"])[0]\n        description = \"XAgent Recorder\"\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, recorder_dir: {recorder_dir}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n\n            base = InteractionBase(interaction_id=self.client_id,\n                                user_id=user_id,\n                                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                description=description if description else \"XAgent Recorder\",\n                                agent=\"XAgent\",\n                                mode=\"auto\",\n                                file_list=[],\n                                recorder_root_dir=os.path.join(\n                                    XAgentServerEnv.recorder_root_dir, recorder_dir),\n                                status=\"waiting\",\n                                message=\"waiting...\",\n                                current_step=uuid.uuid4().hex,\n                                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                call_method=\"recorder\",\n                                )\n            InteractionCRUD.create_interaction(db=self.db, base=base)\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"failed\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        # await websocket.close(code=close_code)\n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"recorder\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n                t = threading.Thread(target=self.task_handler)\n                t.start()\n\n\n    def task_handler(self):\n        \"\"\"\n        define a long task to run interaction\n        \n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n        try:\n            InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data=None,\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                    interaction_id=base.interaction_id,\n                                                    status=\"running\",\n                                                    message=\"running\",\n                                                    current_step=current_step)\n\n            # Create XAgentInteraction to run interaction\n            interaction = XAgentInteraction(\n                base=base, parameter=None, interrupt=False, call_method=\"recorder\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n\n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        if send_status:\n            rows = InteractionCRUD.get_next_send(\n                db=self.db, interaction_id=self.client_id)\n            rows = rows[::-1]\n            for row in rows:\n                if not row.is_send:\n                    self.logger.typewriter_log(\n                        title=f\"Send data to {self.client_id}: \",\n                        title_color=Fore.RED,\n                        content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                    )\n                    if row.status in [StatusEnum.FAILED]:\n                        # when interaction is falied, we will send the message to client\n                        # and the message is the result of interaction\n                        message = row.data\n                    else:\n                        message = \"success\"\n\n                    root_dir = os.path.join(XAgentServerEnv.base_dir,\n                                            \"localstorage\",\n                                            \"interact_records\",\n                                            row.create_time[:10],\n                                            row.interaction_id)\n                    await self.websocket.send_text(\n                        WebsocketResponseBody(\n                            status=row.status,\n                            success=True, message=message,\n                            data=handle_data(row=row, root_dir=root_dir),\n                            current=row.current,\n                            node_id=row.node_id,\n                            workspace_file_list=handle_workspace_filelist(\n                                row.file_list)\n                        ).to_text())\n                    InteractionCRUD.update_send_flag(\n                        db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                    redis.delete_key(f\"{self.client_id}_send\")\n\n                    if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                        self.continue_flag = False\n                        break\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 56,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 58,
            "code_end_line": 93,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # this is notice the agent to stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 95,
            "code_end_line": 164,
            "parent": "RecorderServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If you have an interaction running, \n            you can't connect to XAgent\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        recorder_dir = parameters.get(\"recorder_dir\", [\"\"])[0]\n        description = \"XAgent Recorder\"\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, recorder_dir: {recorder_dir}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n\n            base = InteractionBase(interaction_id=self.client_id,\n                                user_id=user_id,\n                                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                description=description if description else \"XAgent Recorder\",\n                                agent=\"XAgent\",\n                                mode=\"auto\",\n                                file_list=[],\n                                recorder_root_dir=os.path.join(\n                                    XAgentServerEnv.recorder_root_dir, recorder_dir),\n                                status=\"waiting\",\n                                message=\"waiting...\",\n                                current_step=uuid.uuid4().hex,\n                                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                call_method=\"recorder\",\n                                )\n            InteractionCRUD.create_interaction(db=self.db, base=base)\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"failed\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 166,
            "code_end_line": 176,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 179,
            "code_end_line": 202,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"recorder\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n                t = threading.Thread(target=self.task_handler)\n                t.start()\n",
            "name_column": 14
        },
        "task_handler": {
            "type": "FunctionDef",
            "name": "task_handler",
            "md_content": "",
            "code_start_line": 205,
            "code_end_line": 274,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    def task_handler(self):\n        \"\"\"\n        define a long task to run interaction\n        \n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n        try:\n            InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data=None,\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                    interaction_id=base.interaction_id,\n                                                    status=\"running\",\n                                                    message=\"running\",\n                                                    current_step=current_step)\n\n            # Create XAgentInteraction to run interaction\n            interaction = XAgentInteraction(\n                base=base, parameter=None, interrupt=False, call_method=\"recorder\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n",
            "name_column": 8
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 276,
            "code_end_line": 280,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 282,
            "code_end_line": 326,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        if send_status:\n            rows = InteractionCRUD.get_next_send(\n                db=self.db, interaction_id=self.client_id)\n            rows = rows[::-1]\n            for row in rows:\n                if not row.is_send:\n                    self.logger.typewriter_log(\n                        title=f\"Send data to {self.client_id}: \",\n                        title_color=Fore.RED,\n                        content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                    )\n                    if row.status in [StatusEnum.FAILED]:\n                        # when interaction is falied, we will send the message to client\n                        # and the message is the result of interaction\n                        message = row.data\n                    else:\n                        message = \"success\"\n\n                    root_dir = os.path.join(XAgentServerEnv.base_dir,\n                                            \"localstorage\",\n                                            \"interact_records\",\n                                            row.create_time[:10],\n                                            row.interaction_id)\n                    await self.websocket.send_text(\n                        WebsocketResponseBody(\n                            status=row.status,\n                            success=True, message=message,\n                            data=handle_data(row=row, root_dir=root_dir),\n                            current=row.current,\n                            node_id=row.node_id,\n                            workspace_file_list=handle_workspace_filelist(\n                                row.file_list)\n                        ).to_text())\n                    InteractionCRUD.update_send_flag(\n                        db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                    redis.delete_key(f\"{self.client_id}_send\")\n\n                    if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                        self.continue_flag = False\n                        break\n",
            "name_column": 14
        }
    },
    "XAgentServer/application/websockets/__init__.py": {},
    "XAgentServer/application/websockets/common.py": {
        "check_user": {
            "type": "AsyncFunctionDef",
            "name": "check_user",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "async def check_user(db, user_id, token):\n    \"\"\"\n    check user for websocket connection\n    \"\"\"\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\n        raise XAgentWebSocketConnectError(\"user is not exist!\")\n    # auth\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\n        raise XAgentWebSocketConnectError(\"user is not available!\")\n\n    user = UserCRUD.get_user(db=db, user_id=user_id)\n    if not user or user.token != token or user.available is False or user.is_beta is False:\n        raise XAgentWebSocketConnectError(\n            \"XAgentServer is running in production mode, if you want to use it, please contact the administrator.\")\n",
            "name_column": 10
        },
        "handle_data": {
            "type": "FunctionDef",
            "name": "handle_data",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 65,
            "parent": null,
            "have_return": true,
            "code_content": "def handle_data(row: Raw, root_dir: str):\n    \"\"\"\n    handle data for websocket response\n    \"\"\"\n    data = row.data\n    try:\n        using_tools = data.get(\"using_tools\", \"\")\n        if not using_tools:\n            return data\n        tool_name = using_tools.get(\"tool_name\", \"\") if isinstance(\n            using_tools, dict) else \"\"\n        tool_output = using_tools.get(\n            \"tool_output\", {}) if isinstance(using_tools, dict) else \"\"\n        tool_input = using_tools.get(\n            \"tool_input\", {}) if isinstance(using_tools, dict) else \"\"\n        if row.include_pictures:\n            if tool_name == \"PythonNotebook_execute_cell\":\n                for output in tool_output:\n                    if isinstance(output, dict) and 'file_name' in output:\n                        file_name = output['file_name']\n                        png_base64 = None\n                        if file_name:\n                            file_path = os.path.join(\n                                root_dir, \"workspace\", file_name)\n                            if os.path.exists(file_path):\n                                try:\n                                    with open(file_path, \"rb\") as f:\n                                        png_base64 = base64.b64encode(\n                                            f.read()).decode(\"utf-8\")\n                                except Exception:\n                                    pass\n\n                        output[\"file_data\"] = png_base64\n                        using_tools[\"is_include_pictures\"] = True\n    \n        if tool_input:\n            data[\"using_tools\"][\"tool_input\"] = tool_input.encode(\"utf-8\").decode(\"unicode_escape\")\n        if tool_output and isinstance(tool_output, str):\n            data[\"using_tools\"][\"tool_output\"] = tool_output.encode(\"utf-8\").decode(\"unicode_escape\")\n    except Exception:\n        pass\n    return data\n",
            "name_column": 4
        },
        "handle_workspace_filelist": {
            "type": "FunctionDef",
            "name": "handle_workspace_filelist",
            "md_content": "",
            "code_start_line": 68,
            "code_end_line": 79,
            "parent": null,
            "have_return": true,
            "code_content": "def handle_workspace_filelist(file_list):\n    \"\"\"handle workspace file list\n\n    Args:\n        file_list (_type_): file_list is a list of file name\n\n    Returns:\n        List[Dict]: element list, each element is a dict with name and suffix\n    \"\"\"\n    if not isinstance(file_list, list) or not file_list:\n        return []\n    return [{\"name\": file, \"suffix\": file.split(\".\")[-1]}  for file in file_list]\n",
            "name_column": 4
        }
    },
    "XAgentServer/application/websockets/share.py": {
        "ReplayServer": {
            "type": "ClassDef",
            "name": "ReplayServer",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 198,
            "parent": null,
            "have_return": true,
            "code_content": "class ReplayServer(WebSocketEndpoint):\n    \"\"\"Main Websocket Server\n    Extends:\n        WebSocketEndpoint\n    \n    Description:\n        In this websocket, we will receive the args from user,\n        and you can use it to run the interaction.\n        specifically, the args is a dict, \n        and it must contain a key named \"goal\" to tell XAgent what do you want to do.\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        \n    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n            \n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n        \n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"share.log\", log_name=f\"{self.client_id}_SHARE\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            # await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(exc),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        \n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"shared\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n                 \n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        try:\n            rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n            for row in rows:\n                self.logger.typewriter_log(\n                    title=f\"Send data to {self.client_id}: \",\n                    title_color=Fore.RED,\n                    content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                )\n                root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n                await self.websocket.send_text(\n                    WebsocketResponseBody(status=row.status,\n                                        success=True, message=\"success\",\n                                        data=handle_data(row=row, root_dir=root_dir),\n                                        current=row.current,\n                                        node_id=row.node_id,\n                                        workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n                await asyncio.sleep(random.randint(1, 3))\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n        except:\n            if self.scheduler.running:\n                self.scheduler.shutdown()",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 50,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 80,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 82,
            "code_end_line": 129,
            "parent": "ReplayServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n        \n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"share.log\", log_name=f\"{self.client_id}_SHARE\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            # await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(exc),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 131,
            "code_end_line": 141,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 144,
            "code_end_line": 165,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"shared\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n",
            "name_column": 14
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 167,
            "code_end_line": 171,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 198,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        try:\n            rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n            for row in rows:\n                self.logger.typewriter_log(\n                    title=f\"Send data to {self.client_id}: \",\n                    title_color=Fore.RED,\n                    content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                )\n                root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n                await self.websocket.send_text(\n                    WebsocketResponseBody(status=row.status,\n                                        success=True, message=\"success\",\n                                        data=handle_data(row=row, root_dir=root_dir),\n                                        current=row.current,\n                                        node_id=row.node_id,\n                                        workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n                await asyncio.sleep(random.randint(1, 3))\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n        except:\n            if self.scheduler.running:\n                self.scheduler.shutdown()",
            "name_column": 14
        }
    },
    "XAgentServer/application/websockets/base.py": {
        "MainServer": {
            "type": "ClassDef",
            "name": "MainServer",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 390,
            "parent": null,
            "have_return": true,
            "code_content": "class MainServer(WebSocketEndpoint):\n    \"\"\"Main Websocket Server\n    Extends:\n        WebSocketEndpoint\n\n    Description:\n        In this websocket, we will receive the args from user,\n        and you can use it to run the interaction.\n        specifically, the args is a dict, \n        and it must contain a key named \"goal\" to tell XAgent what do you want to do.\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n\n    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            interaction = InteractionCRUD.get_interaction(\n                db=self.db, interaction_id=self.client_id)\n            if interaction.status not in [StatusEnum.FINISHED, StatusEnum.FAILED]:\n                InteractionCRUD.update_interaction_status(db=self.db,\n                                                          interaction_id=self.client_id,\n                                                          status=StatusEnum.CLOSED,\n                                                          message=\"closed\",\n                                                          current_step=\"0\")\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # notice the agent stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        description = parameters.get(\"description\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, description: {description}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            if base is None:\n                raise XAgentWebSocketConnectError(\n                    \"init interaction failed, please restart!\")\n\n            InteractionCRUD.update_interaction(db=self.db,\n                                               base_data={\n                                                   \"interaction_id\": self.client_id,\n                                                   \"status\": \"connected\",\n                                                   \"message\": \"connected\",\n                                                   \"current_step\": \"0\",\n                                                   \"description\": description}\n                                               )\n\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        # await websocket.close(code=close_code)\n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n\n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        if data.get(\"type\", \"\") != \"ping\":\n            self.logger.typewriter_log(\n                title=f\"Receive data from {self.client_id}: \",\n                title_color=Fore.RED,\n                content=json.dumps(data, indent=4, ensure_ascii=False)\n            )\n        if data.get(\"type\", \"\") == \"data\":\n            args = data.get(\"args\", {})\n            agent = data.get(\"agent\", \"\")\n            mode = data.get(\"mode\", \"\")\n            file_list = data.get(\"file_list\", [])\n            node_id = data.get(\"node_id\", \"\")\n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args=args,\n            )\n            InteractionCRUD.add_parameter(db=self.db, parameter=parameter)\n\n            if node_id:\n                InteractionCRUD.update_human_data(\n                    db=self.db, interaction_id=self.client_id, node_id=node_id, human_data=args)\n                redis.set_key(f\"{self.client_id}_{node_id}_receive\", 1)\n\n            else:\n                InteractionCRUD.update_interaction(db=self.db,\n                                                   base_data={\n                                                       \"interaction_id\": self.client_id,\n                                                       \"agent\": agent,\n                                                       \"mode\": mode,\n                                                       \"file_list\": file_list,\n                                                       \"create_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}\n                                                   )\n                # Create a new raw data to record\n                InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                    interaction_id=self.client_id,\n                    node_id=uuid.uuid4().hex,\n                    status=StatusEnum.RUNNING,\n                    create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    current=\"\",\n                    step=-1,\n                    data=None,\n                    file_list=[],\n                    do_interrupt=mode != \"auto\",\n                    wait_seconds=0,\n                    ask_for_human_help=False,\n                    is_human=True,\n                    human_data=args,\n                    human_file_list=file_list,\n                    is_send=False,\n                    is_receive=False,\n                    is_deleted=False\n                ))\n                redis.set_key(f\"{self.client_id}_send\", 1)\n\n            if not self.scheduler.running:\n                # add pong job to scheduler\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                # add send data job to scheduler\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n\n                # start a new thread to run interaction\n                t = threading.Thread(\n                    target=self.task_handler, args=(parameter,))\n                t.start()\n\n    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=base.interaction_id,\n                                                      status=\"running\",\n                                                      message=\"running\",\n                                                      current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n\n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        try:\n            if send_status:\n                rows = InteractionCRUD.get_next_send(\n                    db=self.db, interaction_id=self.client_id)\n                rows = rows[::-1]\n                for row in rows:\n                    if not row.is_send:\n                        self.logger.typewriter_log(\n                            title=f\"Send data to {self.client_id}: \",\n                            title_color=Fore.RED,\n                            content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                        )\n                        if row.status in [StatusEnum.FAILED]:\n                            # when interaction is falied, we will send the message to client\n                            # and the message is the result of interaction\n                            message = row.data\n                        else:\n                            message = \"success\"\n\n                        await self.websocket.send_text(\n                            WebsocketResponseBody(\n                                status=row.status,\n                                success=True, message=message,\n                                data=handle_data(row=row, root_dir=self.log_dir),\n                                current=row.current,\n                                node_id=row.node_id,\n                                workspace_file_list=handle_workspace_filelist(\n                                    row.file_list)\n                            ).to_text())\n                        InteractionCRUD.update_send_flag(\n                            db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                        redis.delete_key(f\"{self.client_id}_send\")\n\n                        if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                            self.continue_flag = False\n                            break\n        except Exception as e:\n            self.logger.error(\n                f\"Error in send_data of {self.client_id}: {e}\")\n            traceback.print_exc()\n            self.continue_flag = False\n            raise XAgentError(e) from e",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 70,
            "code_end_line": 79,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 124,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            interaction = InteractionCRUD.get_interaction(\n                db=self.db, interaction_id=self.client_id)\n            if interaction.status not in [StatusEnum.FINISHED, StatusEnum.FAILED]:\n                InteractionCRUD.update_interaction_status(db=self.db,\n                                                          interaction_id=self.client_id,\n                                                          status=StatusEnum.CLOSED,\n                                                          message=\"closed\",\n                                                          current_step=\"0\")\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # notice the agent stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 126,
            "code_end_line": 191,
            "parent": "MainServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        description = parameters.get(\"description\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, description: {description}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            if base is None:\n                raise XAgentWebSocketConnectError(\n                    \"init interaction failed, please restart!\")\n\n            InteractionCRUD.update_interaction(db=self.db,\n                                               base_data={\n                                                   \"interaction_id\": self.client_id,\n                                                   \"status\": \"connected\",\n                                                   \"message\": \"connected\",\n                                                   \"current_step\": \"0\",\n                                                   \"description\": description}\n                                               )\n\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 193,
            "code_end_line": 203,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 206,
            "code_end_line": 281,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n\n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        if data.get(\"type\", \"\") != \"ping\":\n            self.logger.typewriter_log(\n                title=f\"Receive data from {self.client_id}: \",\n                title_color=Fore.RED,\n                content=json.dumps(data, indent=4, ensure_ascii=False)\n            )\n        if data.get(\"type\", \"\") == \"data\":\n            args = data.get(\"args\", {})\n            agent = data.get(\"agent\", \"\")\n            mode = data.get(\"mode\", \"\")\n            file_list = data.get(\"file_list\", [])\n            node_id = data.get(\"node_id\", \"\")\n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args=args,\n            )\n            InteractionCRUD.add_parameter(db=self.db, parameter=parameter)\n\n            if node_id:\n                InteractionCRUD.update_human_data(\n                    db=self.db, interaction_id=self.client_id, node_id=node_id, human_data=args)\n                redis.set_key(f\"{self.client_id}_{node_id}_receive\", 1)\n\n            else:\n                InteractionCRUD.update_interaction(db=self.db,\n                                                   base_data={\n                                                       \"interaction_id\": self.client_id,\n                                                       \"agent\": agent,\n                                                       \"mode\": mode,\n                                                       \"file_list\": file_list,\n                                                       \"create_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}\n                                                   )\n                # Create a new raw data to record\n                InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                    interaction_id=self.client_id,\n                    node_id=uuid.uuid4().hex,\n                    status=StatusEnum.RUNNING,\n                    create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    current=\"\",\n                    step=-1,\n                    data=None,\n                    file_list=[],\n                    do_interrupt=mode != \"auto\",\n                    wait_seconds=0,\n                    ask_for_human_help=False,\n                    is_human=True,\n                    human_data=args,\n                    human_file_list=file_list,\n                    is_send=False,\n                    is_receive=False,\n                    is_deleted=False\n                ))\n                redis.set_key(f\"{self.client_id}_send\", 1)\n\n            if not self.scheduler.running:\n                # add pong job to scheduler\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                # add send data job to scheduler\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n\n                # start a new thread to run interaction\n                t = threading.Thread(\n                    target=self.task_handler, args=(parameter,))\n                t.start()\n",
            "name_column": 14
        },
        "task_handler": {
            "type": "FunctionDef",
            "name": "task_handler",
            "md_content": "",
            "code_start_line": 283,
            "code_end_line": 336,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=base.interaction_id,\n                                                      status=\"running\",\n                                                      message=\"running\",\n                                                      current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n",
            "name_column": 8
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 338,
            "code_end_line": 342,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 344,
            "code_end_line": 390,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        try:\n            if send_status:\n                rows = InteractionCRUD.get_next_send(\n                    db=self.db, interaction_id=self.client_id)\n                rows = rows[::-1]\n                for row in rows:\n                    if not row.is_send:\n                        self.logger.typewriter_log(\n                            title=f\"Send data to {self.client_id}: \",\n                            title_color=Fore.RED,\n                            content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                        )\n                        if row.status in [StatusEnum.FAILED]:\n                            # when interaction is falied, we will send the message to client\n                            # and the message is the result of interaction\n                            message = row.data\n                        else:\n                            message = \"success\"\n\n                        await self.websocket.send_text(\n                            WebsocketResponseBody(\n                                status=row.status,\n                                success=True, message=message,\n                                data=handle_data(row=row, root_dir=self.log_dir),\n                                current=row.current,\n                                node_id=row.node_id,\n                                workspace_file_list=handle_workspace_filelist(\n                                    row.file_list)\n                            ).to_text())\n                        InteractionCRUD.update_send_flag(\n                            db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                        redis.delete_key(f\"{self.client_id}_send\")\n\n                        if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                            self.continue_flag = False\n                            break\n        except Exception as e:\n            self.logger.error(\n                f\"Error in send_data of {self.client_id}: {e}\")\n            traceback.print_exc()\n            self.continue_flag = False\n            raise XAgentError(e) from e",
            "name_column": 14
        }
    },
    "XAgentServer/application/schemas/response_body.py": {
        "ResponseBody": {
            "type": "ClassDef",
            "name": "ResponseBody",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 23,
            "parent": null,
            "have_return": true,
            "code_content": "class ResponseBody(BaseModel):\n    \"\"\"Response body\n    \"\"\"\n    data: Union[str, dict, list, Json, None] = None\n    success: bool = True\n    message: Union[str, None] = None\n\n    def to_dict(self):\n        \"\"\"to dict\n        \"\"\"\n        return self.dict()\n\n    def to_json(self):\n        \"\"\"to json\n        \"\"\"\n        return self.json()\n",
            "name_column": 6
        },
        "WebsocketResponseBody": {
            "type": "ClassDef",
            "name": "WebsocketResponseBody",
            "md_content": "",
            "code_start_line": 26,
            "code_end_line": 62,
            "parent": null,
            "have_return": true,
            "code_content": "class WebsocketResponseBody():\n    r\"\"\"\n    WerSocket \n\n    Attributes:\n        data: \n\n        status: \n\n        message: \n\n        kwargs: , \n    \"\"\"\n\n    def __init__(self,\n                 data: Union[str, dict, list, Json, None],\n                 status: str = \"success\",\n                 message: Union[str, None] = None,\n                 **kwargs):\n        self.data = data\n        self.status = status\n        self.message = message\n        self.extend(kwargs)\n\n    def to_text(self):\n        r\"\"\"\n        json\n        \"\"\"\n\n        return json.dumps(self.__dict__, ensure_ascii=False, indent=2)\n\n    def extend(self, extend: dict):\n        \"\"\"extend attributes\n        \"\"\"\n        for key, value in extend.items():\n            if key not in self.__dict__.keys():\n                self.__dict__[key] = value\n",
            "name_column": 6
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 15,
            "code_end_line": 18,
            "parent": "ResponseBody",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        \"\"\"to dict\n        \"\"\"\n        return self.dict()\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 23,
            "parent": "ResponseBody",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"to json\n        \"\"\"\n        return self.json()\n",
            "name_column": 8
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 40,
            "code_end_line": 48,
            "parent": "WebsocketResponseBody",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 data: Union[str, dict, list, Json, None],\n                 status: str = \"success\",\n                 message: Union[str, None] = None,\n                 **kwargs):\n        self.data = data\n        self.status = status\n        self.message = message\n        self.extend(kwargs)\n",
            "name_column": 8
        },
        "to_text": {
            "type": "FunctionDef",
            "name": "to_text",
            "md_content": "",
            "code_start_line": 50,
            "code_end_line": 55,
            "parent": "WebsocketResponseBody",
            "have_return": true,
            "code_content": "    def to_text(self):\n        r\"\"\"\n        json\n        \"\"\"\n\n        return json.dumps(self.__dict__, ensure_ascii=False, indent=2)\n",
            "name_column": 8
        },
        "extend": {
            "type": "FunctionDef",
            "name": "extend",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 62,
            "parent": "WebsocketResponseBody",
            "have_return": false,
            "code_content": "    def extend(self, extend: dict):\n        \"\"\"extend attributes\n        \"\"\"\n        for key, value in extend.items():\n            if key not in self.__dict__.keys():\n                self.__dict__[key] = value\n",
            "name_column": 8
        }
    },
    "XAgentServer/application/schemas/request_body.py": {
        "RequestBody": {
            "type": "ClassDef",
            "name": "RequestBody",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 12,
            "parent": null,
            "have_return": false,
            "code_content": "class RequestBody(BaseModel):\n    \"\"\"RequestBody\n    \"\"\"\n    token: str\n    query: str\n    mode: str\n",
            "name_column": 6
        }
    },
    "XAgentServer/application/cruds/user.py": {
        "UserCRUD": {
            "type": "ClassDef",
            "name": "UserCRUD",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 152,
            "parent": null,
            "have_return": true,
            "code_content": "class UserCRUD(metaclass=abc.ABCMeta):\n    \"\"\"\n    User CRUD\n    \"\"\"\n\n    @classmethod\n    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"\n        get all users\n        \n        Args:\n            db: database session\n        \"\"\"\n        try:\n            return UserDBInterface.get_user_list(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"\n        get user by user_id or email\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n        \n        Returns:\n            user\n        \n        \"\"\"\n        try:\n            return UserDBInterface.get_user(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def is_exist(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None):\n        \"\"\"\n        check user is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.is_exist(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"\n        check token is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.token_is_exist(db=db, user_id=user_id, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        check user is valid\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.user_is_valid(db=db, user_id=user_id, email=email, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \n        Args:\n            db: database session\n            user_dict: user dict\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.add_user(db=db, user_dict=user_dict)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \n        Args:\n            db: database session\n            user: user\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.update_user(db=db, user=user)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 6
        },
        "get_user_list": {
            "type": "FunctionDef",
            "name": "get_user_list",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 27,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"\n        get all users\n        \n        Args:\n            db: database session\n        \"\"\"\n        try:\n            return UserDBInterface.get_user_list(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_user": {
            "type": "FunctionDef",
            "name": "get_user",
            "md_content": "",
            "code_start_line": 30,
            "code_end_line": 49,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"\n        get user by user_id or email\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n        \n        Returns:\n            user\n        \n        \"\"\"\n        try:\n            return UserDBInterface.get_user(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 71,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def is_exist(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None):\n        \"\"\"\n        check user is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.is_exist(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "token_is_exist": {
            "type": "FunctionDef",
            "name": "token_is_exist",
            "md_content": "",
            "code_start_line": 74,
            "code_end_line": 93,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"\n        check token is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.token_is_exist(db=db, user_id=user_id, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "user_is_valid": {
            "type": "FunctionDef",
            "name": "user_is_valid",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 116,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        check user is valid\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.user_is_valid(db=db, user_id=user_id, email=email, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "add_user": {
            "type": "FunctionDef",
            "name": "add_user",
            "md_content": "",
            "code_start_line": 119,
            "code_end_line": 134,
            "parent": "UserCRUD",
            "have_return": false,
            "code_content": "    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \n        Args:\n            db: database session\n            user_dict: user dict\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.add_user(db=db, user_dict=user_dict)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_user": {
            "type": "FunctionDef",
            "name": "update_user",
            "md_content": "",
            "code_start_line": 137,
            "code_end_line": 152,
            "parent": "UserCRUD",
            "have_return": false,
            "code_content": "    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \n        Args:\n            db: database session\n            user: user\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.update_user(db=db, user=user)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        }
    },
    "XAgentServer/application/cruds/interaction.py": {
        "InteractionCRUD": {
            "type": "ClassDef",
            "name": "InteractionCRUD",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 543,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionCRUD(metaclass=abc.ABCMeta):\n    \"\"\"\n    interaction crud\n    \"\"\"\n\n    @classmethod\n    def search_many_interaction(cls, db: Session) -> list:\n        \"\"\"\n        search many interaction\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_interaction(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_interaction(cls, db: Session, interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            interaction InteractionBase\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_interaction(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def create_interaction(cls, db: Session, base: InteractionBase):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            base: base\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.create_interaction(db=db, base=base)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n        \n    @classmethod\n    def get_ready_interaction(cls, db: Session, user_id: str):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            user_id: user_id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_ready_interaction(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n\n    @classmethod\n    def add_parameter(cls, db: Session, parameter: InteractionParameter = None):\n        \"\"\"\n        add parameter\n        Args:\n            db: db\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_parameter(db=db, parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter list [InteractionParameter]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n        \n        \n    @classmethod\n    def get_init_parameter(cls, db: Session, interaction_id: str) -> InteractionParameter:\n        \"\"\"\n        get init parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter InteractionParameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            parameters = InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n            init_parameter = parameters[0]\n            parameter = InteractionParameter.from_json({\"args\": init_parameter, \"interaction_id\": interaction_id, \"parameter_id\": None})\n            return parameter\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def search_interaction_by_user_id(cls,\n                                   db: Session,\n                                   user_id: str,\n                                   page_size: int = 10,\n                                   page_num: int = 1) -> list[dict]:\n        \"\"\"\n        get interaction by user id\n        Args:\n            db: db\n            user_id: user id\n            page_size: page size\n            page_num: page num\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        return InteractionDBInterface.search_interaction_by_user_id(db=db,\n                                                        user_id=user_id,\n                                                        page_size=page_size,\n                                                        page_num=page_num)\n\n    @classmethod\n    def is_exist(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        interaction is exist\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            True if interaction is exist, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            return InteractionDBInterface.is_exist(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n        Args:\n            db: db\n            base_data: base data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction(db=db, base_data=base_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n        Args:\n            db: db\n            interaction_id: interaction id\n            status: status\n            message: message\n            current_step: current step\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_status(\n                db=db,\n                interaction_id=interaction_id,\n                status=status,\n                message=message,\n                current_step=current_step)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_parameter(\n                db=db,\n                interaction_id=interaction_id,\n                parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        is running\n        Args:\n            db: db\n            user_id: user id\n        Returns:\n            True if running, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.is_running(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.delete_interaction(\n                db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get shared interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n            Returns:\n                interaction InteractionBase, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_shared_interaction(\n                db=db,\n                interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared\n        Args:\n            db: db\n            page_size: page size\n            page_index: page index\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_shared(db=db,\n                                                    page_size=page_size,\n                                                    page_index=page_index)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert raw\n        Args:\n            db: db\n            process: process\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.insert_raw(db=db, process=process)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def search_many_raws(cls, db: Session, interaction_id: str) -> List[XAgentRaw] | None:\n        \"\"\"\n        search many raws\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [XAgentRaw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return [XAgentRaw.from_db(raw) for raw in \n                    InteractionDBInterface.search_many_raws(db=db, interaction_id=interaction_id)]\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_raw(cls, db: Session, interaction_id: str, node_id: str) -> XAgentRaw | None:\n        \"\"\"\n        get raw\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        Returns:\n            raw XAgentRaw, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_raw(db=db,\n                                                  interaction_id=interaction_id,\n                                                  node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_next_send(cls, db: Session, interaction_id: str) -> List[Raw] | None:\n        \"\"\"\n        get next send\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [Raw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_next_send(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_send_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_receive_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_human_data(cls,\n                          db: Session,\n                          interaction_id: str,\n                          node_id: str,\n                          human_data: dict):\n        \"\"\"\n        update human data\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n            human_data: human data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_human_data(db=db,\n                                            interaction_id=interaction_id,\n                                            node_id=node_id,\n                                            human_data=human_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def insert_error(cls,\n                     db: Session,\n                     interaction_id: str,\n                     message: str,\n                     status: str = \"failed\"):\n        \"\"\"\n        insert error\n        Args:\n            db: db\n            interaction_id: interaction id\n            message: message\n            status: status, default is failed\n        Returns:\n            raw XAgentRaw\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            process = XAgentRaw(\n                node_id=uuid.uuid4().hex,\n                interaction_id=interaction_id,\n                current=\"\",\n                step=0,\n                data=message,\n                file_list=[],\n                status=status,\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                is_deleted=False,\n                is_human=False,\n                human_data={},\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                include_pictures=False,\n            )\n            InteractionDBInterface.insert_raw(db=db, process=process)\n            return process\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def add_share(cls, db: Session, share):\n        \"\"\"\n        add share\n        Args:\n            db: db\n            share: share\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_share(db=db, shared=share)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n        \n        \n    @classmethod\n    def get_finish_status(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        get finish status\n        \n        Args:\n            db: db\n            interaction_id: interaction id\n            \n        Returns:\n            True if finish, else False\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_finish_status(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 6
        },
        "search_many_interaction": {
            "type": "FunctionDef",
            "name": "search_many_interaction",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 30,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_many_interaction(cls, db: Session) -> list:\n        \"\"\"\n        search many interaction\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_interaction(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_interaction": {
            "type": "FunctionDef",
            "name": "get_interaction",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 48,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_interaction(cls, db: Session, interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            interaction InteractionBase\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_interaction(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "create_interaction": {
            "type": "FunctionDef",
            "name": "create_interaction",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 64,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def create_interaction(cls, db: Session, base: InteractionBase):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            base: base\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.create_interaction(db=db, base=base)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_ready_interaction": {
            "type": "FunctionDef",
            "name": "get_ready_interaction",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 80,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_ready_interaction(cls, db: Session, user_id: str):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            user_id: user_id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_ready_interaction(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "add_parameter": {
            "type": "FunctionDef",
            "name": "add_parameter",
            "md_content": "",
            "code_start_line": 84,
            "code_end_line": 97,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def add_parameter(cls, db: Session, parameter: InteractionParameter = None):\n        \"\"\"\n        add parameter\n        Args:\n            db: db\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_parameter(db=db, parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_parameter": {
            "type": "FunctionDef",
            "name": "get_parameter",
            "md_content": "",
            "code_start_line": 100,
            "code_end_line": 115,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter list [InteractionParameter]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_init_parameter": {
            "type": "FunctionDef",
            "name": "get_init_parameter",
            "md_content": "",
            "code_start_line": 119,
            "code_end_line": 137,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_init_parameter(cls, db: Session, interaction_id: str) -> InteractionParameter:\n        \"\"\"\n        get init parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter InteractionParameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            parameters = InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n            init_parameter = parameters[0]\n            parameter = InteractionParameter.from_json({\"args\": init_parameter, \"interaction_id\": interaction_id, \"parameter_id\": None})\n            return parameter\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "search_interaction_by_user_id": {
            "type": "FunctionDef",
            "name": "search_interaction_by_user_id",
            "md_content": "",
            "code_start_line": 140,
            "code_end_line": 161,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_interaction_by_user_id(cls,\n                                   db: Session,\n                                   user_id: str,\n                                   page_size: int = 10,\n                                   page_num: int = 1) -> list[dict]:\n        \"\"\"\n        get interaction by user id\n        Args:\n            db: db\n            user_id: user id\n            page_size: page size\n            page_num: page num\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        return InteractionDBInterface.search_interaction_by_user_id(db=db,\n                                                        user_id=user_id,\n                                                        page_size=page_size,\n                                                        page_num=page_num)\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 164,
            "code_end_line": 179,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def is_exist(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        interaction is exist\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            True if interaction is exist, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            return InteractionDBInterface.is_exist(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_interaction": {
            "type": "FunctionDef",
            "name": "update_interaction",
            "md_content": "",
            "code_start_line": 182,
            "code_end_line": 195,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n        Args:\n            db: db\n            base_data: base data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction(db=db, base_data=base_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_interaction_status": {
            "type": "FunctionDef",
            "name": "update_interaction_status",
            "md_content": "",
            "code_start_line": 198,
            "code_end_line": 224,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n        Args:\n            db: db\n            interaction_id: interaction id\n            status: status\n            message: message\n            current_step: current step\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_status(\n                db=db,\n                interaction_id=interaction_id,\n                status=status,\n                message=message,\n                current_step=current_step)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_interaction_parameter": {
            "type": "FunctionDef",
            "name": "update_interaction_parameter",
            "md_content": "",
            "code_start_line": 227,
            "code_end_line": 247,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_parameter(\n                db=db,\n                interaction_id=interaction_id,\n                parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "is_running": {
            "type": "FunctionDef",
            "name": "is_running",
            "md_content": "",
            "code_start_line": 250,
            "code_end_line": 265,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        is running\n        Args:\n            db: db\n            user_id: user id\n        Returns:\n            True if running, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.is_running(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "delete_interaction": {
            "type": "FunctionDef",
            "name": "delete_interaction",
            "md_content": "",
            "code_start_line": 268,
            "code_end_line": 282,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.delete_interaction(\n                db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_shared_interaction": {
            "type": "FunctionDef",
            "name": "get_shared_interaction",
            "md_content": "",
            "code_start_line": 285,
            "code_end_line": 304,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get shared interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n            Returns:\n                interaction InteractionBase, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_shared_interaction(\n                db=db,\n                interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "search_many_shared": {
            "type": "FunctionDef",
            "name": "search_many_shared",
            "md_content": "",
            "code_start_line": 307,
            "code_end_line": 328,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared\n        Args:\n            db: db\n            page_size: page size\n            page_index: page index\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_shared(db=db,\n                                                    page_size=page_size,\n                                                    page_index=page_index)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "insert_raw": {
            "type": "FunctionDef",
            "name": "insert_raw",
            "md_content": "",
            "code_start_line": 331,
            "code_end_line": 344,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert raw\n        Args:\n            db: db\n            process: process\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.insert_raw(db=db, process=process)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "search_many_raws": {
            "type": "FunctionDef",
            "name": "search_many_raws",
            "md_content": "",
            "code_start_line": 347,
            "code_end_line": 363,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_many_raws(cls, db: Session, interaction_id: str) -> List[XAgentRaw] | None:\n        \"\"\"\n        search many raws\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [XAgentRaw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return [XAgentRaw.from_db(raw) for raw in \n                    InteractionDBInterface.search_many_raws(db=db, interaction_id=interaction_id)]\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_raw": {
            "type": "FunctionDef",
            "name": "get_raw",
            "md_content": "",
            "code_start_line": 366,
            "code_end_line": 384,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_raw(cls, db: Session, interaction_id: str, node_id: str) -> XAgentRaw | None:\n        \"\"\"\n        get raw\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        Returns:\n            raw XAgentRaw, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_raw(db=db,\n                                                  interaction_id=interaction_id,\n                                                  node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_next_send": {
            "type": "FunctionDef",
            "name": "get_next_send",
            "md_content": "",
            "code_start_line": 387,
            "code_end_line": 402,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_next_send(cls, db: Session, interaction_id: str) -> List[Raw] | None:\n        \"\"\"\n        get next send\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [Raw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_next_send(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_send_flag": {
            "type": "FunctionDef",
            "name": "update_send_flag",
            "md_content": "",
            "code_start_line": 405,
            "code_end_line": 420,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_send_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_receive_flag": {
            "type": "FunctionDef",
            "name": "update_receive_flag",
            "md_content": "",
            "code_start_line": 423,
            "code_end_line": 438,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_receive_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_human_data": {
            "type": "FunctionDef",
            "name": "update_human_data",
            "md_content": "",
            "code_start_line": 441,
            "code_end_line": 463,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_human_data(cls,\n                          db: Session,\n                          interaction_id: str,\n                          node_id: str,\n                          human_data: dict):\n        \"\"\"\n        update human data\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n            human_data: human data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_human_data(db=db,\n                                            interaction_id=interaction_id,\n                                            node_id=node_id,\n                                            human_data=human_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "insert_error": {
            "type": "FunctionDef",
            "name": "insert_error",
            "md_content": "",
            "code_start_line": 466,
            "code_end_line": 509,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def insert_error(cls,\n                     db: Session,\n                     interaction_id: str,\n                     message: str,\n                     status: str = \"failed\"):\n        \"\"\"\n        insert error\n        Args:\n            db: db\n            interaction_id: interaction id\n            message: message\n            status: status, default is failed\n        Returns:\n            raw XAgentRaw\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            process = XAgentRaw(\n                node_id=uuid.uuid4().hex,\n                interaction_id=interaction_id,\n                current=\"\",\n                step=0,\n                data=message,\n                file_list=[],\n                status=status,\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                is_deleted=False,\n                is_human=False,\n                human_data={},\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                include_pictures=False,\n            )\n            InteractionDBInterface.insert_raw(db=db, process=process)\n            return process\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "add_share": {
            "type": "FunctionDef",
            "name": "add_share",
            "md_content": "",
            "code_start_line": 512,
            "code_end_line": 525,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def add_share(cls, db: Session, share):\n        \"\"\"\n        add share\n        Args:\n            db: db\n            share: share\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_share(db=db, shared=share)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_finish_status": {
            "type": "FunctionDef",
            "name": "get_finish_status",
            "md_content": "",
            "code_start_line": 529,
            "code_end_line": 543,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_finish_status(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        get finish status\n        \n        Args:\n            db: db\n            interaction_id: interaction id\n            \n        Returns:\n            True if finish, else False\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_finish_status(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        }
    },
    "XAgentServer/application/cruds/recorder.py": {
        "RunningRecordCRUD": {
            "type": "ClassDef",
            "name": "RunningRecordCRUD",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 91,
            "parent": null,
            "have_return": true,
            "code_content": "class RunningRecordCRUD(metaclass=abc.ABCMeta):\n    \"\"\"\n    Recorder CRUD\n    \"\"\"\n\n    @classmethod\n    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"\n        get all records\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_list(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None) -> XAgentRunningRecord | None:\n        \"\"\"\n        get record by record_id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n\n    @classmethod\n    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"\n        insert record\n        \n        Args:\n            db: database session\n            record: record\n        \n        \"\"\"\n        try:\n            RecordDBInterface.insert_record(db=db, record=record)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_record_by_type(cls,\n                         db: Session,\n                         record_id: str,\n                         node_id: str = \"\",\n                         node_type: str = \"\") -> List[XAgentRunningRecord]:\n        \"\"\"\n        get record by id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_by_type(db=db,\n                                                        record_id=record_id,\n                                                        node_id=node_id,\n                                                        node_type=node_type)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 6
        },
        "get_record_list": {
            "type": "FunctionDef",
            "name": "get_record_list",
            "md_content": "",
            "code_start_line": 18,
            "code_end_line": 29,
            "parent": "RunningRecordCRUD",
            "have_return": true,
            "code_content": "    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"\n        get all records\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_list(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_record": {
            "type": "FunctionDef",
            "name": "get_record",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 49,
            "parent": "RunningRecordCRUD",
            "have_return": true,
            "code_content": "    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None) -> XAgentRunningRecord | None:\n        \"\"\"\n        get record by record_id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "insert_record": {
            "type": "FunctionDef",
            "name": "insert_record",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 66,
            "parent": "RunningRecordCRUD",
            "have_return": false,
            "code_content": "    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"\n        insert record\n        \n        Args:\n            db: database session\n            record: record\n        \n        \"\"\"\n        try:\n            RecordDBInterface.insert_record(db=db, record=record)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_record_by_type": {
            "type": "FunctionDef",
            "name": "get_record_by_type",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 91,
            "parent": "RunningRecordCRUD",
            "have_return": true,
            "code_content": "    def get_record_by_type(cls,\n                         db: Session,\n                         record_id: str,\n                         node_id: str = \"\",\n                         node_type: str = \"\") -> List[XAgentRunningRecord]:\n        \"\"\"\n        get record by id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_by_type(db=db,\n                                                        record_id=record_id,\n                                                        node_id=node_id,\n                                                        node_type=node_type)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        }
    },
    "XAgent/config.py": {
        "XAgentConfig": {
            "type": "ClassDef",
            "name": "XAgentConfig",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 121,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentConfig(dict):\n    \"\"\"\n    A dictionary-like configuration class with attribute-style access.\n\n    Inherited from dictionary, this class provides methods for accessing and modifying\n    dictionary items using attributes and methods.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize class instance.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def __getattr__(self, key):\n        \"\"\"\n        Access the class attribute.\n\n        Args:\n            key (str): Key to access the class attribute.\n\n        Returns:\n            Value of the class attribute for the input key.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            return self[key]\n        raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n\n    def __setattr__(self, key, value):\n        \"\"\"\n        Set the value of the class attribute.\n\n        Args:\n            key (str): Key for the attribute to set.\n            value : Value to be set for the input key.\n        \"\"\"\n        self[key] = value\n\n    def __delattr__(self, key):\n        \"\"\"\n        Delete the class attribute.\n\n        Args:\n            key (str): Key of the attribute to delete.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            del self[key]\n        else:\n            raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n\n    def to_dict(self, safe=False):\n        \"\"\"\n        Convert the xAgentConfig object to dictionary.\n\n        Args:\n            safe (bool, optional): If True, 'api_keys' will be excluded from the output.\n                Default is False.\n\n        Returns:\n            dict: Dictionary representation of the instance.\n        \"\"\"\n        if safe:\n            right_value = deepcopy(self)\n            right_value.pop(\"api_keys\", \"\")\n            return right_value\n        else:\n            return self\n\n    def reload(self, config_file='assets/config.yml'):\n        \"\"\"\n        Load configuration data from YAML file and environment variables. And also update\n        the ARGS with new data.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n        \"\"\"\n        config_file = os.getenv('CONFIG_FILE', config_file)\n        print('---config file---\\n'+str(config_file))\n        self.__init__(\n            **yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader))\n        # check environment variables\n        self['selfhost_toolserver_url'] = os.getenv(\n            'TOOLSERVER_URL', self['selfhost_toolserver_url'])\n        print('---args---\\n'+str(ARGS))\n        self.update(ARGS)\n\n    @staticmethod\n    def get_default_config(config_file='assets/config.yml'):\n        \"\"\"\n        Get default configuration data from given file through environment variable.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n\n        Returns:\n            XAgentConfig: An instance of XAgentConfig with loaded configuration data.\n        \"\"\"\n        try:\n            config_file = os.getenv('CONFIG_FILE', config_file)\n            cfg = yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader)\n        except:\n            cfg = {}\n        return XAgentConfig(**cfg)\n",
            "name_column": 6
        },
        "get_model_name": {
            "type": "FunctionDef",
            "name": "get_model_name",
            "md_content": "",
            "code_start_line": 128,
            "code_end_line": 170,
            "parent": null,
            "have_return": true,
            "code_content": "def get_model_name(model_name: str = None):\n    \"\"\"\n    Get the normalized model name for a given input model name.\n\n    Args:\n        model_name (str, optional): Input model name. Default is None.\n\n    Returns:\n        str: Normalized model name.\n\n    Raises:\n        Exception: If the model name is not recognized.\n    \"\"\"\n    if model_name is None:\n        model_name = CONFIG.default_completion_kwargs['model']\n\n    normalized_model_name = ''\n    match model_name.lower():\n        case 'gpt-4':\n            normalized_model_name = 'gpt-4'\n        case 'gpt-4-32k':\n            normalized_model_name = 'gpt-4-32k'\n        case 'gpt-4-1106-preview':\n            normalized_model_name = 'gpt-4-1106-preview'\n        case 'gpt-4-turbo':\n            normalized_model_name = 'gpt-4-1106-preview'\n        case 'gpt-3.5-turbo-16k':\n            normalized_model_name = 'gpt-3.5-turbo-16k'\n        case 'gpt-3.5-turbo-1106':\n            normalized_model_name = 'gpt-3.5-turbo-1106'\n\n        case 'gpt4':\n            normalized_model_name = 'gpt-4'\n        case 'gpt4-32':\n            normalized_model_name = 'gpt-4-32k'\n        case 'gpt-35-16k':\n            normalized_model_name = 'gpt-3.5-turbo-16k'\n        case 'xagentllm':\n            normalized_model_name = 'xagentllm'\n        case _:\n            raise Exception(f\"Unknown model name {model_name}\")\n\n    return normalized_model_name\n",
            "name_column": 4
        },
        "get_apiconfig_by_model": {
            "type": "FunctionDef",
            "name": "get_apiconfig_by_model",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 190,
            "parent": null,
            "have_return": true,
            "code_content": "def get_apiconfig_by_model(model_name: str) -> dict:\n    \"\"\"\n    Get API configuration for a model by its name.\n\n    The function first normalizes the name, then fetches the API keys for this model\n    from the CONFIG and rotates the keys.\n\n    Args:\n        model_name (str): Name of the model.\n\n    Returns:\n        dict: Dictionary containing the fetched API configuration.\n    \"\"\"\n    normalized_model_name = get_model_name(model_name)\n    apiconfig = deepcopy(CONFIG.api_keys[normalized_model_name][0])\n    CONFIG.api_keys[normalized_model_name].append(\n        CONFIG.api_keys[normalized_model_name].pop(0))\n    return apiconfig\n",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 15,
            "code_end_line": 23,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize class instance.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n",
            "name_column": 8
        },
        "__getattr__": {
            "type": "FunctionDef",
            "name": "__getattr__",
            "md_content": "",
            "code_start_line": 25,
            "code_end_line": 40,
            "parent": "XAgentConfig",
            "have_return": true,
            "code_content": "    def __getattr__(self, key):\n        \"\"\"\n        Access the class attribute.\n\n        Args:\n            key (str): Key to access the class attribute.\n\n        Returns:\n            Value of the class attribute for the input key.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            return self[key]\n        raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n",
            "name_column": 8
        },
        "__setattr__": {
            "type": "FunctionDef",
            "name": "__setattr__",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 50,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def __setattr__(self, key, value):\n        \"\"\"\n        Set the value of the class attribute.\n\n        Args:\n            key (str): Key for the attribute to set.\n            value : Value to be set for the input key.\n        \"\"\"\n        self[key] = value\n",
            "name_column": 8
        },
        "__delattr__": {
            "type": "FunctionDef",
            "name": "__delattr__",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 65,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def __delattr__(self, key):\n        \"\"\"\n        Delete the class attribute.\n\n        Args:\n            key (str): Key of the attribute to delete.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            del self[key]\n        else:\n            raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 83,
            "parent": "XAgentConfig",
            "have_return": true,
            "code_content": "    def to_dict(self, safe=False):\n        \"\"\"\n        Convert the xAgentConfig object to dictionary.\n\n        Args:\n            safe (bool, optional): If True, 'api_keys' will be excluded from the output.\n                Default is False.\n\n        Returns:\n            dict: Dictionary representation of the instance.\n        \"\"\"\n        if safe:\n            right_value = deepcopy(self)\n            right_value.pop(\"api_keys\", \"\")\n            return right_value\n        else:\n            return self\n",
            "name_column": 8
        },
        "reload": {
            "type": "FunctionDef",
            "name": "reload",
            "md_content": "",
            "code_start_line": 85,
            "code_end_line": 102,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def reload(self, config_file='assets/config.yml'):\n        \"\"\"\n        Load configuration data from YAML file and environment variables. And also update\n        the ARGS with new data.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n        \"\"\"\n        config_file = os.getenv('CONFIG_FILE', config_file)\n        print('---config file---\\n'+str(config_file))\n        self.__init__(\n            **yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader))\n        # check environment variables\n        self['selfhost_toolserver_url'] = os.getenv(\n            'TOOLSERVER_URL', self['selfhost_toolserver_url'])\n        print('---args---\\n'+str(ARGS))\n        self.update(ARGS)\n",
            "name_column": 8
        },
        "get_default_config": {
            "type": "FunctionDef",
            "name": "get_default_config",
            "md_content": "",
            "code_start_line": 105,
            "code_end_line": 121,
            "parent": "XAgentConfig",
            "have_return": true,
            "code_content": "    def get_default_config(config_file='assets/config.yml'):\n        \"\"\"\n        Get default configuration data from given file through environment variable.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n\n        Returns:\n            XAgentConfig: An instance of XAgentConfig with loaded configuration data.\n        \"\"\"\n        try:\n            config_file = os.getenv('CONFIG_FILE', config_file)\n            cfg = yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader)\n        except:\n            cfg = {}\n        return XAgentConfig(**cfg)\n",
            "name_column": 8
        }
    },
    "XAgent/running_recorder.py": {
        "dump_common_things": {
            "type": "FunctionDef",
            "name": "dump_common_things",
            "md_content": "**dump_common_things**: strintfloatbool\n\nobject\n\n- strintfloatbool\n- dump_common_things\n- dump_common_things\n- to_json\n\n****: \n- strintfloatbool\n- to_json\n- None\n\n****:\n- : \"Hello World\"\n  : \"Hello World\"\n- : {\"name\": \"John\", \"age\": 30}\n  : {\"name\": \"John\", \"age\": 30}\n- : [1, 2, 3, 4, 5]\n  : [1, 2, 3, 4, 5]\n- : datetime.datetime(2022, 1, 1)\n  : None",
            "code_start_line": 14,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def dump_common_things(object):\n    \"\"\"\n    Serialize commonly used data types, like str, int, float, bool, dictionaries, and lists.\n\n    Args:\n        object (Any): The object to serialize.\n\n    Returns:\n        object: The cpickled object.\n    \"\"\"\n    if type(object) in [str, int, float, bool]:\n        return object\n    if type(object) == dict:\n        return {dump_common_things(key): dump_common_things(value) for key, value in object.items()}\n    if type(object) == list:\n        return [dump_common_things(cont) for cont in object]\n    method = getattr(object, 'to_json', None)\n    if callable(method):\n        return method()\n",
            "name_column": 4
        },
        "RunningRecoder": {
            "type": "ClassDef",
            "name": "RunningRecoder",
            "md_content": "**RunningRecoder**\n\n\n- `__init__(self, record_root_dir=\"./running_records/\")`RunningRecorder`record_root_dir`\"LLM_inout_pair\"\"tool_server_pair\"LLM\n\n- `get_query_id(self)`ID1\n\n- `decrease_query_id(self)`ID1\n\n- `change_now_task(self, new_subtask_id)``new_subtask_id`IDIDIDIDID0\n\n- `regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after)``refine_function_name``refine_function_input``refine_function_output``plan_after`JSON\n\n- `regist_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, output_data=None, **other_args)`LLM`llm_query_id`LLMID`messages``functions``function_call``model``stop``output_data``other_args`LLMJSON\"LLM_inout_pair\"LLM\n\n- `query_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, **other_args)`LLM`llm_query_id`LLMID`messages``functions``function_call``model``stop``other_args`LLM\n\n- `regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None)``tool_name``tool_input``tool_output``tool_status_code``thought_data`JSON\n\n- `regist_tool_server(self, url, payload, tool_output, response_status_code)``url`URL`payload``tool_output``response_status_code`JSON\"tool_server_pair\"\n\n- `query_tool_server_cache(self, url, payload)``url`URL`payload`\n\n- `regist_query(self, query)``query`JSON\"query.json\"\n\n- `get_query(self)`\"query.json\"\n\n- `regist_config(self, config: XAgentConfig)``config`YAML\"config.yml\"\n\n- `get_config(self)`\"config.yml\"\n\n- `regist_father_info(self, record_dir)``record_dir`YAML\"This-Is-A-Reload-Run.yml\"\n\n- `load_from_disk(self, record_dir)``record_dir`\n\n****RunningRecoder\n- \"./running_records/\"\n- LLMJSON\n- LLM\n- JSONYAML\n- \n\n****\n```python\nrunning_recorder = RunningRecoder()\nrunning_recorder.regist_llm_inout(1, \"Hello\", output_data=\"World\")\nrunning_recorder.query_llm_inout(1, \"Hello\")  #  \"World\"\n```",
            "code_start_line": 34,
            "code_end_line": 395,
            "parent": null,
            "have_return": true,
            "code_content": "class RunningRecoder():\n    \"\"\"\n    A class used to record the running sequences of the program, also including program query status and config data.\n\n    Attributes:\n        record_root_dir (str): The root directory of the running records.\n        newly_start (bool): A flag to indicate whether or not a new task has started.\n        toolserver_interface_id (int): The id of the tool server interface.\n        tool_call_id (int): The id of the tool call.\n        plan_refine_id (int): The id of the plan refinement.\n        llm_server_cache (dict): The cache for the llm server.\n        tool_server_cache (dict): The cache for the tool server.\n        tool_call_cache (dict): The cache for the tool call.\n        plan_refine_cache (dict): The cache for the plan refinement.\n        query_count (int): The count of the queries.\n    \"\"\"\n    def __init__(self, record_root_dir=\"./running_records/\"):\n        \"\"\"\n        Initialize the RunningRecorder.\n\n        Args:\n            record_root_dir (str): The root directory of the running records.\n        \"\"\"\n        now = int(round(time.time() * 1000))\n        strip = time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime(now / 1000)) + uuid.uuid4().hex[:8]\n\n        self.record_root_dir = os.path.join(record_root_dir, strip)\n        os.makedirs(self.record_root_dir, exist_ok=True)\n\n        for subdir_name in [\"LLM_inout_pair\", \"tool_server_pair\"]:\n            os.makedirs(os.path.join(self.record_root_dir, subdir_name), exist_ok=True)\n\n        self.newly_start = True  \n\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.query_count = 0\n\n    def get_query_id(self):\n        \"\"\"\n        Get the query id.\n\n        Returns:\n            int: The id of the query.\n        \"\"\"\n        query_id = deepcopy(self.query_count)\n        self.query_count += 1\n        return query_id\n\n    def decrease_query_id(self):\n        \"\"\"\n        Decrease the query id.\n        \"\"\"\n        self.query_count -= 1\n    \n    def change_now_task(self, new_subtask_id):\n        \"\"\"\n        Change the current subtask.\n\n        Args:\n            new_subtask_id (int): The id of the new subtask.\n        \"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n    def regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after):\n        \"\"\"\n        Register plan modification.\n\n        Args:\n            refine_function_name (str): The name of the refine function.\n            refine_function_input (Any): The input of the refine function.\n            refine_function_output (Any): The output of the refine function.\n            plan_after (str): The plan after modification.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(\n                os.path.join(self.record_root_dir, self.now_subtask_id, f\"plan_refine_{self.plan_refine_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            plan_refine_record = {\n                \"refine_function_name\": dump_common_things(refine_function_name),\n                \"refine_function_input\": dump_common_things(refine_function_input),\n                \"refine_function_output\": dump_common_things(refine_function_output),\n                \"plan_after\": dump_common_things(plan_after),\n            }\n            json.dump(plan_refine_record, writer, indent=2, ensure_ascii=False)\n\n        self.plan_refine_id += 1\n    def regist_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, output_data=None,**other_args):\n        \"\"\"\n        Register llm input output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            output_data (Any, optional): The output data.\n            other_args (dict, optional): Other arguments.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"LLM_inout_pair\", f\"{llm_query_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            llm_inout_record = {\n                \"input\": {\n                    \"messages\": dump_common_things(messages),\n                    \"functions\": dump_common_things(functions),\n                    \"function_call\": dump_common_things(function_call),\n                    \"model\": dump_common_things(model),\n                    \"stop\": dump_common_things(stop),\n                    \"other_args\": dump_common_things(other_args),\n                },\n                \"output\": dump_common_things(output_data),\n                \"llm_interface_id\": llm_query_id,\n            }\n            json.dump(llm_inout_record, writer, indent=2, ensure_ascii=False)\n            self.llm_server_cache.append(llm_inout_record)\n            logger.typewriter_log(\"LLM inout registed:\",Fore.RED, f\"query-id={llm_query_id}\",level=logging.DEBUG)\n\n    def query_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, **other_args):\n        \"\"\"\n        Query llm input and output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            other_args (dict, optional): Other arguments.\n\n        Returns:\n            Any: The output data.\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        if llm_query_id >= len(self.llm_server_cache):\n            logger.typewriter_log(\"Reach the max length of record\")\n            return None\n        cache = self.llm_server_cache[llm_query_id]\n        if input_data == cache[\"input\"]:\n            logger.typewriter_log(\n                \"get a llm_server response from Record\",\n                Fore.BLUE,\n                f\"query-id={llm_query_id}\"\n            )\n            return cache[\"output\"]\n        \n        return None\n\n    def regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None):\n        \"\"\"\n        Register tool call.\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (Any): The input for the tool.\n            tool_output (Any): The output from the tool.\n            tool_status_code (int): The status code of the tool.\n            thought_data (Any, optional): The thought data.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(os.path.join(self.record_root_dir, self.now_subtask_id, f\"tool_{self.tool_call_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"tool_name\": dump_common_things(tool_name),\n                \"tool_input\": dump_common_things(tool_input),\n                \"tool_output\": dump_common_things(tool_output),\n                \"tool_status_code\": dump_common_things(tool_status_code),\n            }\n            if thought_data:\n                tool_record[\"thought\"] = dump_common_things(thought_data)\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.tool_call_id += 1\n\n    def regist_tool_server(self, url, payload, tool_output,  response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"tool_server_pair\", f\"{self.toolserver_interface_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"url\": dump_common_things(url.split(\"/\")[-1]),\n                \"payload\": dump_common_things(payload),\n                \"response_status_code\": dump_common_things(response_status_code),\n                \"tool_output\": dump_common_things(tool_output),\n            }\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.toolserver_interface_id += 1\n\n    def query_tool_server_cache(self, url, payload):\n        \"\"\"\n        Query the tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload to send.\n\n        Returns:\n            dict: The output from the tool server and the response status code.\n        \"\"\"\n        if self.newly_start:\n            return None\n        if self.toolserver_interface_id >= len(self.tool_server_cache):\n            return None\n\n        cache = self.tool_server_cache[self.toolserver_interface_id]\n\n        if cache[\"url\"] == url.split(\"/\")[-1] and cache[\"payload\"] == dump_common_things(payload):\n            logger.typewriter_log(\n                \"get a tool_server response from Record\",\n                Fore.BLUE,\n                cache[\"url\"],\n            )\n            return {\n                \"tool_output\": cache[\"tool_output\"], \n                \"response_status_code\": cache[\"response_status_code\"]\n            }\n\n        return None\n\n\n    def regist_query(self, query):\n        \"\"\"\n        Register a query.\n\n        Args:\n            query (AutoGPTQuery): The query to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"query.json\"), \"w\",encoding=\"utf-8\",) as writer:\n            json.dump(query.to_json(), writer, indent=2, ensure_ascii=False)\n\n    def get_query(self):\n        \"\"\"\n        Get the registered query.\n\n        Returns:\n            AutoGPTQuery: The registered query.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a query from Record\",\n            Fore.BLUE,\n        )\n        return self.query\n\n    def regist_config(self, config: XAgentConfig):\n        \"\"\"\n        Register a configuration.\n\n        Args:\n            config (XAgentConfig): The configuration to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"config.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump(dict(config.to_dict(safe=True)), allow_unicode=True))\n\n\n    def get_config(self):\n        \"\"\"\n        Get the registered configuration.\n\n        Returns:\n            XAgentConfig: The registered configuration.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a config from Record\",\n            Fore.BLUE,\n        )\n        return self.config\n\n    def regist_father_info(self, record_dir):\n        \"\"\"\n        Register father info.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"This-Is-A-Reload-Run.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump({\n                \"load_record_dir\": record_dir,\n            }, allow_unicode=True))\n\n    def load_from_disk(self, record_dir):\n        \"\"\"\n        Load from a record in disk.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        logger.typewriter_log(\n            \"load from a disk record, overwrite all the existing config-info\",\n            Fore.BLUE,\n            record_dir,\n        )\n        self.regist_father_info(record_dir)\n        self.newly_start = False\n\n        for dir_name in os.listdir(record_dir):\n            if dir_name == \"query.json\":\n                with open(os.path.join(record_dir, dir_name), \"r\",encoding=\"utf-8\") as reader:\n                    self.query_json = json.load(reader)\n                    self.query = AutoGPTQuery.from_json(self.query_json)\n            elif dir_name == \"config.yml\":\n                CONFIG.reload(os.path.join(record_dir, dir_name))\n            elif dir_name == \"LLM_inout_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.llm_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        llm_pair = json.load(reader)\n                        self.llm_server_cache[inout_id] = llm_pair\n                logger.typewriter_log(\n                    f\"Record contain {inout_count} LLM inout\",\n                    Fore.BLUE,\n                )\n            elif dir_name == \"tool_server_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.tool_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        tool_pair = json.load(reader)\n                        self.tool_server_cache[inout_id] = tool_pair\n                logger.typewriter_log(\n                    f\"Record contain {len(os.listdir(os.path.join(record_dir, dir_name)))} Tool call\",\n                    Fore.BLUE,\n                )\n            elif os.path.isdir(os.path.join(record_dir, dir_name)):\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    if file_name.startswith(\"plan_refine\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            plan_refine = json.load(reader)\n                            self.plan_refine_cache.append(plan_refine)\n                    elif file_name.startswith(\"tool\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            tool_call = json.load(reader)\n                            self.tool_call_cache.append(tool_call)\n                    else:\n                        raise NotImplementedError\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**RunningRecorder\n\nrecord_root_dir\"./running_records/\"nowtime\"%Y_%m_%d_%H_%M_%S\"8strip\n\nrecord_root_dirstripos.makedirs\n\nos.makedirs\"LLM_inout_pair\"\"tool_server_pair\"LLM\n\nself.newly_startTrueRecorder\n\nself.toolserver_interface_idself.tool_call_idself.plan_refine_id0ID\n\nself.llm_server_cacheself.tool_server_cacheself.tool_call_cacheself.plan_refine_cacheLLM\n\nself.query_count0\n\n****\n- record_root_dir\"./running_records/\"\n- \n- \"LLM_inout_pair\"\"tool_server_pair\"LLM\n- ",
            "code_start_line": 50,
            "code_end_line": 78,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def __init__(self, record_root_dir=\"./running_records/\"):\n        \"\"\"\n        Initialize the RunningRecorder.\n\n        Args:\n            record_root_dir (str): The root directory of the running records.\n        \"\"\"\n        now = int(round(time.time() * 1000))\n        strip = time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime(now / 1000)) + uuid.uuid4().hex[:8]\n\n        self.record_root_dir = os.path.join(record_root_dir, strip)\n        os.makedirs(self.record_root_dir, exist_ok=True)\n\n        for subdir_name in [\"LLM_inout_pair\", \"tool_server_pair\"]:\n            os.makedirs(os.path.join(self.record_root_dir, subdir_name), exist_ok=True)\n\n        self.newly_start = True  \n\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.query_count = 0\n",
            "name_column": 8
        },
        "get_query_id": {
            "type": "FunctionDef",
            "name": "get_query_id",
            "md_content": "**get_query_id**id\n\nquery_id1query_idid\n\n\n\n****\n\n****0get_query_id1",
            "code_start_line": 80,
            "code_end_line": 89,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_query_id(self):\n        \"\"\"\n        Get the query id.\n\n        Returns:\n            int: The id of the query.\n        \"\"\"\n        query_id = deepcopy(self.query_count)\n        self.query_count += 1\n        return query_id\n",
            "name_column": 8
        },
        "decrease_query_id": {
            "type": "FunctionDef",
            "name": "decrease_query_id",
            "md_content": "**decrease_query_id**ID\n\nID1\n\n****\n- ToolServerManager\n- 1",
            "code_start_line": 91,
            "code_end_line": 95,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def decrease_query_id(self):\n        \"\"\"\n        Decrease the query id.\n        \"\"\"\n        self.query_count -= 1\n",
            "name_column": 8
        },
        "change_now_task": {
            "type": "FunctionDef",
            "name": "change_now_task",
            "md_content": "**change_now_task**: \n\nnew_subtask_idididnow_subtask_idnew_subtask_ididtool_call_id0idplan_refine_id0\n\n****: \n- new_subtask_id\n- ididid0",
            "code_start_line": 97,
            "code_end_line": 106,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def change_now_task(self, new_subtask_id):\n        \"\"\"\n        Change the current subtask.\n\n        Args:\n            new_subtask_id (int): The id of the new subtask.\n        \"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n",
            "name_column": 8
        },
        "regist_plan_modify": {
            "type": "FunctionDef",
            "name": "regist_plan_modify",
            "md_content": "**regist_plan_modify**\n\nrefine_function_namerefine_function_inputrefine_function_outputplan_after\n\n`open`JSON`json.dump`\n\n`os.makedirs``json.dump`JSON`indent`2JSON\n\n****`self.record_root_dir``self.now_subtask_id`UTF-8",
            "code_start_line": 108,
            "code_end_line": 129,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after):\n        \"\"\"\n        Register plan modification.\n\n        Args:\n            refine_function_name (str): The name of the refine function.\n            refine_function_input (Any): The input of the refine function.\n            refine_function_output (Any): The output of the refine function.\n            plan_after (str): The plan after modification.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(\n                os.path.join(self.record_root_dir, self.now_subtask_id, f\"plan_refine_{self.plan_refine_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            plan_refine_record = {\n                \"refine_function_name\": dump_common_things(refine_function_name),\n                \"refine_function_input\": dump_common_things(refine_function_input),\n                \"refine_function_output\": dump_common_things(refine_function_output),\n                \"plan_after\": dump_common_things(plan_after),\n            }\n            json.dump(plan_refine_record, writer, indent=2, ensure_ascii=False)\n\n        self.plan_refine_id += 1\n",
            "name_column": 8
        },
        "regist_llm_inout": {
            "type": "FunctionDef",
            "name": "regist_llm_inout",
            "md_content": "**regist_llm_inout**llm\n\nllm\n- llm_query_idintllmid\n- messagesAny\n- functionslist\n- function_callAny\n- modelAny\n- stopbool\n- output_dataAny\n- other_argsdict\n\nllmJSONllm_server_cachelogger.typewriter_log\n\nXAgent/ai_functions/request/obj_generator.pychatcompletionregist_llm_inoutllm_query_idregist_llm_inoutregist_llm_inoutllm_query_idcopyed_kwargsresponseregist_llm_inout\n\n****regist_llm_inoutllm_query_id",
            "code_start_line": 130,
            "code_end_line": 159,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, output_data=None,**other_args):\n        \"\"\"\n        Register llm input output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            output_data (Any, optional): The output data.\n            other_args (dict, optional): Other arguments.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"LLM_inout_pair\", f\"{llm_query_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            llm_inout_record = {\n                \"input\": {\n                    \"messages\": dump_common_things(messages),\n                    \"functions\": dump_common_things(functions),\n                    \"function_call\": dump_common_things(function_call),\n                    \"model\": dump_common_things(model),\n                    \"stop\": dump_common_things(stop),\n                    \"other_args\": dump_common_things(other_args),\n                },\n                \"output\": dump_common_things(output_data),\n                \"llm_interface_id\": llm_query_id,\n            }\n            json.dump(llm_inout_record, writer, indent=2, ensure_ascii=False)\n            self.llm_server_cache.append(llm_inout_record)\n            logger.typewriter_log(\"LLM inout registed:\",Fore.RED, f\"query-id={llm_query_id}\",level=logging.DEBUG)\n",
            "name_column": 8
        },
        "query_llm_inout": {
            "type": "FunctionDef",
            "name": "query_llm_inout",
            "md_content": "**query_llm_inout**llm\n\n\n- llm_query_idintllmid\n- messagesAny\n- functionslist\n- function_callAny\n- modelAny\n- stopbool\n- other_argsdict\n\n\n\nNoneinput_datallm_query_idllm_server_cacheNonellm_query_idcacheinput_datacache[\"input\"]cache[\"output\"]None\n\n\nXAgent/ai_functions/request/obj_generator.py\n\n```python\ndef chatcompletion(self, *, schema_validation=True, **kwargs):\n    \"\"\"\n    \n\n    \n        kwargs\n\n    \n        AI\n\n    \n        Exception\n        NotImplementedError\n    \"\"\"\n    \n    request_type = kwargs.pop('request_type', CONFIG.default_request_type)\n    for k in list(kwargs.keys()):\n        if kwargs[k] is None:\n            kwargs.pop(k)\n    \n    llm_query_id = recorder.get_query_id()\n    try:   \n        copyed_kwargs = deepcopy(kwargs)\n        if (response := recorder.query_llm_inout(llm_query_id=llm_query_id, **copyed_kwargs)) is None:\n            response = self._get_chatcompletion_request_func(request_type)(**kwargs)\n        recorder.regist_llm_inout(llm_query_id=llm_query_id, **copyed_kwargs, output_data=response)\n    except Exception as e:\n        traceback.print_exc()\n        logger.typewriter_log(f\"chatcompletion error: {e}\", Fore.RED)\n        recorder.decrease_query_id()\n        raise e\n\n    if schema_validation:\n        # refine the response\n        match request_type:\n            case 'openai':                \n                response = self.function_call_refine(kwargs, response)\n            case 'xagent':\n                pass\n            case _:\n                raise NotImplementedError(f\"Request type {request_type} not implemented\")\n    \n    return response\n```\n\n****\n\n****",
            "code_start_line": 161,
            "code_end_line": 199,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, **other_args):\n        \"\"\"\n        Query llm input and output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            other_args (dict, optional): Other arguments.\n\n        Returns:\n            Any: The output data.\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        if llm_query_id >= len(self.llm_server_cache):\n            logger.typewriter_log(\"Reach the max length of record\")\n            return None\n        cache = self.llm_server_cache[llm_query_id]\n        if input_data == cache[\"input\"]:\n            logger.typewriter_log(\n                \"get a llm_server response from Record\",\n                Fore.BLUE,\n                f\"query-id={llm_query_id}\"\n            )\n            return cache[\"output\"]\n        \n        return None\n",
            "name_column": 8
        },
        "regist_tool_call": {
            "type": "FunctionDef",
            "name": "regist_tool_call",
            "md_content": "**regist_tool_call**\n\n\n\n- tool_name (str)\n- tool_input (Any)\n- tool_output (Any)\n- tool_status_code (int)\n- thought_data (Any, )\n\nJSON\n\n1. `os.makedirs``self.record_root_dir``self.now_subtask_id`\n2. `open``self.record_root_dir``self.now_subtask_id``tool_{self.tool_call_id:05d}.json`UTF-8\n3. `tool_record``dump_common_things`\n4. `tool_record``dump_common_things`\n5. `json.dump``tool_record`2ASCII\n6. `self.tool_call_id`ID\n\n****`self.record_root_dir``self.now_subtask_id``dump_common_things`",
            "code_start_line": 201,
            "code_end_line": 224,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None):\n        \"\"\"\n        Register tool call.\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (Any): The input for the tool.\n            tool_output (Any): The output from the tool.\n            tool_status_code (int): The status code of the tool.\n            thought_data (Any, optional): The thought data.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(os.path.join(self.record_root_dir, self.now_subtask_id, f\"tool_{self.tool_call_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"tool_name\": dump_common_things(tool_name),\n                \"tool_input\": dump_common_things(tool_input),\n                \"tool_output\": dump_common_things(tool_output),\n                \"tool_status_code\": dump_common_things(tool_status_code),\n            }\n            if thought_data:\n                tool_record[\"thought\"] = dump_common_things(thought_data)\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.tool_call_id += 1\n",
            "name_column": 8
        },
        "regist_tool_server": {
            "type": "FunctionDef",
            "name": "regist_tool_server",
            "md_content": "**regist_tool_server**\n\nurlURLpayloadtool_outputresponse_status_codeJSON\n\n`open``self.record_root_dir``tool_server_pair``self.toolserver_interface_id:05d``tool_record``json.dump``tool_record`2\n\n`self.toolserver_interface_id`1\n\n****`self.record_root_dir``self.toolserver_interface_id`UTF-8",
            "code_start_line": 226,
            "code_end_line": 245,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_server(self, url, payload, tool_output,  response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"tool_server_pair\", f\"{self.toolserver_interface_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"url\": dump_common_things(url.split(\"/\")[-1]),\n                \"payload\": dump_common_things(payload),\n                \"response_status_code\": dump_common_things(response_status_code),\n                \"tool_output\": dump_common_things(tool_output),\n            }\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.toolserver_interface_id += 1\n",
            "name_column": 8
        },
        "query_tool_server_cache": {
            "type": "FunctionDef",
            "name": "query_tool_server_cache",
            "md_content": "**query_tool_server_cache**\n\nurlpayloadurlURLpayload\n\nNonetoolserver_interface_idNone\n\ntool_server_cachetoolserver_interface_id\n\nurlpayload\n\nNone\n\n****\n- urlpayload\n- \n\n****\n\n{\n    \"tool_output\": \"\",\n    \"response_status_code\": \"\"\n}",
            "code_start_line": 247,
            "code_end_line": 276,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_tool_server_cache(self, url, payload):\n        \"\"\"\n        Query the tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload to send.\n\n        Returns:\n            dict: The output from the tool server and the response status code.\n        \"\"\"\n        if self.newly_start:\n            return None\n        if self.toolserver_interface_id >= len(self.tool_server_cache):\n            return None\n\n        cache = self.tool_server_cache[self.toolserver_interface_id]\n\n        if cache[\"url\"] == url.split(\"/\")[-1] and cache[\"payload\"] == dump_common_things(payload):\n            logger.typewriter_log(\n                \"get a tool_server response from Record\",\n                Fore.BLUE,\n                cache[\"url\"],\n            )\n            return {\n                \"tool_output\": cache[\"tool_output\"], \n                \"response_status_code\": cache[\"response_status_code\"]\n            }\n\n        return None\n",
            "name_column": 8
        },
        "regist_query": {
            "type": "FunctionDef",
            "name": "regist_query",
            "md_content": "**regist_query**\n\nqueryAutoGPTQuery\n\n\"query.json\"queryJSONUTF-82ASCII\n\n****\n- self.record_root_dir\n- queryAutoGPTQuery",
            "code_start_line": 279,
            "code_end_line": 287,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_query(self, query):\n        \"\"\"\n        Register a query.\n\n        Args:\n            query (AutoGPTQuery): The query to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"query.json\"), \"w\",encoding=\"utf-8\",) as writer:\n            json.dump(query.to_json(), writer, indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "get_query": {
            "type": "FunctionDef",
            "name": "get_query",
            "md_content": "**get_query**\n\nlogger.typewriter_log\n\n****\n\n****",
            "code_start_line": 289,
            "code_end_line": 300,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_query(self):\n        \"\"\"\n        Get the registered query.\n\n        Returns:\n            AutoGPTQuery: The registered query.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a query from Record\",\n            Fore.BLUE,\n        )\n        return self.query\n",
            "name_column": 8
        },
        "regist_config": {
            "type": "FunctionDef",
            "name": "regist_config",
            "md_content": "**regist_config**\n\nconfigXAgentConfig\n\nconfig.ymlconfigyaml.safe_dumpyamlallow_unicode=True\n\n****\n- record_root_dir\n- XAgentConfigto_dict",
            "code_start_line": 302,
            "code_end_line": 310,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_config(self, config: XAgentConfig):\n        \"\"\"\n        Register a configuration.\n\n        Args:\n            config (XAgentConfig): The configuration to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"config.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump(dict(config.to_dict(safe=True)), allow_unicode=True))\n",
            "name_column": 8
        },
        "get_config": {
            "type": "FunctionDef",
            "name": "get_config",
            "md_content": "**get_config**\n\nXAgentConfiglogger.typewriter_log\"load a config from Record\"self.config\n\n****XAgentConfig\n\n****XAgentConfig",
            "code_start_line": 313,
            "code_end_line": 324,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_config(self):\n        \"\"\"\n        Get the registered configuration.\n\n        Returns:\n            XAgentConfig: The registered configuration.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a config from Record\",\n            Fore.BLUE,\n        )\n        return self.config\n",
            "name_column": 8
        },
        "regist_father_info": {
            "type": "FunctionDef",
            "name": "regist_father_info",
            "md_content": "**regist_father_info**: \n\nrecord_dir\n\nopen\"This-Is-A-Reload-Run.yml\"yaml.safe_dumprecord_dir\"load_record_dir\"record_dir\n\n****: record_dir",
            "code_start_line": 326,
            "code_end_line": 336,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_father_info(self, record_dir):\n        \"\"\"\n        Register father info.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"This-Is-A-Reload-Run.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump({\n                \"load_record_dir\": record_dir,\n            }, allow_unicode=True))\n",
            "name_column": 8
        },
        "load_from_disk": {
            "type": "FunctionDef",
            "name": "load_from_disk",
            "md_content": "**load_from_disk**\n\nrecord_dir\n\nlogger.typewriter_log\"load from a disk record, overwrite all the existing config-info\"record_dir\n\nself.regist_father_inforecord_dir\n\nself.newly_startFalse\n\nrecord_dir\n\n\"query.json\"json.loadself.query_jsonAutoGPTQuery.from_jsonself.query_jsonAutoGPTQueryself.query\n\n\"config.yml\"CONFIG.reload\n\n\"LLM_inout_pair\"inout_idjson.loadllm_pairllm_pairself.llm_server_cache\n\n\"tool_server_pair\"inout_idjson.loadtool_pairtool_pairself.tool_server_cache\n\n\"plan_refine\"json.loadplan_refineself.plan_refine_cache\"tool\"json.loadtool_callself.tool_call_cacheNotImplementedError\n\n****\n- \n- \n- ",
            "code_start_line": 338,
            "code_end_line": 395,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def load_from_disk(self, record_dir):\n        \"\"\"\n        Load from a record in disk.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        logger.typewriter_log(\n            \"load from a disk record, overwrite all the existing config-info\",\n            Fore.BLUE,\n            record_dir,\n        )\n        self.regist_father_info(record_dir)\n        self.newly_start = False\n\n        for dir_name in os.listdir(record_dir):\n            if dir_name == \"query.json\":\n                with open(os.path.join(record_dir, dir_name), \"r\",encoding=\"utf-8\") as reader:\n                    self.query_json = json.load(reader)\n                    self.query = AutoGPTQuery.from_json(self.query_json)\n            elif dir_name == \"config.yml\":\n                CONFIG.reload(os.path.join(record_dir, dir_name))\n            elif dir_name == \"LLM_inout_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.llm_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        llm_pair = json.load(reader)\n                        self.llm_server_cache[inout_id] = llm_pair\n                logger.typewriter_log(\n                    f\"Record contain {inout_count} LLM inout\",\n                    Fore.BLUE,\n                )\n            elif dir_name == \"tool_server_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.tool_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        tool_pair = json.load(reader)\n                        self.tool_server_cache[inout_id] = tool_pair\n                logger.typewriter_log(\n                    f\"Record contain {len(os.listdir(os.path.join(record_dir, dir_name)))} Tool call\",\n                    Fore.BLUE,\n                )\n            elif os.path.isdir(os.path.join(record_dir, dir_name)):\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    if file_name.startswith(\"plan_refine\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            plan_refine = json.load(reader)\n                            self.plan_refine_cache.append(plan_refine)\n                    elif file_name.startswith(\"tool\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            tool_call = json.load(reader)\n                            self.tool_call_cache.append(tool_call)\n                    else:\n                        raise NotImplementedError\n",
            "name_column": 8
        }
    },
    "XAgent/recorder.py": {
        "dump_common_things": {
            "type": "FunctionDef",
            "name": "dump_common_things",
            "md_content": "**dump_common_things**: \n\n\n\n\"to_json\"\n\n\n\n****: \n- \n- \n\n****:\n- 1:\n  ```\n  object = \"Hello World\"\n  result = dump_common_things(object)\n  print(result)\n  : \"Hello World\"\n  ```\n\n- 2:\n  ```\n  object = {\"name\": \"John\", \"age\": 30}\n  result = dump_common_things(object)\n  print(result)\n  : {\"name\": \"John\", \"age\": 30}\n  ```\n\n- 3:\n  ```\n  object = [1, 2, 3, {\"name\": \"John\"}]\n  result = dump_common_things(object)\n  print(result)\n  : [1, 2, 3, {\"name\": \"John\"}]\n  ```\n\n- 4:\n  ```\n  class Person:\n      def __init__(self, name):\n          self.name = name\n      def to_json(self):\n          return {\"name\": self.name}\n  \n  object = Person(\"John\")\n  result = dump_common_things(object)\n  print(result)\n  : {\"name\": \"John\"}\n  ```\n\ndump_common_things",
            "code_start_line": 19,
            "code_end_line": 29,
            "parent": null,
            "have_return": true,
            "code_content": "def dump_common_things(object):\n    \"\"\"common\"\"\"\n    if type(object) in [str, int, float, bool]:\n        return object\n    if isinstance(object, dict):\n        return {dump_common_things(key): dump_common_things(value) for key, value in object.items()}\n    if isinstance(object, list):\n        return [dump_common_things(cont) for cont in object]\n    method = getattr(object, 'to_json', None)\n    if callable(method):\n        return method()\n",
            "name_column": 4
        },
        "get_db": {
            "type": "FunctionDef",
            "name": "get_db",
            "md_content": "**get_db**\n\ncontext managersession\n\n1. session\n2. yieldsessionyieldyield\n3. tryyieldsession\n4. tryexceptsession\n5. tryfinallysession\n\n****get_dbwithsessionsession",
            "code_start_line": 33,
            "code_end_line": 45,
            "parent": null,
            "have_return": false,
            "code_content": "def get_db():\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n",
            "name_column": 4
        },
        "RunningRecoder": {
            "type": "ClassDef",
            "name": "RunningRecoder",
            "md_content": "**RunningRecoder**\n\n\n\n- `__init__(self, record_id: str, newly_start=True, root_dir=None, logger: Logger=None)`RunningRecoder`record_id``newly_start``root_dir``logger`\n\n- `change_now_task(self, new_subtask_id)``new_subtask_id`ID\n\n- `generate_record(self, current, node_id, node_type, data)``current`ID`node_id`ID`node_type``data`\n\n- `regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after)`plan_refine`refine_function_name`refine`refine_function_input`refine`refine_function_output`refine`plan_after`refine\n\n- `regist_llm_inout(self, messages, functions, function_call, model, stop, other_args, output_data)`llm_inout`messages``functions``function_call``model``stop``other_args``output_data`\n\n- `query_llm_inout(self, restrict_cache_query, messages, functions, function_call, model, stop, other_args)`llm_inout`restrict_cache_query`llm_interface_id`messages``functions``function_call``model``stop``other_args`\n\n- `regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None)`tool_call`tool_name``tool_input``tool_output``tool_status_code``thought_data`\n\n- `regist_tool_server(self, url, payload, tool_output, response_status_code)`tool_server`url`URL`payload`payload`tool_output``response_status_code`\n\n- `query_tool_server_cache(self, url, payload)`tool_server`url`URL`payload`payload\n\n- `regist_query(self, query)``query`\n\n- `get_query(self)`\n\n- `regist_config(self, config: XAgentConfig)``config`\n\n- `get_config(self)`\n\n- `load_from_db(self, record_id)``record_id`ID\n\n****\n\n****\n```\nRunningRecoder\n```",
            "code_start_line": 48,
            "code_end_line": 346,
            "parent": null,
            "have_return": true,
            "code_content": "class RunningRecoder():\n    \"\"\"A class used to record the running sequences of the program, also including program query status and config data.\n    \"\"\"\n\n    def __init__(self, record_id: str, newly_start=True, root_dir=None, logger: Logger=None):\n        self.record_id = record_id\n        self.record_root_dir = root_dir\n        if not os.path.exists(self.record_root_dir):\n            os.makedirs(self.record_root_dir, exist_ok=True)\n\n        self.newly_start = newly_start  # \n        self.logger = logger\n        self.query = {}\n        self.config = {}\n\n        self.llm_interface_id = 0\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.now_subtask_id = None\n\n    def change_now_task(self, new_subtask_id):\n        \"\"\"change now task\"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n    def generate_record(self, current, node_id, node_type, data):\n        \"\"\"generate a recorder\"\"\"\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder Start-=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=f\"Current: {current} Node: {node_type} {node_id}\")\n        json_str = json.dumps(data, ensure_ascii=False, indent=4)\n        json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Data -=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder End-=-=-=-=-=-=-=\",\n                                   title_color=Fore.GREEN,\n                                   content=\"\")\n\n        return XAgentRunningRecord(\n            record_id=self.record_id,\n            current=current,\n            node_id=node_id,\n            node_type=node_type,\n            data=data,\n            create_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n        )\n\n\n    def regist_plan_modify(self,\n                           refine_function_name,\n                           refine_function_input,\n                           refine_function_output,\n                           plan_after):\n        \"\"\"plan_refine\"\"\"\n        plan_refine_record = {\n            \"refine_function_name\": dump_common_things(refine_function_name),\n            \"refine_function_input\": dump_common_things(refine_function_input),\n            \"refine_function_output\": dump_common_things(refine_function_output),\n            \"plan_after\": dump_common_things(plan_after),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.plan_refine_id,\n            node_type=RecorderTypeEnum.PLAN_REFINE,\n            data=plan_refine_record,\n        )\n\n\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.plan_refine_id += 1\n\n    def regist_llm_inout(self,\n                         messages,\n                         functions,\n                         function_call,\n                         model,\n                         stop,\n                         other_args,\n                         output_data):\n        \"\"\"llm_inout\"\"\"\n        llm_inout_record = {\n            \"input\": {\n                \"messages\": dump_common_things(messages),\n                \"functions\": dump_common_things(functions),\n                \"function_call\": dump_common_things(function_call),\n                \"model\": dump_common_things(model),\n                \"stop\": dump_common_things(stop),\n                \"other_args\": dump_common_things(other_args),\n            },\n            \"output\": dump_common_things(output_data),\n            \"llm_interface_id\": self.llm_interface_id,\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.llm_interface_id,\n            node_type=RecorderTypeEnum.LLM_INPUT_PAIR,\n            data=llm_inout_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.llm_interface_id += 1\n\n    def query_llm_inout(self, restrict_cache_query, messages, functions, function_call, model, stop, other_args):\n        \"\"\"restrict_cache_query: llm_interface_id\n\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        for cache in self.llm_server_cache:\n            if input_data == cache[\"input\"]:\n                if restrict_cache_query and self.llm_interface_id != cache[\"llm_interface_id\"]:\n                    continue\n\n                # import pdb; pdb.set_trace()\n                return cache[\"output\"]\n        return None\n\n    def regist_tool_call(self,\n                         tool_name,\n                         tool_input,\n                         tool_output,\n                         tool_status_code,\n                         thought_data=None):\n        \"\"\"tool server\n        \"\"\"\n        tool_record = {\n            \"tool_name\": dump_common_things(tool_name),\n            \"tool_input\": dump_common_things(tool_input),\n            \"tool_output\": dump_common_things(tool_output),\n            \"tool_status_code\": dump_common_things(tool_status_code),\n        }\n        if thought_data:\n            tool_record[\"thought\"] = dump_common_things(thought_data)\n\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.tool_call_id,\n            node_type=RecorderTypeEnum.TOOL_CALL,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.tool_call_id += 1\n\n    def regist_tool_server(self,\n                           url,\n                           payload,\n                           tool_output,\n                           response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        tool_record = {\n            \"url\": dump_common_things(url.split(\"/\")[-1]),\n            \"payload\": dump_common_things(payload),\n            \"response_status_code\": dump_common_things(response_status_code),\n            \"tool_output\": dump_common_things(tool_output),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.toolserver_interface_id,\n            node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.toolserver_interface_id += 1\n\n    def query_tool_server_cache(self, url, payload):\n        \"\"\"query tool server cache\"\"\"\n        if self.newly_start:\n            return None\n\n        if not self.tool_server_cache:\n            with get_db() as db:\n                tool_record = RunningRecordCRUD.get_record_by_type(\n                    db=db,\n                    record_id=self.record_id,\n                    node_id=0,\n                    node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n                )\n\n            self.tool_server_cache = [json.loads(\n                record.data) for record in tool_record]\n\n        for cache in self.tool_server_cache:\n            # import pdb; pdb.set_trace()\n            if cache[\"url\"] == url.split(\"/\")[-1] \\\n                    and cache[\"payload\"] == dump_common_things(payload):\n                print(f\"get a tool_server response from Record: {cache['tool_output']}\")\n                return cache[\"tool_output\"]\n\n        return None\n\n    def regist_query(self, query):\n        \"\"\"query\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.QUERY,\n            data=query.to_json(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n    def get_query(self):\n        \"\"\"get query from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.QUERY,\n            )\n\n        self.query = AutoGPTQuery.from_json(records[0].data)\n        return self.query\n\n    def regist_config(self, config: XAgentConfig):\n        \"\"\"config\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.CONFIG,\n            data=config.to_dict(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n    def get_config(self):\n        \"\"\"get running config from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.CONFIG,\n            )\n        return json.loads(records[0].data)\n\n    def load_from_db(self, record_id):\n        \"\"\"record\n        \"\"\"\n\n        self.newly_start = False\n\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=record_id\n            )\n\n        for record in records:\n            if record.node_type == RecorderTypeEnum.QUERY:\n                self.query = AutoGPTQuery.from_json(record.data)\n            elif record.node_type == RecorderTypeEnum.CONFIG:\n                self.config = XAgentConfig()\n                self.config.merge_from_dict(record.data)\n            elif record.node_type == RecorderTypeEnum.LLM_INPUT_PAIR:\n                self.llm_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_SERVER_PAIR:\n                self.tool_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.PLAN_REFINE:\n                self.plan_refine_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_CALL:\n                self.tool_call_cache.append(record.data)\n            else:\n                raise NotImplementedError\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Recorder\n\n__init__\n- record_id: strID\n- newly_start: boolRecorder\n- root_dir: str\n- logger: Logger\n\n\n\nqueryconfig\n\nIDllm_interface_idtoolserver_interface_idtool_call_idplan_refine_id\n\nllm_server_cachetool_server_cachetool_call_cacheplan_refine_cache\n\nIDnow_subtask_id\n\n****",
            "code_start_line": 52,
            "code_end_line": 74,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def __init__(self, record_id: str, newly_start=True, root_dir=None, logger: Logger=None):\n        self.record_id = record_id\n        self.record_root_dir = root_dir\n        if not os.path.exists(self.record_root_dir):\n            os.makedirs(self.record_root_dir, exist_ok=True)\n\n        self.newly_start = newly_start  # \n        self.logger = logger\n        self.query = {}\n        self.config = {}\n\n        self.llm_interface_id = 0\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.now_subtask_id = None\n",
            "name_column": 8
        },
        "change_now_task": {
            "type": "FunctionDef",
            "name": "change_now_task",
            "md_content": "**change_now_task**: \n\nIDIDIDIDID0\n\n****: \n- IDID\n- \n- ID",
            "code_start_line": 76,
            "code_end_line": 80,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def change_now_task(self, new_subtask_id):\n        \"\"\"change now task\"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n",
            "name_column": 8
        },
        "generate_record": {
            "type": "FunctionDef",
            "name": "generate_record",
            "md_content": "**generate_record**\n\ncurrentIDnode_idIDnode_typedataloggerdataJSONXAgentRunningRecord\n\n\n- XAgent/recorder.pyregist_plan_modifygenerate_recordplan_refine\n- XAgent/recorder.pyregist_llm_inoutgenerate_recordllm_inout\n- XAgent/recorder.pyregist_tool_callgenerate_recordtool_call\n- XAgent/recorder.pyregist_tool_servergenerate_recordtool_server\n- XAgent/recorder.pyregist_querygenerate_recordquery\n- XAgent/recorder.pyregist_configgenerate_recordconfig\n\n****\n- \n- dataJSON\n\n****\n```\n{\n    \"record_id\": 1,\n    \"current\": 1,\n    \"node_id\": 1,\n    \"node_type\": \"PLAN_REFINE\",\n    \"data\": {\n        \"refine_function_name\": \"refine_function\",\n        \"refine_function_input\": \"input_data\",\n        \"refine_function_output\": \"output_data\",\n        \"plan_after\": \"new_plan\"\n    },\n    \"create_time\": \"2022-01-01 00:00:00\",\n    \"update_time\": \"2022-01-01 00:00:00\",\n    \"is_deleted\": false\n}\n```",
            "code_start_line": 82,
            "code_end_line": 105,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def generate_record(self, current, node_id, node_type, data):\n        \"\"\"generate a recorder\"\"\"\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder Start-=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=f\"Current: {current} Node: {node_type} {node_id}\")\n        json_str = json.dumps(data, ensure_ascii=False, indent=4)\n        json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Data -=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder End-=-=-=-=-=-=-=\",\n                                   title_color=Fore.GREEN,\n                                   content=\"\")\n\n        return XAgentRunningRecord(\n            record_id=self.record_id,\n            current=current,\n            node_id=node_id,\n            node_type=node_type,\n            data=data,\n            create_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n        )\n",
            "name_column": 8
        },
        "regist_plan_modify": {
            "type": "FunctionDef",
            "name": "regist_plan_modify",
            "md_content": "**regist_plan_modify**plan_refine\n\nrefine_function_namerefine_function_inputrefine_function_outputplan_afterrefine_function_namerefinerefine_function_inputrefinerefine_function_outputrefineplan_afterrefineplan\n\nplan_refine_recordrefine_function_namerefine_function_inputrefine_function_outputplan_afterdump_common_things\n\nself.generate_recordIDcurrentplan_refineIDnode_idnode_typeplan_refine_record\n\nget_dbRunningRecordCRUDinsert_record\n\nplan_refine_id1\n\n****\n- refine_function_namerefine_function_inputrefine_function_outputplan_after\n- RunningRecordCRUDinsert_record\n- plan_refineplan_refine_id1ID",
            "code_start_line": 108,
            "code_end_line": 130,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_plan_modify(self,\n                           refine_function_name,\n                           refine_function_input,\n                           refine_function_output,\n                           plan_after):\n        \"\"\"plan_refine\"\"\"\n        plan_refine_record = {\n            \"refine_function_name\": dump_common_things(refine_function_name),\n            \"refine_function_input\": dump_common_things(refine_function_input),\n            \"refine_function_output\": dump_common_things(refine_function_output),\n            \"plan_after\": dump_common_things(plan_after),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.plan_refine_id,\n            node_type=RecorderTypeEnum.PLAN_REFINE,\n            data=plan_refine_record,\n        )\n\n\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.plan_refine_id += 1\n",
            "name_column": 8
        },
        "regist_llm_inout": {
            "type": "FunctionDef",
            "name": "regist_llm_inout",
            "md_content": "**regist_llm_inout**: llm_inout\n\n\n- messages: \n- functions: \n- function_call: \n- model: \n- stop: \n- other_args: \n- output_data: \n\nllm_inout_recordmessagesfunctionsfunction_callmodelstopother_argsdump_common_thingsdump_common_thingsoutput_data\n\ngenerate_recordrecordrecordIDllm_interface_idRecorderTypeEnum.LLM_INPUT_PAIRllm_inout_record\n\nget_dbRunningRecordCRUDinsert_recordrecord\n\nllm_interface_id1\n\n****: \n- \n- ",
            "code_start_line": 132,
            "code_end_line": 161,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_llm_inout(self,\n                         messages,\n                         functions,\n                         function_call,\n                         model,\n                         stop,\n                         other_args,\n                         output_data):\n        \"\"\"llm_inout\"\"\"\n        llm_inout_record = {\n            \"input\": {\n                \"messages\": dump_common_things(messages),\n                \"functions\": dump_common_things(functions),\n                \"function_call\": dump_common_things(function_call),\n                \"model\": dump_common_things(model),\n                \"stop\": dump_common_things(stop),\n                \"other_args\": dump_common_things(other_args),\n            },\n            \"output\": dump_common_things(output_data),\n            \"llm_interface_id\": self.llm_interface_id,\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.llm_interface_id,\n            node_type=RecorderTypeEnum.LLM_INPUT_PAIR,\n            data=llm_inout_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.llm_interface_id += 1\n",
            "name_column": 8
        },
        "query_llm_inout": {
            "type": "FunctionDef",
            "name": "query_llm_inout",
            "md_content": "**query_llm_inout**LLM\n\n\n- restrict_cache_queryLLMID\n- messages\n- functions\n- function_call\n- model\n- stop\n- other_args\n\nLLMNone\n\ninput_datamessagesfunctionsfunction_callmodelstopother_args\n\nllm_server_cacheinputrestrict_cache_queryllm_interface_idllm_interface_idllm_interface_idoutput\n\nNone\n\n****\n- \n- restrict_cache_query\n- llm_interface_id\n\n****output",
            "code_start_line": 163,
            "code_end_line": 184,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_llm_inout(self, restrict_cache_query, messages, functions, function_call, model, stop, other_args):\n        \"\"\"restrict_cache_query: llm_interface_id\n\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        for cache in self.llm_server_cache:\n            if input_data == cache[\"input\"]:\n                if restrict_cache_query and self.llm_interface_id != cache[\"llm_interface_id\"]:\n                    continue\n\n                # import pdb; pdb.set_trace()\n                return cache[\"output\"]\n        return None\n",
            "name_column": 8
        },
        "regist_tool_call": {
            "type": "FunctionDef",
            "name": "regist_tool_call",
            "md_content": "**regist_tool_call**tool server\n\n\n- tool_name\n- tool_input\n- tool_output\n- tool_status_code\n- thought_data\n\n\n1. tool_record\n2. tool_record\n3. generate_recordIDID\n4. get_dbRunningRecordCRUDinsert_record\n5. ID\n\n****\n- \n- thought_data\n- \n- ",
            "code_start_line": 186,
            "code_end_line": 212,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_call(self,\n                         tool_name,\n                         tool_input,\n                         tool_output,\n                         tool_status_code,\n                         thought_data=None):\n        \"\"\"tool server\n        \"\"\"\n        tool_record = {\n            \"tool_name\": dump_common_things(tool_name),\n            \"tool_input\": dump_common_things(tool_input),\n            \"tool_output\": dump_common_things(tool_output),\n            \"tool_status_code\": dump_common_things(tool_status_code),\n        }\n        if thought_data:\n            tool_record[\"thought\"] = dump_common_things(thought_data)\n\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.tool_call_id,\n            node_type=RecorderTypeEnum.TOOL_CALL,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.tool_call_id += 1\n",
            "name_column": 8
        },
        "regist_tool_server": {
            "type": "FunctionDef",
            "name": "regist_tool_server",
            "md_content": "**regist_tool_server**\n\n\n- urlstrURL\n- payloadAnypayload\n- tool_outputAny\n- response_status_codeint\n\n\n\n\n```python\nregist_tool_server(url, payload, tool_output, response_status_code)\n```\n\n****URLpayload",
            "code_start_line": 214,
            "code_end_line": 243,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_server(self,\n                           url,\n                           payload,\n                           tool_output,\n                           response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        tool_record = {\n            \"url\": dump_common_things(url.split(\"/\")[-1]),\n            \"payload\": dump_common_things(payload),\n            \"response_status_code\": dump_common_things(response_status_code),\n            \"tool_output\": dump_common_things(tool_output),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.toolserver_interface_id,\n            node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.toolserver_interface_id += 1\n",
            "name_column": 8
        },
        "query_tool_server_cache": {
            "type": "FunctionDef",
            "name": "query_tool_server_cache",
            "md_content": "**query_tool_server_cache**\n\nURLpayloadNone\n\n\n- urlURL\n- payload\n\n\n1. None\n2. JSONself.tool_server_cache\n3. self.tool_server_cacheURLpayloadurlpayload\n4. self.tool_server_cacheNone\n\n****urlpayloadURLpayload\n\n****\n```\nget a tool_server response from Record: {\"output\": \"example output\"}\n```",
            "code_start_line": 245,
            "code_end_line": 269,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_tool_server_cache(self, url, payload):\n        \"\"\"query tool server cache\"\"\"\n        if self.newly_start:\n            return None\n\n        if not self.tool_server_cache:\n            with get_db() as db:\n                tool_record = RunningRecordCRUD.get_record_by_type(\n                    db=db,\n                    record_id=self.record_id,\n                    node_id=0,\n                    node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n                )\n\n            self.tool_server_cache = [json.loads(\n                record.data) for record in tool_record]\n\n        for cache in self.tool_server_cache:\n            # import pdb; pdb.set_trace()\n            if cache[\"url\"] == url.split(\"/\")[-1] \\\n                    and cache[\"payload\"] == dump_common_things(payload):\n                print(f\"get a tool_server response from Record: {cache['tool_output']}\")\n                return cache[\"tool_output\"]\n\n        return None\n",
            "name_column": 8
        },
        "regist_query": {
            "type": "FunctionDef",
            "name": "regist_query",
            "md_content": "**regist_query**query\n\nquerygenerate_recordrecordIDIDqueryJSONget_dbRunningRecordCRUDinsert_record\n\n\nXAgent/core.py\n\n```python\ndef resister_recorder(self, param: XAgentParam):\n    \"\"\"\n    register a recorder to the core components\n    \"\"\"\n    self.recorder = RunningRecoder(\n        record_id=self.interaction.base.interaction_id,\n        newly_start=param.newly_created,\n        root_dir=self.base_dir,\n        logger=self.logger\n    )\n    if param.newly_created:\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n    else:\n        self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n\n    XAgentCoreComponents.global_recorder = self.recorder\n```\nresister_recorderRunningRecoderIDregist_queryregist_configqueryconfigXAgentCoreComponents.global_recorder\n\n****\n- query\n- \n- ",
            "code_start_line": 271,
            "code_end_line": 281,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_query(self, query):\n        \"\"\"query\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.QUERY,\n            data=query.to_json(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n",
            "name_column": 8
        },
        "get_query": {
            "type": "FunctionDef",
            "name": "get_query",
            "md_content": "**get_query**\n\n`get_db()``with``RunningRecordCRUD.get_record_by_type()`\n- `db`\n- `record_id`ID\n- `node_id`ID0\n- `node_type`RecorderTypeEnum.QUERY\n\n`records``AutoGPTQuery.from_json()``AutoGPTQuery``self.query``self.query`\n\n****IDID\n\n****`{\"query\": \"SELECT * FROM table\"}``self.query``AutoGPTQuery(query=\"SELECT * FROM table\")`",
            "code_start_line": 283,
            "code_end_line": 294,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_query(self):\n        \"\"\"get query from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.QUERY,\n            )\n\n        self.query = AutoGPTQuery.from_json(records[0].data)\n        return self.query\n",
            "name_column": 8
        },
        "regist_config": {
            "type": "FunctionDef",
            "name": "regist_config",
            "md_content": "**regist_config**: config\n\nconfig\n\n1. self.generate_recordrecordIDcurrentIDnode_idnode_typeconfigdata\n\n2. get_dbrecord\n\n\n\nXAgent/core.py\n\n```python\ndef resister_recorder(self, param: XAgentParam):\n    \"\"\"\n    register a recorder to the core components\n    \"\"\"\n    self.recorder = RunningRecoder(\n        record_id=self.interaction.base.interaction_id,\n        newly_start=param.newly_created,\n        root_dir=self.base_dir,\n        logger=self.logger\n    )\n    if param.newly_created:\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n    else:\n        self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n\n    XAgentCoreComponents.global_recorder = self.recorder\n```\n\nrecorderrecorderparam.queryconfigparam.configrecorderXAgentCoreComponents.global_recorderrecorderrecorder\n\n****regist_configXAgentConfig",
            "code_start_line": 296,
            "code_end_line": 306,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_config(self, config: XAgentConfig):\n        \"\"\"config\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.CONFIG,\n            data=config.to_dict(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n",
            "name_column": 8
        },
        "get_config": {
            "type": "FunctionDef",
            "name": "get_config",
            "md_content": "**get_config**\n\n`get_db()``RunningRecordCRUD.get_record_by_type()``record_id``node_id``node_type``json.loads()`JSON\n\n****`record_id`\n\n****\n\n```python\n{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n    ...\n}\n```",
            "code_start_line": 308,
            "code_end_line": 317,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_config(self):\n        \"\"\"get running config from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.CONFIG,\n            )\n        return json.loads(records[0].data)\n",
            "name_column": 8
        },
        "load_from_db": {
            "type": "FunctionDef",
            "name": "load_from_db",
            "md_content": "**load_from_db**: record\n\nrecord_idrecordIDself.newly_startFalserecord\n\nget_db()RunningRecordCRUDget_record_by_typerecord_id\n\nrecordnode_typedata\n- node_typeRecorderTypeEnum.QUERYrecorddataAutoGPTQueryself.query\n- node_typeRecorderTypeEnum.CONFIGXAgentConfigrecorddata\n- node_typeRecorderTypeEnum.LLM_INPUT_PAIRrecorddataself.llm_server_cache\n- node_typeRecorderTypeEnum.TOOL_SERVER_PAIRrecorddataself.tool_server_cache\n- node_typeRecorderTypeEnum.PLAN_REFINErecorddataself.plan_refine_cache\n- node_typeRecorderTypeEnum.TOOL_CALLrecorddataself.tool_call_cache\n- node_typeNotImplementedError\n\n****: record_idrecord_id",
            "code_start_line": 319,
            "code_end_line": 346,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def load_from_db(self, record_id):\n        \"\"\"record\n        \"\"\"\n\n        self.newly_start = False\n\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=record_id\n            )\n\n        for record in records:\n            if record.node_type == RecorderTypeEnum.QUERY:\n                self.query = AutoGPTQuery.from_json(record.data)\n            elif record.node_type == RecorderTypeEnum.CONFIG:\n                self.config = XAgentConfig()\n                self.config.merge_from_dict(record.data)\n            elif record.node_type == RecorderTypeEnum.LLM_INPUT_PAIR:\n                self.llm_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_SERVER_PAIR:\n                self.tool_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.PLAN_REFINE:\n                self.plan_refine_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_CALL:\n                self.tool_call_cache.append(record.data)\n            else:\n                raise NotImplementedError\n",
            "name_column": 8
        }
    },
    "XAgent/summarization_system.py": {
        "SummarizationNode": {
            "type": "ClassDef",
            "name": "SummarizationNode",
            "md_content": "**SummarizationNode**: \n\nXAgent.data_structure.nodeNode\n\n****:\n- father (SummarizationNode): \n- children (List[SummarizationNode]): \n- message (Message): \n- summarization_from_root_to_here: \n\n****:\n- `__init__(self)`: \n- `add_father_child_relation(cls, father, child)`: \n- `add_father_child_relation(cls, father, child)`: \n\n****: \n- `add_father_child_relation``AssertionError`\n- `SummarizationNode``add_father_child_relation`\n\n\n- XAgent/summarization_system.pySummarizationTrieTree`query``insert`SummarizationNode\n- XAgent/summarization_system.pySummarizationTrieTree`generate_summary`SummarizationNode\n\n**SummarizationTrieTree**: Trie\n\n****:\n- root (SummarizationNode): \n- config: \n\n****:\n- `__init__(self, config)`: \n- `query(self, message_list: List[Message]) -> SummarizationTreeQueryResult`: \n- `insert(self, message_list)`: \n- `get_summarzation_message_all(cls, father_summarize_node: SummarizationNode, message_list: List[Message]) -> List[Message]`: \n- `get_summarzation_message_recursive(cls, father_summarize_node: SummarizationNode, new_message: Message)`: \n- `generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None)`: \n\n****: \n- `query`\n- `insert`\n- `get_summarzation_message_all`\n- `get_summarzation_message_recursive`\n- `generate_summary`\n\n\n- XAgent/summarization_system.pySummarizationTrieTree`generate_summary`SummarizationNode",
            "code_start_line": 9,
            "code_end_line": 41,
            "parent": null,
            "have_return": false,
            "code_content": "class SummarizationNode(Node):\n    \"\"\"Class to represent nodes in the summarization tree.\n\n    Inherits from the Node class defined in XAgent.data_structure.node.\n\n    Attributes:\n        father (SummarizationNode): Parent SummarizationNode.\n        children (List[SummarizationNode]): List of child SummarizationNodes.\n        message (Message): Message associated with this node.\n        summarization_from_root_to_here: Summary from root node to this node.\n    \"\"\"\n    def __init__(self):\n        self.father: SummarizationNode = None\n        self.children: List[SummarizationNode] = []\n\n        self.message: Message = None\n\n        self.summarization_from_root_to_here = None\n\n    @classmethod\n    def add_father_child_relation(cls, father, child):\n        \"\"\"Adds relation between father SummarizationNode and child SummarizationNode.\n\n        Args:\n            father (SummarizationNode): Parent node.\n            child (SummarizationNode): Child node to be added to the parent node's children list.\n\n        Raises:\n            AssertionError: If the child node is already in the father's children list.\n        \"\"\"\n        assert child not in father.children\n        father.children.append(child)\n        child.father = father\n",
            "name_column": 6
        },
        "SummarizationTreeQueryResult": {
            "type": "ClassDef",
            "name": "SummarizationTreeQueryResult",
            "md_content": "**SummarizationTreeQueryResult**\n\n\n- have_summary\n- not_in_tree\n- in_tree_but_no_summary\n\n\n- XAgent/summarization_system.py\n- \n    def query(self, message_list: List[Message]) -> SummarizationTreeQueryResult:\n        \"\"\"\n\n        :\n            message_list (List[Message]): \n\n        :\n            SummarizationTreeQueryResult: \n            SummarizationNode: \n        \"\"\"\n        # \n\n    def generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None):\n        \"\"\"\n\n        :\n            message_list (List[Message]): \n            recursive_mode (bool): \n            \n        :\n            str: \n        \"\"\"\n        # \n\n****\n- `query`\n- `generate_summary`",
            "code_start_line": 45,
            "code_end_line": 49,
            "parent": null,
            "have_return": false,
            "code_content": "class SummarizationTreeQueryResult(Enum):\n    \"\"\"Enumeration for possible results when querying the summarization tree.\"\"\"\n    have_summary = 0\n    not_in_tree = 1\n    in_tree_but_no_summary = 2\n",
            "name_column": 6
        },
        "SummarizationTrieTree": {
            "type": "ClassDef",
            "name": "SummarizationTrieTree",
            "md_content": "**SummarizationTrieTree**: Trie\n\n\n- root (SummarizationNode): \n- config: \n\n**__init__**:\n- : config ()\n- : SummarizationTrieTree\n- : \n\n**query**:\n- : message_list ()\n- : \n- : \n  - SummarizationTreeQueryResult: \n  - SummarizationNode: \n\n**insert**:\n- : message_list ()\n- : Trie\n- : \n\n**get_summarzation_message_all**:\n- : father_summarize_node (), message_list ()\n- : \n- : \n\n**get_summarzation_message_recursive**:\n- : father_summarize_node (), new_message ()\n- : \n- : \n\n**generate_summary**:\n- : message_list (), recursive_mode (), agent_dispatcher ()\n- : \n- : \n\n****: \n\n****:\n```\n\n```",
            "code_start_line": 52,
            "code_end_line": 217,
            "parent": null,
            "have_return": true,
            "code_content": "class SummarizationTrieTree:\n    \"\"\"Class to represent the Summarization Trie Tree. The tree is used to generate summaries.\n\n    Attributes:\n        root (SummarizationNode): Root node of the tree.\n        config: Configuration data for the tree.\n    \"\"\"\n    def __init__(self, config):\n        self.root = SummarizationNode()\n        self.config = config\n\n    def query(self, message_list: List[Message]) -> SummarizationTreeQueryResult:\n        \"\"\"Queries the tree with the given list of messages.\n\n        Args:\n            message_list (List[Message]): The list of messages for the tree query.\n\n        Returns:\n            SummarizationTreeQueryResult: The state of summary related to the query.\n            SummarizationNode: If the list of messages is in the tree, returns the node where the search ended.\n        \"\"\"\n        now_node = self.root\n\n        now_position = 0\n        while now_position < len(message_list):\n            now_message = message_list[now_position]\n            find = False\n            for child in now_node.children:\n                if Message.equal(child.message, now_message):\n                    find = True\n                    now_node = child\n                    break\n            \n            if find:\n                now_position += 1\n            else:\n                return SummarizationTreeQueryResult.not_in_tree, now_node\n        \n        if now_node.summarzation_from_root_to_here:\n            return SummarizationTreeQueryResult.have_summary, now_node\n        else:\n            return SummarizationTreeQueryResult.in_tree_but_no_summary, now_node\n        \n\n    def insert(self,message_list):\n        now_node = self.root\n\n        now_position = 0\n        while now_position < len(message_list):\n            now_message = message_list[now_position]\n            find = False\n            for child in now_node.children:\n                if Message.equal(child.message, now_message):\n                    find = True\n                    now_node = child\n                    break\n            \n            if find:\n                now_position += 1\n            else:\n                break\n\n        assert now_position < len(message_list)\n\n\n        for i in range(now_position, len(message_list)):\n            new_node = SummarizationNode()\n            new_node.message = message_list[i]\n            SummarizationNode.add_father_child_relation(now_node,new_node)\n            now_node = new_node\n\n        return now_node\n\n\n    def insert(self, message_list):\n        \"\"\"Inserts a list of messages into the trie tree.\n\n        Args:\n            message_list (List[Message]): List of messages to be inserted into the tree.\n\n        Returns:\n            SummarizationNode: Returns the end node after insertion.\n        \"\"\"\n\n    @classmethod\n    def get_summarzation_message_all(cls, father_summarize_node: SummarizationNode, message_list: List[Message]) -> List[Message]:\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in message_list] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n\n\n\n    @classmethod\n    def get_summarzation_message_recursive(cls, father_summarize_node: SummarizationNode, new_message: Message):\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Summary So Far:\n        \"\"\"\n        {father_summarize_node.summarization_from_root_to_here}\n        \"\"\"\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in new_message] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n\n\n    def generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None):\n        \"\"\"Generates a summary for the given list of messages.\n\n        Args:\n            message_list (List[Message]): List of messages to be summarized.\n            recursive_mode (bool): Flag indicating if recursive mode summarization is required.\n            \n        Returns:\n            str: The new summarized content text.\n        \"\"\"\n        status_code, summarize_node = self.query(message_list)\n        assert status_code != SummarizationTreeQueryResult.have_summary\n        if recursive_mode:\n            status_code, summarize_node = self.query(message_list[:-1])\n            assert status_code == SummarizationTreeQueryResult.have_summary\n\n            summarize_message_list = self.get_summarzation_message_recursive(summarize_node, message_list[-1])\n        else:\n            \n            if status_code == SummarizationTreeQueryResult.not_in_tree:\n                summarize_node = self.insert(message_list)\n            summarize_message_list = self.get_summarzation_message_all( summarize_node, message_list)\n\n\n        # print(summarize_message_list)\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.summarization, \n            \"Summarize the given content\"\n        )\n\n        _, new_message, _ = agent.parse(placeholders={\n            \"system\": {\n                \"running_summary\": summarize_node.summarization_from_root_to_here,\n                \"new_message\": [message.content for message in message_list] or \"Nothing new happened.\"\n            }\n        })\n\n        new_summary = new_message[\"content\"]\n\n        summarize_node.summarization_from_root_to_here = new_summary\n\n        return new_summary\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**SummarizationSystem\n\nconfigself.rootself.config\n\nself.rootSummarizationNode\n\nself.config\n\n****",
            "code_start_line": 59,
            "code_end_line": 61,
            "parent": "SummarizationTrieTree",
            "have_return": false,
            "code_content": "    def __init__(self, config):\n        self.root = SummarizationNode()\n        self.config = config\n",
            "name_column": 8
        },
        "add_father_child_relation": {
            "type": "FunctionDef",
            "name": "add_father_child_relation",
            "md_content": "**add_father_child_relation**\n\nSummarizationNodeAssertionError\n\n****AssertionError",
            "code_start_line": 29,
            "code_end_line": 41,
            "parent": "SummarizationNode",
            "have_return": false,
            "code_content": "    def add_father_child_relation(cls, father, child):\n        \"\"\"Adds relation between father SummarizationNode and child SummarizationNode.\n\n        Args:\n            father (SummarizationNode): Parent node.\n            child (SummarizationNode): Child node to be added to the parent node's children list.\n\n        Raises:\n            AssertionError: If the child node is already in the father's children list.\n        \"\"\"\n        assert child not in father.children\n        father.children.append(child)\n        child.father = father\n",
            "name_column": 8
        },
        "query": {
            "type": "FunctionDef",
            "name": "query",
            "md_content": "**query**\n\n\n\n\n\n\"not_in_tree\"\n\n\n\n****\n\n****\"have_summary\"A\n\n",
            "code_start_line": 63,
            "code_end_line": 93,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def query(self, message_list: List[Message]) -> SummarizationTreeQueryResult:\n        \"\"\"Queries the tree with the given list of messages.\n\n        Args:\n            message_list (List[Message]): The list of messages for the tree query.\n\n        Returns:\n            SummarizationTreeQueryResult: The state of summary related to the query.\n            SummarizationNode: If the list of messages is in the tree, returns the node where the search ended.\n        \"\"\"\n        now_node = self.root\n\n        now_position = 0\n        while now_position < len(message_list):\n            now_message = message_list[now_position]\n            find = False\n            for child in now_node.children:\n                if Message.equal(child.message, now_message):\n                    find = True\n                    now_node = child\n                    break\n            \n            if find:\n                now_position += 1\n            else:\n                return SummarizationTreeQueryResult.not_in_tree, now_node\n        \n        if now_node.summarzation_from_root_to_here:\n            return SummarizationTreeQueryResult.have_summary, now_node\n        else:\n            return SummarizationTreeQueryResult.in_tree_but_no_summary, now_node\n",
            "name_column": 8
        },
        "insert": {
            "type": "FunctionDef",
            "name": "insert",
            "md_content": "**insert**trie\n\n\n\n\n\n\n\n\n\n****\n- \n- \n- None\n\n\n- XAgent/summarization_system.py\n- \n    ```\n    summarize_node = self.insert(message_list)\n    ```",
            "code_start_line": 126,
            "code_end_line": 134,
            "parent": "SummarizationTrieTree",
            "have_return": false,
            "code_content": "    def insert(self, message_list):\n        \"\"\"Inserts a list of messages into the trie tree.\n\n        Args:\n            message_list (List[Message]): List of messages to be inserted into the tree.\n\n        Returns:\n            SummarizationNode: Returns the end node after insertion.\n        \"\"\"\n",
            "name_column": 8
        },
        "get_summarzation_message_all": {
            "type": "FunctionDef",
            "name": "get_summarzation_message_all",
            "md_content": "**get_summarzation_message_all**: \n\nfather_summarize_nodeSummarizationNodemessage_listList[Message]List[Message]\n\n(system_prompt)message_list\n\nmessage_list\n\n****: \n- father_summarize_nodeSummarizationNode\n- message_listList[Message]\n- List[Message]\n\n****:\n```\n[\n    Message(sender='system', content='Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\\n\\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\\n\\nLatest Development:\\n\"\"\"\\n[message.content for message in message_list] or \"Nothing new happened.\"\\n\"\"\"\\n')\n]\n```",
            "code_start_line": 137,
            "code_end_line": 150,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def get_summarzation_message_all(cls, father_summarize_node: SummarizationNode, message_list: List[Message]) -> List[Message]:\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in message_list] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n",
            "name_column": 8
        },
        "get_summarzation_message_recursive": {
            "type": "FunctionDef",
            "name": "get_summarzation_message_recursive",
            "md_content": "**get_summarzation_message_recursive**\n\nfather_summarize_nodeSummarizationNodenew_messageMessagefather_summarize_nodenew_message\n\nfather_summarize_nodenew_messageMessagemessage_list\n\nmessage_list\n\n****SummarizationNodeMessage\n\n****\n```\n[\n    Message(\n        sender=\"system\",\n        content=\"Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\\n\\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\\n\\nSummary So Far:\\n\\\"\\\"\\\"\\n{father_summarize_node.summarization_from_root_to_here}\\n\\\"\\\"\\\"\\n\\nLatest Development:\\n\\\"\\\"\\\"\\n{[message.content for message in new_message] or \"Nothing new happened.\"}\\n\\\"\\\"\\\"\\n\"\n    )\n]\n```",
            "code_start_line": 155,
            "code_end_line": 173,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def get_summarzation_message_recursive(cls, father_summarize_node: SummarizationNode, new_message: Message):\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Summary So Far:\n        \"\"\"\n        {father_summarize_node.summarization_from_root_to_here}\n        \"\"\"\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in new_message] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n",
            "name_column": 8
        },
        "generate_summary": {
            "type": "FunctionDef",
            "name": "generate_summary",
            "md_content": "**generate_summary**\n\n\n- message_listList[Message]\n- recursive_modebool\n\n\n\n\nquerySummarizationTreeQueryResult.have_summary\nTruequerySummarizationTreeQueryResult.have_summary\nget_summarzation_message_recursiveget_summarzation_message_all\nFalseSummarizationTreeQueryResult.not_in_treeinsert\nagent_dispatcherdispatchagentagentparse\nsummarize_nodesummarization_from_root_to_here\n\n****\n\n****",
            "code_start_line": 176,
            "code_end_line": 217,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None):\n        \"\"\"Generates a summary for the given list of messages.\n\n        Args:\n            message_list (List[Message]): List of messages to be summarized.\n            recursive_mode (bool): Flag indicating if recursive mode summarization is required.\n            \n        Returns:\n            str: The new summarized content text.\n        \"\"\"\n        status_code, summarize_node = self.query(message_list)\n        assert status_code != SummarizationTreeQueryResult.have_summary\n        if recursive_mode:\n            status_code, summarize_node = self.query(message_list[:-1])\n            assert status_code == SummarizationTreeQueryResult.have_summary\n\n            summarize_message_list = self.get_summarzation_message_recursive(summarize_node, message_list[-1])\n        else:\n            \n            if status_code == SummarizationTreeQueryResult.not_in_tree:\n                summarize_node = self.insert(message_list)\n            summarize_message_list = self.get_summarzation_message_all( summarize_node, message_list)\n\n\n        # print(summarize_message_list)\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.summarization, \n            \"Summarize the given content\"\n        )\n\n        _, new_message, _ = agent.parse(placeholders={\n            \"system\": {\n                \"running_summary\": summarize_node.summarization_from_root_to_here,\n                \"new_message\": [message.content for message in message_list] or \"Nothing new happened.\"\n            }\n        })\n\n        new_summary = new_message[\"content\"]\n\n        summarize_node.summarization_from_root_to_here = new_summary\n\n        return new_summary\n",
            "name_column": 8
        }
    },
    "XAgent/__init__.py": {},
    "XAgent/core.py": {
        "XAgentParam": {
            "type": "ClassDef",
            "name": "XAgentParam",
            "md_content": "**XAgentParam**: XAgent\n\nXAgentParamXAgent\n\n- \n  - configXAgent\n  - queryXAgent\n  - newly_createdXAgent\n\n- \n  - `__init__(self, config=None, query: BaseQuery = None, newly_created: bool = True) -> None`XAgentParamconfigquerynewly_createdXAgent\n\n  - `build_query(self, query: dict)`AutoGPTQueryquery\n\n  - `build_config(self, config)`configconfig\n\n****XAgentParamconfigquerynewly_createdbuild_querybuild_config",
            "code_start_line": 25,
            "code_end_line": 48,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentParam(metaclass=abc.ABCMeta):\n    \"\"\"\n    XAgent Param\n    \"\"\"\n\n    def __init__(self,\n                 config=None,\n                 query: BaseQuery = None,\n                 newly_created: bool = True) -> None:\n        self.config = config\n        self.query = query\n        self.newly_created = newly_created\n\n    def build_query(self, query: dict):\n        \"\"\"\n        build query\n        \"\"\"\n        self.query = AutoGPTQuery(**query)\n\n    def build_config(self, config):\n        \"\"\"\n        build config\n        \"\"\"\n        self.config = config\n",
            "name_column": 6
        },
        "XAgentCoreComponents": {
            "type": "ClassDef",
            "name": "XAgentCoreComponents",
            "md_content": "**XAgentCoreComponents**: XAgentXAgent\n\n\n\n- `register_interaction(interaction: XAgentInteraction)`: \n- `register_logger()`: \n- `resister_recorder(param: XAgentParam)`: \n- `register_toolserver_interface(param: XAgentParam)`: \n- `register_function_handler(config)`: \n- `register_working_memory_function()`: \n- `register_agent_dispatcher(param: XAgentParam)`: \n- `register_vector_db_interface()`: \n- `register_all(param: XAgentParam, interaction: XAgentInteraction)`: \n- `build(param: XAgentParam, interaction: XAgentInteraction)`: \n- `start()`: \n- `close()`: \n- `print_task_save_items(item: TaskSaveItem)`: \n- `print_assistant_thoughts(assistant_reply_json_valid: object, speak_mode: bool = False)`: \n\n****: \n- \n- \n- `print_task_save_items`\n- `print_assistant_thoughts`\n\n****:\n```\nXAgentCoreComponents: XAgentXAgent\n\n\n\n- register_interaction(interaction: XAgentInteraction): \n- register_logger(): \n- resister_recorder(param: XAgentParam): \n- register_toolserver_interface(param: XAgentParam): \n- register_function_handler(config): \n- register_working_memory_function(): \n- register_agent_dispatcher(param: XAgentParam): \n- register_vector_db_interface(): \n- register_all(param: XAgentParam, interaction: XAgentInteraction): \n- build(param: XAgentParam, interaction: XAgentInteraction): \n- start(): \n- close(): \n- print_task_save_items(item: TaskSaveItem): \n- print_assistant_thoughts(assistant_reply_json_valid: object, speak_mode: bool = False): \n\n: \n- \n- \n- print_task_save_items\n- print_assistant_thoughts\n```",
            "code_start_line": 51,
            "code_end_line": 326,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentCoreComponents(metaclass=abc.ABCMeta):\n    \"\"\"\n    XAgent  / XAgent Core Components\n    Components:\n        logger:  / logger\n        recorder:  / running recorder\n        toolserver_interface:  / tool server interface\n        function_handler:  / function handler\n        working_memory_function:  / working memory\n        agent_dispatcher:  / agent dispatcher\n        vector_db_interface:  / vector db interface\n        interaction:  / interaction\n\n\n     / all components in the component set are globally unique\n\n    \"\"\"\n\n    global_recorder = None\n\n    def __init__(self) -> None:\n        self.interaction = None\n        self.logger = None\n        self.recorder = None\n        self.toolserver_interface = None\n        self.function_handler = None\n        self.tool_functions_description_list = []\n        self.function_list = []\n        self.working_memory_function = None\n        self.agent_dispatcher = None\n        self.vector_db_interface = None\n        self.base_dir = \"\"\n        self.extract_dir = \"\"\n        self.available_agents = [\n            PlanGenerateAgent,\n            PlanRefineAgent,\n            ToolAgent,\n            ReflectAgent,\n        ]\n\n    def register_interaction(self,\n                             interaction: XAgentInteraction):\n        \"\"\"\n        register an interaction to the core components\n        \"\"\"\n        self.interaction = interaction\n\n    def register_logger(self):\n        \"\"\"\n        register a logger to the core components\n        \"\"\"\n        self.base_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.interaction.base.interaction_id)\n        if not os.path.exists(self.base_dir):\n            os.makedirs(self.base_dir, exist_ok=True)\n\n        self.extract_dir = os.path.join(self.base_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir, exist_ok=True)\n        self.logger = self.interaction.logger\n\n    def resister_recorder(self, param: XAgentParam):\n        \"\"\"\n        register a recorder to the core components\n        \"\"\"\n        self.recorder = RunningRecoder(\n            record_id=self.interaction.base.interaction_id,\n            newly_start=param.newly_created,\n            root_dir=self.base_dir,\n            logger=self.logger\n        )\n        if param.newly_created:\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n        else:\n            self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n\n        XAgentCoreComponents.global_recorder = self.recorder\n\n    def register_toolserver_interface(self, param: XAgentParam):\n        \"\"\"\n        register a tool server interface to the core components\n        \"\"\"\n        self.logger.info(\"register tool server interface\")\n        self.toolserver_interface = ToolServerInterface(\n            self.recorder, logger=self.logger)\n        self.logger.info(\"lazy init tool server interface\")\n        self.toolserver_interface.lazy_init(config=param.config)\n        # to download all files\n        self.interaction.register_toolserver_interface(\n            self.toolserver_interface)\n\n    def register_function_handler(self, config):\n        \"\"\"\n        register a function handler to the core components\n        \"\"\"\n        self.logger.info(\"register function handler\")\n        self.function_handler = FunctionHandler(\n            toolserver_interface=self.toolserver_interface,\n            config=config,\n            interaction=self.interaction,\n            recorder=self.recorder,\n            logger=self.logger)\n\n    def register_working_memory_function(self):\n        \"\"\"\n        register a working memory agent to the core components\n        \"\"\"\n        # working memory function is used for\n        # communication between different agents that handle different subtasks\n        self.logger.info(\"register working memory function\")\n        self.working_memory_agent = WorkingMemoryAgent(logger=self.logger)\n        self.working_memory_function = WorkingMemoryAgent.get_working_memory_function()\n\n    def register_agent_dispatcher(self, param: XAgentParam):\n        \"\"\"\n        register a agent dispatcher to the core components\n        \"\"\"\n        self.logger.info(\"register agent dispatcher\")\n        self.agent_dispatcher = XAgentDispatcher(param.config,\n                                                 enable=False,\n                                                 logger=self.logger)\n        for agent in self.available_agents:\n            self.agent_dispatcher.regist_agent(agent)\n\n    def register_vector_db_interface(self):\n        \"\"\"\n        register a vector db interface to the core components\n        \"\"\"\n        # self.vector_db_interface = VectorDBInterface()\n        pass\n\n    def register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        register all components to the core components\n        \"\"\"\n        self.register_interaction(interaction)\n        self.register_logger()\n        self.resister_recorder(param)\n        self.register_toolserver_interface(param)\n        self.register_function_handler(param.config)\n        self.register_working_memory_function()\n        self.register_agent_dispatcher(param=param)\n        self.register_vector_db_interface()\n\n    def build(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.register_all(param, interaction)\n        self.logger.info(\"build all components, done!\")\n\n        subtask_functions, self.tool_functions_description_list = self.function_handler.get_functions(\n            param.config)\n        self.function_list = subtask_functions + self.working_memory_function\n\n    def start(self):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.logger.info(\"start all components\")\n\n    def close(self):\n        \"\"\"\n        close all components\n        \"\"\"\n        self.toolserver_interface.download_all_files()\n        self.toolserver_interface.close()\n\n    def print_task_save_items(self,\n                              item: TaskSaveItem,\n                              ) -> None:\n\n        self.logger.typewriter_log(\n            f\"Task Name:\", Fore.YELLOW, f\"{item.name}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Goal:\", Fore.YELLOW, f\"{item.goal}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Prior-Criticism:\", Fore.YELLOW, f\"{item.prior_plan_criticism}\"\n        )\n        if len(item.posterior_plan_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Task Posterior-Criticism:\", Fore.YELLOW\n            )\n            for line in item.posterior_plan_reflection:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.milestones) > 0:\n            self.logger.typewriter_log(\n                f\"Task Milestones:\", Fore.YELLOW,\n            )\n            for line in item.milestones:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        # if len(item.expected_tools) > 0:\n        #     logger.typewriter_log(\n        #         f\"Expected Tools:\", Fore.YELLOW,\n        #     )\n        #     for line in item.expected_tools:\n        #         line = f\"{line['tool_name']}: {line['reason']}\".lstrip(\"- \")\n        #         logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.tool_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Posterior Tool Reflections:\", Fore.YELLOW,\n            )\n            for line in item.tool_reflection:\n                line = f\"{line['target_tool_name']}: {line['reflection']}\".lstrip(\n                    \"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        self.logger.typewriter_log(\n            f\"Task Status:\", Fore.YELLOW, f\"{item.status.name}\"\n        )\n        if item.action_list_summary != \"\":\n            self.logger.typewriter_log(\n                f\"Action Summary:\", Fore.YELLOW, f\"{item.action_list_summary}\"\n            )\n\n    def print_assistant_thoughts(\n        self,\n        # ai_name: object,\n        assistant_reply_json_valid: object,\n        speak_mode: bool = False,\n    ) -> None:\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = assistant_reply_json_valid.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n        if assistant_thoughts_text is not None and assistant_thoughts_text != \"\":\n            self.logger.typewriter_log(\n                f\"THOUGHTS:\", Fore.YELLOW, f\"{assistant_thoughts_text}\"\n            )\n        if assistant_thoughts_reasoning is not None and assistant_thoughts_reasoning != \"\":\n            self.logger.typewriter_log(\n                \"REASONING:\", Fore.YELLOW, f\"{assistant_thoughts_reasoning}\")\n\n        if assistant_thoughts_plan is not None and len(assistant_thoughts_plan) > 0:\n            self.logger.typewriter_log(\"PLAN:\", Fore.YELLOW, \"\")\n            # If it's a list, join it into a string\n            if isinstance(assistant_thoughts_plan, list):\n                assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n            elif isinstance(assistant_thoughts_plan, dict):\n                assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n            # Split the input_string using the newline character and dashes\n            lines = assistant_thoughts_plan.split(\"\\n\")\n            for line in lines:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        if assistant_thoughts_criticism is not None and assistant_thoughts_criticism != \"\":\n            self.logger.typewriter_log(\n                \"CRITICISM:\", Fore.YELLOW, f\"{assistant_thoughts_criticism}\")\n        return {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism,\n            \"node_id\": uuid.uuid4().hex\n        }\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**\n\n\n- interaction\n- logger\n- recorder\n- toolserver_interface\n- function_handler\n- tool_functions_description_list\n- function_list\n- working_memory_function\n- agent_dispatcher\n- vector_db_interface\n- base_dir\n- extract_dir\n- available_agentsPlanGenerateAgentPlanRefineAgentToolAgentReflectAgent\n\n****\n- `__init__`\n- \n- \n\n",
            "code_start_line": 71,
            "code_end_line": 89,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def __init__(self) -> None:\n        self.interaction = None\n        self.logger = None\n        self.recorder = None\n        self.toolserver_interface = None\n        self.function_handler = None\n        self.tool_functions_description_list = []\n        self.function_list = []\n        self.working_memory_function = None\n        self.agent_dispatcher = None\n        self.vector_db_interface = None\n        self.base_dir = \"\"\n        self.extract_dir = \"\"\n        self.available_agents = [\n            PlanGenerateAgent,\n            PlanRefineAgent,\n            ToolAgent,\n            ReflectAgent,\n        ]\n",
            "name_column": 8
        },
        "build_query": {
            "type": "FunctionDef",
            "name": "build_query",
            "md_content": "**build_query**\n\nqueryAutoGPTQueryself.query\n\n****\n- query\n- AutoGPTQueryself.query",
            "code_start_line": 38,
            "code_end_line": 42,
            "parent": "XAgentParam",
            "have_return": false,
            "code_content": "    def build_query(self, query: dict):\n        \"\"\"\n        build query\n        \"\"\"\n        self.query = AutoGPTQuery(**query)\n",
            "name_column": 8
        },
        "build_config": {
            "type": "FunctionDef",
            "name": "build_config",
            "md_content": "**build_config**\n\nconfigself.config\n\nXAgentServer/server.pyinteractbuild_configargsxagent_paramxagent_parambuild_configconfigXAgentCoreComponentsxagent_corebuildxagent_paraminteractionXAgent\n\nbuild_config\n\n****\n- config\n- configself.config",
            "code_start_line": 44,
            "code_end_line": 48,
            "parent": "XAgentParam",
            "have_return": false,
            "code_content": "    def build_config(self, config):\n        \"\"\"\n        build config\n        \"\"\"\n        self.config = config\n",
            "name_column": 8
        },
        "register_interaction": {
            "type": "FunctionDef",
            "name": "register_interaction",
            "md_content": "**register_interaction**interaction\n\ninteractionXAgentInteraction\n\nXAgent/core.pyregister_allregister_interactionregister_allregister_allregister_interactioninteraction\n\n****\n- interactionXAgentInteraction\n- interaction",
            "code_start_line": 91,
            "code_end_line": 96,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_interaction(self,\n                             interaction: XAgentInteraction):\n        \"\"\"\n        register an interaction to the core components\n        \"\"\"\n        self.interaction = interaction\n",
            "name_column": 8
        },
        "register_logger": {
            "type": "FunctionDef",
            "name": "register_logger",
            "md_content": "**register_logger**\n\n\n- base_dirXAgentServerEnv.base_dir\"localstorage\"\"interact_records\"IDXAgentServerEnv.base_dirXAgentServer\"localstorage\"\"interact_records\"datetime.now().strftime(\"%Y-%m-%d\")IDself.interaction.base.interaction_idbase_dir\n- extract_dirbase_dir\"workspace\"extract_dir\n- self.interaction.loggerself.logger\n\n****\n- XAgentServerEnv.base_dirdatetime.now().strftime(\"%Y-%m-%d\")self.interaction.base.interaction_id\n- \n- \n\nregister_logger",
            "code_start_line": 98,
            "code_end_line": 114,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_logger(self):\n        \"\"\"\n        register a logger to the core components\n        \"\"\"\n        self.base_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.interaction.base.interaction_id)\n        if not os.path.exists(self.base_dir):\n            os.makedirs(self.base_dir, exist_ok=True)\n\n        self.extract_dir = os.path.join(self.base_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir, exist_ok=True)\n        self.logger = self.interaction.logger\n",
            "name_column": 8
        },
        "resister_recorder": {
            "type": "FunctionDef",
            "name": "resister_recorder",
            "md_content": "**resister_recorder**\n\nparamXAgentParamRunningRecoderself.recorderRunningRecoder\n- record_idinteraction_id\n- newly_start\n- root_dirbase_dir\n- logger\n\nparam.newly_created\n- param.newly_createdTrueself.recorderregist_queryparam.queryself.recorderregist_configparam.config\n- param.newly_createdFalseself.recorderload_from_dbself.recorderregist_queryparam.queryself.recorderregist_configparam.config\n\nself.recorderXAgentCoreComponentsglobal_recorder\n\n****\n- XAgentParamparam\n- register_allparaminteraction",
            "code_start_line": 116,
            "code_end_line": 134,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def resister_recorder(self, param: XAgentParam):\n        \"\"\"\n        register a recorder to the core components\n        \"\"\"\n        self.recorder = RunningRecoder(\n            record_id=self.interaction.base.interaction_id,\n            newly_start=param.newly_created,\n            root_dir=self.base_dir,\n            logger=self.logger\n        )\n        if param.newly_created:\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n        else:\n            self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n\n        XAgentCoreComponents.global_recorder = self.recorder\n",
            "name_column": 8
        },
        "register_toolserver_interface": {
            "type": "FunctionDef",
            "name": "register_toolserver_interface",
            "md_content": "**register_toolserver_interface**\n\n\n- self.logger.info()\n- ToolServerInterfaceself.toolserver_interfaceself.recorderself.logger\n- self.logger.info()\n- self.toolserver_interfacelazy_init()param.config\n- self.interactionregister_toolserver_interface()self.toolserver_interface\n\n****\n- register_toolserver_interface()register_interaction()register_logger()resister_recorder()\n- register_toolserver_interface()XAgentParamXAgentInteraction\n- register_toolserver_interface()paramconfig\n\n\n- XAgent/core.py\n- \n  ```\n  def register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n      \"\"\"\n      register all components to the core components\n      \"\"\"\n      self.register_interaction(interaction)\n      self.register_logger()\n      self.resister_recorder(param)\n      self.register_toolserver_interface(param)\n      self.register_function_handler(param.config)\n      self.register_working_memory_function()\n      self.register_agent_dispatcher(param=param)\n      self.register_vector_db_interface()\n  ```\n  register_all()register_interaction()register_logger()resister_recorder()register_toolserver_interface()register_toolserver_interface()param",
            "code_start_line": 136,
            "code_end_line": 147,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_toolserver_interface(self, param: XAgentParam):\n        \"\"\"\n        register a tool server interface to the core components\n        \"\"\"\n        self.logger.info(\"register tool server interface\")\n        self.toolserver_interface = ToolServerInterface(\n            self.recorder, logger=self.logger)\n        self.logger.info(\"lazy init tool server interface\")\n        self.toolserver_interface.lazy_init(config=param.config)\n        # to download all files\n        self.interaction.register_toolserver_interface(\n            self.toolserver_interface)\n",
            "name_column": 8
        },
        "register_function_handler": {
            "type": "FunctionDef",
            "name": "register_function_handler",
            "md_content": "**register_function_handler**\n\n\n- toolserver_interface\n- config\n- interaction\n- recorder\n- logger\n\nFunctionHandler\n\n\n- \n- \n- \n- ",
            "code_start_line": 149,
            "code_end_line": 159,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_function_handler(self, config):\n        \"\"\"\n        register a function handler to the core components\n        \"\"\"\n        self.logger.info(\"register function handler\")\n        self.function_handler = FunctionHandler(\n            toolserver_interface=self.toolserver_interface,\n            config=config,\n            interaction=self.interaction,\n            recorder=self.recorder,\n            logger=self.logger)\n",
            "name_column": 8
        },
        "register_working_memory_function": {
            "type": "FunctionDef",
            "name": "register_working_memory_function",
            "md_content": "**register_working_memory_function**\n\n\n\nself.working_memory_agentWorkingMemoryAgentget_working_memory_functionself.working_memory_function\n\nXAgent/core.pyregister_allself.register_working_memory_function()\n\n****\n- \n- \n- self.working_memory_agentself.working_memory_agent",
            "code_start_line": 161,
            "code_end_line": 169,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_working_memory_function(self):\n        \"\"\"\n        register a working memory agent to the core components\n        \"\"\"\n        # working memory function is used for\n        # communication between different agents that handle different subtasks\n        self.logger.info(\"register working memory function\")\n        self.working_memory_agent = WorkingMemoryAgent(logger=self.logger)\n        self.working_memory_function = WorkingMemoryAgent.get_working_memory_function()\n",
            "name_column": 8
        },
        "register_agent_dispatcher": {
            "type": "FunctionDef",
            "name": "register_agent_dispatcher",
            "md_content": "**register_agent_dispatcher**\n\nparamXAgentParam\"register agent dispatcher\"XAgentDispatcherself.agent_dispatcherXAgentDispatcherparam.configenable=Falseself.loggerself.available_agents(agent)agent_dispatcher\n\n\nXAgent/core.py\n\n```python\ndef register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n    \"\"\"\n    register all components to the core components\n    \"\"\"\n    self.register_interaction(interaction)\n    self.register_logger()\n    self.resister_recorder(param)\n    self.register_toolserver_interface(param)\n    self.register_function_handler(param.config)\n    self.register_working_memory_function()\n    self.register_agent_dispatcher(param=param)\n    self.register_vector_db_interface()\n```\n\n****\n- register_agent_dispatcherregister_interactionregister_logger\n- ",
            "code_start_line": 171,
            "code_end_line": 180,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_agent_dispatcher(self, param: XAgentParam):\n        \"\"\"\n        register a agent dispatcher to the core components\n        \"\"\"\n        self.logger.info(\"register agent dispatcher\")\n        self.agent_dispatcher = XAgentDispatcher(param.config,\n                                                 enable=False,\n                                                 logger=self.logger)\n        for agent in self.available_agents:\n            self.agent_dispatcher.regist_agent(agent)\n",
            "name_column": 8
        },
        "register_vector_db_interface": {
            "type": "FunctionDef",
            "name": "register_vector_db_interface",
            "md_content": "**register_vector_db_interface**\n\npass\n\nXAgent/core.pyregister_allregister_allregister_vector_db_interface\n\n****register_vector_db_interface",
            "code_start_line": 182,
            "code_end_line": 187,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_vector_db_interface(self):\n        \"\"\"\n        register a vector db interface to the core components\n        \"\"\"\n        # self.vector_db_interface = VectorDBInterface()\n        pass\n",
            "name_column": 8
        },
        "register_all": {
            "type": "FunctionDef",
            "name": "register_all",
            "md_content": "**register_all**\n\nXAgent/core.pyregister_allbuildbuildregister_allself.register_interactioninteractionself.register_loggerself.resister_recorderself.register_toolserver_interfaceToolServerself.register_function_handlerself.register_working_memory_functionself.register_agent_dispatcherself.register_vector_db_interface\n\nregister_allinteractionToolServer\n\n****\n- register_allparaminteraction\n- register_allself.register_interactionself.register_loggerself.resister_recorderself.register_toolserver_interfaceself.register_function_handlerself.register_working_memory_functionself.register_agent_dispatcherself.register_vector_db_interface\n- register_allself.function_handlerself.working_memory_functionself.logger",
            "code_start_line": 189,
            "code_end_line": 200,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        register all components to the core components\n        \"\"\"\n        self.register_interaction(interaction)\n        self.register_logger()\n        self.resister_recorder(param)\n        self.register_toolserver_interface(param)\n        self.register_function_handler(param.config)\n        self.register_working_memory_function()\n        self.register_agent_dispatcher(param=param)\n        self.register_vector_db_interface()\n",
            "name_column": 8
        },
        "build": {
            "type": "FunctionDef",
            "name": "build",
            "md_content": "**build**\n\n`register_all`\"build all components, done!\"\n\n`function_handler``get_functions``subtask_functions``self.working_memory_function``self.tool_functions_description_list`\n\n****\n- `build``register_all`\n- `build``self.tool_functions_description_list`",
            "code_start_line": 202,
            "code_end_line": 211,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def build(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.register_all(param, interaction)\n        self.logger.info(\"build all components, done!\")\n\n        subtask_functions, self.tool_functions_description_list = self.function_handler.get_functions(\n            param.config)\n        self.function_list = subtask_functions + self.working_memory_function\n",
            "name_column": 8
        },
        "start": {
            "type": "FunctionDef",
            "name": "start",
            "md_content": "**start**\n\nstart all components\n\n****",
            "code_start_line": 213,
            "code_end_line": 217,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def start(self):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.logger.info(\"start all components\")\n",
            "name_column": 8
        },
        "close": {
            "type": "FunctionDef",
            "name": "close",
            "md_content": "**close**\n\n\n1. toolserver_interfacedownload_all_files\n2. toolserver_interfaceclose\n\n\nXAgentServer/server.py\n\n```python\ndef interact(self, interaction: XAgentInteraction):\n    # query = message\n    \"\"\"\n    XAgent Server Start Function\n    \"\"\"\n    from XAgent.config import CONFIG as config\n    xagent_core = None\n    try:\n        config.reload()\n        args = {}\n        # args\n        args = interaction.parameter.args\n\n        self.logger.info(\n            f\"server is running, the start query is {args.get('goal', '')}\")\n        xagent_param = XAgentParam()\n\n        # build query\n        xagent_param.build_query({\n            \"role_name\": \"Assistant\",\n            \"task\": args.get(\"goal\", \"\"),\n            \"plan\": args.get(\"plan\", [\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\"]),\n        })\n        xagent_param.build_config(config)\n        xagent_core = XAgentCoreComponents()\n        # build XAgent Core Components\n        xagent_core.build(xagent_param, interaction=interaction)\n        json_str = json.dumps(\n            xagent_param.config.to_dict(), indent=2)\n        json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n        self.logger.info(json_str)\n        self.logger.typewriter_log(\n            \"Human-In-The-Loop\",\n            Fore.RED,\n            str(xagent_param.config.enable_ask_human_for_help),\n        )\n\n        file_list = interaction.base.file_list\n        for file in file_list:\n            file_uuid = file.get(\"uuid\", \"\")\n            file_name = file.get(\"name\", \"\")\n            if file_uuid.startswith(\"/\"):\n                file_path = file_uuid\n            else:\n                file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\n                                         interaction.base.user_id, file_uuid)\n\n            upload_dir = os.path.join(\n                xagent_core.base_dir, \"upload\")\n            if not os.path.exists(upload_dir):\n                os.makedirs(upload_dir)\n            # workspace\n            if interaction.call_method == \"web\":\n                shutil.copy(file_path, os.path.join(upload_dir, file_name))\n            else:\n                if os.path.exists(file_path):\n                    if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\n                        # ,\n                        pass\n                    else:\n                        shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                    # shutil.copy(file_path, os.path.join(upload_dir, file_name))\n\n            new_file = os.path.join(upload_dir, file_name)\n            try:\n                xagent_core.toolserver_interface.upload_file(new_file)\n            except Exception as e:\n                self.logger.typewriter_log(\n                    \"Error happens when uploading file\",\n                    Fore.RED,\n                    f\"{new_file}\\n{e}\",\n                )\n                raise XAgentUploadFileError(str(e)) from e\n\n        task_handler = TaskHandler(xagent_core=xagent_core,\n                                   xagent_param=xagent_param)\n        self.logger.info(\"Start outer loop async\")\n        task_handler.outer_loop()\n    except Exception as e:\n        raise XAgentRunningError(str(e)) from e\n    finally:\n        if xagent_core is not None:\n            xagent_core.close()\n```\n\n****\n- closedownload_all_files\n- XAgent ServerinteractXAgent Server",
            "code_start_line": 219,
            "code_end_line": 224,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def close(self):\n        \"\"\"\n        close all components\n        \"\"\"\n        self.toolserver_interface.download_all_files()\n        self.toolserver_interface.close()\n",
            "name_column": 8
        },
        "print_task_save_items": {
            "type": "FunctionDef",
            "name": "print_task_save_items",
            "md_content": "**print_task_save_items**: \n\nTaskSaveItem\n\nlogger.typewriter_loglogger.typewriter_loglogger.typewriter_loglogger.typewriter_loglogger.typewriter_log\n\nlogger.typewriter_log\n\n****: TaskSaveItem",
            "code_start_line": 226,
            "code_end_line": 275,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def print_task_save_items(self,\n                              item: TaskSaveItem,\n                              ) -> None:\n\n        self.logger.typewriter_log(\n            f\"Task Name:\", Fore.YELLOW, f\"{item.name}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Goal:\", Fore.YELLOW, f\"{item.goal}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Prior-Criticism:\", Fore.YELLOW, f\"{item.prior_plan_criticism}\"\n        )\n        if len(item.posterior_plan_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Task Posterior-Criticism:\", Fore.YELLOW\n            )\n            for line in item.posterior_plan_reflection:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.milestones) > 0:\n            self.logger.typewriter_log(\n                f\"Task Milestones:\", Fore.YELLOW,\n            )\n            for line in item.milestones:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        # if len(item.expected_tools) > 0:\n        #     logger.typewriter_log(\n        #         f\"Expected Tools:\", Fore.YELLOW,\n        #     )\n        #     for line in item.expected_tools:\n        #         line = f\"{line['tool_name']}: {line['reason']}\".lstrip(\"- \")\n        #         logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.tool_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Posterior Tool Reflections:\", Fore.YELLOW,\n            )\n            for line in item.tool_reflection:\n                line = f\"{line['target_tool_name']}: {line['reflection']}\".lstrip(\n                    \"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        self.logger.typewriter_log(\n            f\"Task Status:\", Fore.YELLOW, f\"{item.status.name}\"\n        )\n        if item.action_list_summary != \"\":\n            self.logger.typewriter_log(\n                f\"Action Summary:\", Fore.YELLOW, f\"{item.action_list_summary}\"\n            )\n",
            "name_column": 8
        },
        "print_assistant_thoughts": {
            "type": "FunctionDef",
            "name": "print_assistant_thoughts",
            "md_content": "**print_assistant_thoughts**\n\nassistant_reply_json_validJSONspeak_modeFalse\n\nassistant_thoughts_reasoningassistant_thoughts_planassistant_thoughts_speakassistant_thoughts_criticismNone\n\nassistant_reply_json_validassistant_thoughtsassistant_thoughtsassistant_thoughts_reasoningassistant_thoughts_planassistant_thoughts_criticism\n\nassistant_thoughts_textNonelogger.typewriter_log\"THOUGHTS\"\n\nassistant_thoughts_reasoningNonelogger.typewriter_log\"REASONING\"\n\nassistant_thoughts_planNone0logger.typewriter_log\"PLAN\"assistant_thoughts_planlogger.typewriter_log\n\nassistant_thoughts_criticismNonelogger.typewriter_log\"CRITICISM\"\n\nnode_id\n\n****logger.typewriter_logassistant_reply_json_valid\n\n****\"\"\"\"[\"1\", \"2\"]\"\"\n{\n  \"thoughts\": \"\",\n  \"reasoning\": \"\",\n  \"plan\": \"1\\n2\",\n  \"criticism\": \"\",\n  \"node_id\": \"node_id\"\n}",
            "code_start_line": 277,
            "code_end_line": 326,
            "parent": "XAgentCoreComponents",
            "have_return": true,
            "code_content": "    def print_assistant_thoughts(\n        self,\n        # ai_name: object,\n        assistant_reply_json_valid: object,\n        speak_mode: bool = False,\n    ) -> None:\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = assistant_reply_json_valid.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n        if assistant_thoughts_text is not None and assistant_thoughts_text != \"\":\n            self.logger.typewriter_log(\n                f\"THOUGHTS:\", Fore.YELLOW, f\"{assistant_thoughts_text}\"\n            )\n        if assistant_thoughts_reasoning is not None and assistant_thoughts_reasoning != \"\":\n            self.logger.typewriter_log(\n                \"REASONING:\", Fore.YELLOW, f\"{assistant_thoughts_reasoning}\")\n\n        if assistant_thoughts_plan is not None and len(assistant_thoughts_plan) > 0:\n            self.logger.typewriter_log(\"PLAN:\", Fore.YELLOW, \"\")\n            # If it's a list, join it into a string\n            if isinstance(assistant_thoughts_plan, list):\n                assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n            elif isinstance(assistant_thoughts_plan, dict):\n                assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n            # Split the input_string using the newline character and dashes\n            lines = assistant_thoughts_plan.split(\"\\n\")\n            for line in lines:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        if assistant_thoughts_criticism is not None and assistant_thoughts_criticism != \"\":\n            self.logger.typewriter_log(\n                \"CRITICISM:\", Fore.YELLOW, f\"{assistant_thoughts_criticism}\")\n        return {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism,\n            \"node_id\": uuid.uuid4().hex\n        }\n",
            "name_column": 8
        }
    },
    "XAgent/vector_db.py": {
        "VectorDBInterface": {
            "type": "ClassDef",
            "name": "VectorDBInterface",
            "md_content": "**VectorDBInterface**: Pinecone API\n\n\n- task_index: Pinecone\n- turbo_keys: \n- vector_count: \n\n**__init__**: VectorDBInterface\n\nPinecone APIPinecone\n\n**get_keys**: \n\nturbo_keys\n\n**get_info**: \n\nvector_count\n\n**generate_embedding**: \n\nOpenAI API\n\n**delete_sentence**: \n\n\n\n**insert_sentence**: \n\n\n\n**search_similar_sentences**: \n\n\n\n****: PineconeOpenAIPythonAPI\n\n****:\n```\n{\n    \"total_vector_count\": 1000,\n    \"dimension\": 512\n}\nVector Dim 512\nVector Number 1000\n```",
            "code_start_line": 7,
            "code_end_line": 187,
            "parent": null,
            "have_return": true,
            "code_content": "class VectorDBInterface():\n    \"\"\"\n    A class for managing vector databases using the Pinecone API.\n\n    Attributes:\n    task_index : object\n        A Pinecone index object that represents the vector database.\n    turbo_keys : list\n        A list of secret keys used to validate the connection with the database.\n    vector_count : int\n        The number of vectors present in the database.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        The constructor for VectorDBInterface class.\n\n        \"\"\"\n\n        pinecone.init(api_key=\"{API_KEY}\", environment=\"{ENV}\")\n        self.task_index = pinecone.Index(\"{INDEX}\")\n\n        self.get_info()\n        self.get_keys()\n        \n    def get_keys(self):\n        \"\"\"\n        The function to get the secret keys.\n\n        Retrieves the secret keys from the pool and store them in the list turbo_keys.\n\n        \"\"\"\n\n        self.turbo_keys = []\n        lines = pool.split(\"\\n\")\n        for line in lines:\n            striped = line.strip()\n            if striped == \"\":\n                continue\n            contents = striped.split(\"|\")\n            for cont in contents:\n                if cont.startswith(\"sk-\"):\n                    self.turbo_keys.append(cont)\n    \n    def get_info(self):\n        \"\"\"\n        The function to get the information about the database.\n\n        Retrieves the statistics of the database such as total vector count and dimension, \n        and store the total vector count in the vector_count attribute.\n\n        Raises:\n        Exception: An error occured accessing the database.\n\n        \"\"\"\n        \n        try:\n            info = self.task_index.describe_index_stats()\n            self.vector_count = info[\"total_vector_count\"]\n            dimension = info['dimension']\n            print(info)\n            print(\"Vector Dim\", dimension)\n            print(\"Vector Number\", self.vector_count)\n        except:\n            print(\"Warning: Failed to obtain vector information\")\n\n\n    def generate_embedding(self, text:str):\n        \"\"\"\n        The function to generate an embedding for the input text.\n\n        Args:\n        text (str): The input text.\n\n        Returns:\n        list: The embedding of the input text.\n\n        \"\"\"\n        \n        url = \"https://api.openai.com/v1/embeddings\"\n        payload = {\n            \"model\": \"text-embedding-ada-002\",\n            \"input\": text\n        }\n        for key in self.turbo_keys:\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": f\"Bearer {key}\"\n            }\n            response = requests.post(url, json=payload, headers=headers, timeout=10)\n            try:\n                res = json.loads(response.text)\n                embedding = res['data'][0]['embedding']\n                return embedding\n            except:\n                pass\n\n    def delete_sentence(self, sentence:str):\n        \"\"\"\n        The function to delete a sentence from the database.\n\n        Args:\n        sentence (str): The sentence to be deleted.\n\n        Raises:\n        Exception: An error occured deleting the sentence.\n\n        \"\"\"\n        \n        try:\n            self.task_index.delete(sentence)\n            print(\"Success delete sentence:\", sentence)\n        except:\n            print(\"Warning: Fail to delete sentence\", sentence)\n\n    def insert_sentence(self, vec_sentence:str, sentence:str, namespace=\"\"):\n        \"\"\"\n        The function to insert a sentence with its embedding into the database.\n\n        Args:\n        vec_sentence (str): The sentence to generate the embedding.\n        sentence (str): The sentence to be inserted.\n        namespace (str, optional): The namespace of the vector. Defaults to \"\".\n\n        Raises:\n        Exception: An error occured inserting the sentence.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(vec_sentence)\n        if embedding:\n            try:\n                self.task_index.upsert(\n                    [(str(self.vector_count),\n                    embedding,\n                    {\"text\":sentence, \"type\":namespace})],\n                )\n                self.vector_count += 1\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to insert\", sentence)\n        else:\n            print(\"Warning: Failed to generate embedding for \", sentence)\n\n    def search_similar_sentences(self, query_sentence:str, namespace=\"\", top_k=1):\n        \"\"\"\n        The function to search the database for sentences similar to the query sentence.\n\n        Args:\n        query_sentence (str): The query sentence.\n        namespace (str, optional): The namespace of the vectors. Defaults to \"\".\n        top_k (int, optional): The number of most similar sentences to return. \n            Defaults to 1.\n\n        Returns:\n        object: The most similar sentences.\n\n        Raises:\n        Exception: An error occured searching the database.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(query_sentence)\n        if embedding:\n            try:\n                res = self.task_index.query(\n                    embedding,\n                    top_k=top_k,\n                    include_metadata=True,\n                    include_values=False,\n                    filter={\n                        \"type\": {\"$eq\": namespace},\n                    },)\n                print(res)\n                return res\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to search similar sentences\")\n        else:\n            print(\"Warning: Fail to generate embedding\")\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**VectorDBInterface\n\npinecone.init()PineconeAPI_KEYENVpinecone.IndexPineconeINDEX\n\nself.get_info()self.get_keys()\n\n****\n- \"{API_KEY}\"\"{ENV}\"\"{INDEX}\"\n- pinecone.init()Pinecone",
            "code_start_line": 21,
            "code_end_line": 31,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"\n        The constructor for VectorDBInterface class.\n\n        \"\"\"\n\n        pinecone.init(api_key=\"{API_KEY}\", environment=\"{ENV}\")\n        self.task_index = pinecone.Index(\"{INDEX}\")\n\n        self.get_info()\n        self.get_keys()\n",
            "name_column": 8
        },
        "get_keys": {
            "type": "FunctionDef",
            "name": "get_keys",
            "md_content": "**get_keys**\n\nturbo_keys\n\npoollineslinesstripedstripedstriped\"|\"contentscontentscontcont\"sk-\"contturbo_keys\n\n****\n- get_info\n- pinecone.initpinecone\n- pinecone.Index",
            "code_start_line": 33,
            "code_end_line": 50,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def get_keys(self):\n        \"\"\"\n        The function to get the secret keys.\n\n        Retrieves the secret keys from the pool and store them in the list turbo_keys.\n\n        \"\"\"\n\n        self.turbo_keys = []\n        lines = pool.split(\"\\n\")\n        for line in lines:\n            striped = line.strip()\n            if striped == \"\":\n                continue\n            contents = striped.split(\"|\")\n            for cont in contents:\n                if cont.startswith(\"sk-\"):\n                    self.turbo_keys.append(cont)\n",
            "name_column": 8
        },
        "get_info": {
            "type": "FunctionDef",
            "name": "get_info",
            "md_content": "**get_info**\n\nvector_count\n\n****\n- `self.task_index.describe_index_stats()``info`\n- `info[\"total_vector_count\"]``self.vector_count`\n- `info['dimension']``dimension`\n- `info``dimension``self.vector_count`\n\n****\n- \n- \n\n\nXAgent/vector_db.py\n\n```python\ndef __init__(self):\n    \"\"\"\n    VectorDBInterface\n    \"\"\"\n    pinecone.init(api_key=\"{API_KEY}\", environment=\"{ENV}\")\n    self.task_index = pinecone.Index(\"{INDEX}\")\n\n    self.get_info()\n    self.get_keys()\n```\n\n[]\n[XAgent/vector_db.py]",
            "code_start_line": 52,
            "code_end_line": 72,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def get_info(self):\n        \"\"\"\n        The function to get the information about the database.\n\n        Retrieves the statistics of the database such as total vector count and dimension, \n        and store the total vector count in the vector_count attribute.\n\n        Raises:\n        Exception: An error occured accessing the database.\n\n        \"\"\"\n        \n        try:\n            info = self.task_index.describe_index_stats()\n            self.vector_count = info[\"total_vector_count\"]\n            dimension = info['dimension']\n            print(info)\n            print(\"Vector Dim\", dimension)\n            print(\"Vector Number\", self.vector_count)\n        except:\n            print(\"Warning: Failed to obtain vector information\")\n",
            "name_column": 8
        },
        "generate_embedding": {
            "type": "FunctionDef",
            "name": "generate_embedding",
            "md_content": "**generate_embedding**\n\n\n\n\n\n\n\n```python\ndef generate_embedding(self, text:str):\n    \"\"\"\n    The function to generate an embedding for the input text.\n\n    Args:\n    text (str): The input text.\n\n    Returns:\n    list: The embedding of the input text.\n\n    \"\"\"\n    \n    url = \"https://api.openai.com/v1/embeddings\"\n    payload = {\n        \"model\": \"text-embedding-ada-002\",\n        \"input\": text\n    }\n    for key in self.turbo_keys:\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {key}\"\n        }\n        response = requests.post(url, json=payload, headers=headers, timeout=10)\n        try:\n            res = json.loads(response.text)\n            embedding = res['data'][0]['embedding']\n            return embedding\n        except:\n            pass\n```\n\n**generate_embedding**OpenAI APIAPIURLpayloadURL\"https://api.openai.com/v1/embeddings\"payloadself.turbo_keysAPIrequestsAPIPOSTContent-TypeAuthorizationAPIJSON\n\n****APIself.turbo_keys\n\n****\"Hello, world!\"[0.123, 0.456, 0.789]",
            "code_start_line": 75,
            "code_end_line": 103,
            "parent": "VectorDBInterface",
            "have_return": true,
            "code_content": "    def generate_embedding(self, text:str):\n        \"\"\"\n        The function to generate an embedding for the input text.\n\n        Args:\n        text (str): The input text.\n\n        Returns:\n        list: The embedding of the input text.\n\n        \"\"\"\n        \n        url = \"https://api.openai.com/v1/embeddings\"\n        payload = {\n            \"model\": \"text-embedding-ada-002\",\n            \"input\": text\n        }\n        for key in self.turbo_keys:\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": f\"Bearer {key}\"\n            }\n            response = requests.post(url, json=payload, headers=headers, timeout=10)\n            try:\n                res = json.loads(response.text)\n                embedding = res['data'][0]['embedding']\n                return embedding\n            except:\n                pass\n",
            "name_column": 8
        },
        "delete_sentence": {
            "type": "FunctionDef",
            "name": "delete_sentence",
            "md_content": "**delete_sentence**\n\n\n- sentence (str): \n\n\n- Exception: \n\nself.task_index.delete()\"Success delete sentence:\"\"Warning: Fail to delete sentence\"\n\n****\n- \n- ",
            "code_start_line": 105,
            "code_end_line": 121,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def delete_sentence(self, sentence:str):\n        \"\"\"\n        The function to delete a sentence from the database.\n\n        Args:\n        sentence (str): The sentence to be deleted.\n\n        Raises:\n        Exception: An error occured deleting the sentence.\n\n        \"\"\"\n        \n        try:\n            self.task_index.delete(sentence)\n            print(\"Success delete sentence:\", sentence)\n        except:\n            print(\"Warning: Fail to delete sentence\", sentence)\n",
            "name_column": 8
        },
        "insert_sentence": {
            "type": "FunctionDef",
            "name": "insert_sentence",
            "md_content": "**insert_sentence**: \n\n\n- vec_sentence (str): \n- sentence (str): \n- namespace (str, ): \n\n\n- Exception: \n\ngenerate_embeddingtask_indexupsertvector_count1\n\n****: \n- vec_sentence\n- sentence\n- namespace",
            "code_start_line": 123,
            "code_end_line": 150,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def insert_sentence(self, vec_sentence:str, sentence:str, namespace=\"\"):\n        \"\"\"\n        The function to insert a sentence with its embedding into the database.\n\n        Args:\n        vec_sentence (str): The sentence to generate the embedding.\n        sentence (str): The sentence to be inserted.\n        namespace (str, optional): The namespace of the vector. Defaults to \"\".\n\n        Raises:\n        Exception: An error occured inserting the sentence.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(vec_sentence)\n        if embedding:\n            try:\n                self.task_index.upsert(\n                    [(str(self.vector_count),\n                    embedding,\n                    {\"text\":sentence, \"type\":namespace})],\n                )\n                self.vector_count += 1\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to insert\", sentence)\n        else:\n            print(\"Warning: Failed to generate embedding for \", sentence)\n",
            "name_column": 8
        },
        "search_similar_sentences": {
            "type": "FunctionDef",
            "name": "search_similar_sentences",
            "md_content": "**search_similar_sentences**\n\n\n- query_sentence (str)\n- namespace (str, )\n- top_k (int, )1\n\n\n- object\n\n\n- Exception\n\ngenerate_embeddingtask_indexquery\n\n\"Warning: Fail to generate embedding\"\n\n\"Warning: Fail to search similar sentences\"\n\n****\n\n****",
            "code_start_line": 152,
            "code_end_line": 187,
            "parent": "VectorDBInterface",
            "have_return": true,
            "code_content": "    def search_similar_sentences(self, query_sentence:str, namespace=\"\", top_k=1):\n        \"\"\"\n        The function to search the database for sentences similar to the query sentence.\n\n        Args:\n        query_sentence (str): The query sentence.\n        namespace (str, optional): The namespace of the vectors. Defaults to \"\".\n        top_k (int, optional): The number of most similar sentences to return. \n            Defaults to 1.\n\n        Returns:\n        object: The most similar sentences.\n\n        Raises:\n        Exception: An error occured searching the database.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(query_sentence)\n        if embedding:\n            try:\n                res = self.task_index.query(\n                    embedding,\n                    top_k=top_k,\n                    include_metadata=True,\n                    include_values=False,\n                    filter={\n                        \"type\": {\"$eq\": namespace},\n                    },)\n                print(res)\n                return res\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to search similar sentences\")\n        else:\n            print(\"Warning: Fail to generate embedding\")\n",
            "name_column": 8
        }
    },
    "XAgent/utils.py": {
        "get_token_nums": {
            "type": "FunctionDef",
            "name": "get_token_nums",
            "md_content": "**get_token_nums**: \n\ntext\n\n\n\n\n- encoding.encode\n- len\n\n\n- encodingencode\n- text\n\n\ntext\"Hello, world!\"3",
            "code_start_line": 16,
            "code_end_line": 26,
            "parent": null,
            "have_return": true,
            "code_content": "def get_token_nums(text:str)->int:\n    \"\"\"\n    Calculate the number of tokens in the given text.\n    \n    Args:\n        text (str): The text whose tokens need to be counted.\n        \n    Returns:\n        int: The number of tokens in the text.\n    \"\"\"\n    return len(encoding.encode(text))\n",
            "name_column": 4
        },
        "clip_text": {
            "type": "FunctionDef",
            "name": "clip_text",
            "md_content": "**clip_text**clip_text\"`wrapped`\"\n\n\n- text (str)\n- max_tokens (int, )\n- clip_end (bool, )TrueFalse\n\n\n\n\n- XAgent/agent/summarize.py\n- XAgent/inner_loop_search_algorithms/ReACT.py\n- XAgent/workflow/plan_exec.py\n\nXAgent/agent/summarize.pygenerate_func_args\n\nXAgent/inner_loop_search_algorithms/ReACT.pygenerate_chain\n\nXAgent/workflow/plan_exec.pyplan_refine_mode\n\n\n- ",
            "code_start_line": 28,
            "code_end_line": 45,
            "parent": null,
            "have_return": true,
            "code_content": "def clip_text(text:str,max_tokens:int=None,clip_end=False)->str|int:\n    \"\"\"\n    Truncate the given text to the specified number of tokens.\n    If the original text and the clipped text are not of the same length, '`wrapped`' is added to the beginning or the end of the clipped text.\n    \n    Args:\n        text (str): The text to be clipped.\n        max_tokens (int, optional): Maximum number of tokens. The text will be clipped to contain not more than this number of tokens.\n        clip_end (bool, optional): If True, text will be clipped from the end. If False, text will be clipped from the beginning.\n        \n    Returns:\n        str, int: The clipped text, and the total number of tokens in the original text.\n    \"\"\"\n    encoded = encoding.encode(text)\n    decoded = encoding.decode(encoded[:max_tokens] if clip_end else encoded[-max_tokens:])\n    if len(decoded) != len(text):\n        decoded = decoded + '`wrapped`' if clip_end else '`wrapped`' + decoded\n    return decoded, len(encoded)\n",
            "name_column": 4
        },
        "LLMStatusCode": {
            "type": "ClassDef",
            "name": "LLMStatusCode",
            "md_content": "**LLMStatusCode**LLM\n\n\n- SUCCESS0\n- ERROR1\n\n\n\n****LLMStatusCode.SUCCESSLLMStatusCode.ERROR",
            "code_start_line": 48,
            "code_end_line": 51,
            "parent": null,
            "have_return": false,
            "code_content": "class LLMStatusCode(Enum):\n    \"\"\"Enumeration describing different status codes for LLM.\"\"\"\n    SUCCESS = 0\n    ERROR = 1\n",
            "name_column": 6
        },
        "ToolCallStatusCode": {
            "type": "ClassDef",
            "name": "ToolCallStatusCode",
            "md_content": "**ToolCallStatusCode**\n\nToolCallStatusCode\n\n\n- TOOL_CALL_FAILED\n- TOOL_CALL_SUCCESS\n- FORMAT_ERROR\n- HALLUCINATE_NAME\n- OTHER_ERROR\n- TIMEOUT_ERROR\n- TIME_LIMIT_EXCEEDED\n- SERVER_ERROR\n- SUBMIT_AS_SUCCESS\n- SUBMIT_AS_FAILED\n\n__str__\n\n****\n- ToolCallStatusCode.TOOL_CALL_FAILED\n- str()\n\n****\nToolCallStatusCode: TOOL_CALL_FAILED",
            "code_start_line": 54,
            "code_end_line": 82,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolCallStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for tool calls.\n    \n    The status codes are:\n    - TOOL_CALL_FAILED\n    - TOOL_CALL_SUCCESS\n    - FORMAT_ERROR\n    - HALLUCINATE_NAME\n    - OTHER_ERROR\n    - TIMEOUT_ERROR\n    - TIME_LIMIT_EXCEEDED\n    - SERVER_ERROR\n    - SUBMIT_AS_SUCCESS\n    - SUBMIT_AS_FAILED\n    \"\"\"\n    TOOL_CALL_FAILED = -1\n    TOOL_CALL_SUCCESS = 0\n    FORMAT_ERROR = 1\n    HALLUCINATE_NAME = 2 \n    OTHER_ERROR = 3 \n    TIMEOUT_ERROR = 4\n    TIME_LIMIT_EXCEEDED = 5\n    SERVER_ERROR = 6\n    \n    SUBMIT_AS_SUCCESS = 7\n    SUBMIT_AS_FAILED = 8\n    def __str__(self):\n        return self.__class__.__name__ + \": \" + self.name\n",
            "name_column": 6
        },
        "PlanOperationStatusCode": {
            "type": "ClassDef",
            "name": "PlanOperationStatusCode",
            "md_content": "**PlanOperationStatusCode**\n\n\n\n- MODIFY_SUCCESS\n- MODIFY_FORMER_PLAN\n- PLAN_OPERATION_NOT_FOUND\n- TARGET_SUBTASK_NOT_FOUND\n- PLAN_REFINE_EXIT\n- OTHER_ERROR\n\n****",
            "code_start_line": 85,
            "code_end_line": 94,
            "parent": null,
            "have_return": false,
            "code_content": "class PlanOperationStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for plan operations. \n    \"\"\"\n    MODIFY_SUCCESS = 0\n    MODIFY_FORMER_PLAN = 1\n    PLAN_OPERATION_NOT_FOUND = 2\n    TARGET_SUBTASK_NOT_FOUND = 3\n    PLAN_REFINE_EXIT = 4\n    OTHER_ERROR = 5\n",
            "name_column": 6
        },
        "SearchMethodStatusCode": {
            "type": "ClassDef",
            "name": "SearchMethodStatusCode",
            "md_content": "**SearchMethodStatusCode**: \n\n\n- DOING\n- SUCCESS\n- FAIL\n- HAVE_AT_LEAST_ONE_ANSWER\n\n\n\n\n- XAgent/inner_loop_search_algorithms/ReACT.pyrunSUCCESSFAIL\n- XAgent/inner_loop_search_algorithms/base_search.py\n- XAgent/workflow/task_handler.pyinner_loopSUCCESSFAIL\n\n****: ",
            "code_start_line": 97,
            "code_end_line": 104,
            "parent": null,
            "have_return": false,
            "code_content": "class SearchMethodStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for search methods.\n    \"\"\"\n    DOING = 0\n    SUCCESS = 1\n    FAIL = 2\n    HAVE_AT_LEAST_ONE_ANSWER = 3 \n",
            "name_column": 6
        },
        "TaskStatusCode": {
            "type": "ClassDef",
            "name": "TaskStatusCode",
            "md_content": "**TaskStatusCode**: \n\n\n- TODO\n- DOING\n- SUCCESS\n- FAIL\n- SPLIT\n\n\n\n****: \n- \n- ",
            "code_start_line": 107,
            "code_end_line": 115,
            "parent": null,
            "have_return": false,
            "code_content": "class TaskStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for tasks.\n    \"\"\"\n    TODO = 0\n    DOING = 1\n    SUCCESS = 2\n    FAIL = 3\n    SPLIT = 4 \n",
            "name_column": 6
        },
        "RequiredAbilities": {
            "type": "ClassDef",
            "name": "RequiredAbilities",
            "md_content": "**RequiredAbilities**\n\n\n- tool_tree_search0\n- plan_generation1\n- plan_refinement2\n- task_evaluator3\n- summarization4\n- reflection5\n\n****\n- \n- \n- ",
            "code_start_line": 118,
            "code_end_line": 127,
            "parent": null,
            "have_return": false,
            "code_content": "class RequiredAbilities(Enum):\n    \"\"\"\n    Enumeration descsribing different abilities required.\n    \"\"\"\n    tool_tree_search = 0\n    plan_generation = 1\n    plan_refinement = 2\n    task_evaluator = 3\n    summarization = 4\n    reflection = 5\n",
            "name_column": 6
        },
        "AgentRole": {
            "type": "ClassDef",
            "name": "AgentRole",
            "md_content": "**AgentRole**: ChatGPT\n\n****:\n- name (str): \n- prefix (str): \n\n**AgentRole**: ChatGPT\n\n****:\nAgentRoleChatGPTnameprefix\n\n- name\"Auto-GPT\"\n- prefix\"You are an expert of using multiple tools to handle diverse real-world user queries.\"\n\n\n\n****: AgentRolenameprefix",
            "code_start_line": 130,
            "code_end_line": 139,
            "parent": null,
            "have_return": false,
            "code_content": "class AgentRole:\n    \"\"\"\n    This class represents the role of a ChatGPT agent in a conversation.\n\n    Attributes:\n        name (str): The name of the agent.\n        prefix (str): The description of agent's role.\n    \"\"\"\n    name: str = \"Auto-GPT\"\n    prefix: str = \"You are an expert of using multiple tools to handle diverse real-world user queries.\"\n",
            "name_column": 6
        },
        "TaskSaveItem": {
            "type": "ClassDef",
            "name": "TaskSaveItem",
            "md_content": "**TaskSaveItem**\n\n****\n- name (str): \n- goal (str): \n- milestones (List[str]): \n- prior_plan_criticism (str): \n- status (TaskStatusCode): \n- action_list_summary (str): \n- posterior_plan_reflection (List[str]): \n- tool_reflection (List[Dict[str,str]]): \n\n**load_from_json**json\n- \n  - function_output_item: json\n- \n- json\n\n**to_json**json\n- \n  - posterior (bool): False\n- json\n- json\n\n**raw**json\n- json\n\n**print_task_save_items**\n- \n  - item: TaskSaveItem\n- \n- \n\n**plan_function_output_parser**Plan\n- \n  - function_output_item: \n- Plan\n- Plan\n\n**PlanAgent**\n- \n  - config: \n  - query (BaseQuery): \n  - avaliable_tools_description_list (List[dict]): \n- ",
            "code_start_line": 143,
            "code_end_line": 223,
            "parent": null,
            "have_return": true,
            "code_content": "class TaskSaveItem:\n    \"\"\"\n    This class represents the structure of saved tasks.\n    \n    Attributes:\n        name (str): The name of the task.\n        goal (str): The objective of the task.\n        milestones (List[str]): The steps involved to achieve the task.\n        prior_plan_criticism (str): Any criticism on the initial plan of the task.\n        status (TaskStatusCode): The current status of the task.\n        action_list_summary (str): A summary of all the actions done to achieve the task.\n        posterior_plan_reflection (List[str]): A list containing reflection of the finally decided plan.\n        tool_reflection (List[Dict[str,str]]): A list of dictionaries where each dictionary holds reflection of a tool.\n    \"\"\"\n    \n    name: str = \"\"\n    goal: str = \"\"\n    milestones: List[str] = field(default_factory=lambda: [])\n    prior_plan_criticism: str = \"\"\n    status: TaskStatusCode = TaskStatusCode.TODO\n    action_list_summary: str = \"\"\n    posterior_plan_reflection: List[str] = field(default_factory=lambda: [])\n    tool_reflection: List[Dict[str,str]] = field(default_factory=lambda: [])\n\n    def load_from_json(self, function_output_item):\n        \"\"\"Load data from the json representation\"\"\"\n        if \"subtask name\" in function_output_item.keys():\n            self.name = function_output_item[\"subtask name\"]\n        else:\n            print(f\"field subtask name not exist\")\n            \n        if \"goal\" in function_output_item.keys() and \"goal\" in function_output_item[\"goal\"].keys():\n            self.goal=function_output_item[\"goal\"][\"goal\"]\n        else:\n            print(f\"field goal.goal not exist\")\n\n        if \"goal\" in function_output_item.keys() and \"criticism\" in function_output_item[\"goal\"].keys():\n            self.prior_plan_criticism=function_output_item[\"goal\"][\"criticism\"]\n        else:\n            print(f\"field goal.criticism not exist\")\n        \n        # if \"handler\" in function_output_item.keys():\n        #     self.handler=function_output_item[\"handler\"]\n        # else:\n        #     print(f\"field handler not exist\")\n\n        # if \"tool_budget\" in function_output_item.keys():\n        #     self.tool_budget=function_output_item[\"tool_budget\"]\n        # else:\n        #     print(f\"field tool_budget not exist\")\n\n        if \"milestones\" in function_output_item.keys():\n            self.milestones = function_output_item[\"milestones\"]\n        # if \"expected_tools\" in function_output_item.keys():\n        #     self.expected_tools = function_output_item[\"expected_tools\"]\n\n    def to_json(self, posterior=False):\n        \"\"\"Convert the object to json representation.\"\"\"\n        json_data = {\n            \"name\": self.name,\n            \"goal\": self.goal,\n            # \"handler\": self.handler,\n            # \"tool_budget\": self.tool_budget,\n            \"prior_plan_criticsim\": self.prior_plan_criticism,\n            \"milestones\": self.milestones,\n            # \"expected_tools\": self.expected_tools,\n            \"exceute_status\": self.status.name,\n        }\n        if posterior:\n            if self.action_list_summary != \"\":\n                json_data[\"action_list_summary\"] =  self.action_list_summary\n            # if self.posterior_plan_reflection != []:\n            #     json_data[\"posterior_plan_reflection\"] = self.posterior_plan_reflection\n            # if self.tool_reflection != []:\n            #     json_data[\"tool_reflection\"] = self.tool_reflection\n        return json_data\n\n    @property\n    def raw(self) -> str:\n        \"\"\"Convert the object to a raw json string\"\"\"\n        return json.dumps(self.to_json(posterior=True), indent=2, ensure_ascii=False)\n",
            "name_column": 6
        },
        "Singleton": {
            "type": "ClassDef",
            "name": "Singleton",
            "md_content": "**Singleton**: \n\nSingleton`abc.ABCMeta``type``_instances``_instances`\n\nSingleton\n\n****: Singleton:\n- Singleton\n- Singleton`metaclass`\n\n****:\n```\nclass Logger(metaclass=Singleton):\n    # Logger\n    ...\n```\n\n```\nclass AbstractSingleton(abc.ABC, metaclass=Singleton):\n    # AbstractSingleton\n    ...\n```",
            "code_start_line": 227,
            "code_end_line": 238,
            "parent": null,
            "have_return": true,
            "code_content": "class Singleton(abc.ABCMeta, type):\n    \"\"\"\n    Singleton metaclass for ensuring only one instance of a class.\n    \"\"\"\n\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"Call method for the singleton metaclass.\"\"\"\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n",
            "name_column": 6
        },
        "AbstractSingleton": {
            "type": "ClassDef",
            "name": "AbstractSingleton",
            "md_content": "**AbstractSingleton**: \n\n\n\n****:\nAbstractSingletonABCmetaclassSingletonSingletonAbstractSingleton\n\nAbstractSingletonabc.ABC\n\nAbstractSingletonmetaclass=SingletonSingletonSingletonAbstractSingletonAbstractSingletonSingletonAbstractSingleton\n\n****: AbstractSingleton",
            "code_start_line": 240,
            "code_end_line": 245,
            "parent": null,
            "have_return": false,
            "code_content": "class AbstractSingleton(abc.ABC, metaclass=Singleton):\n    \"\"\"\n    An abstract Singleton base class. Classes that inherit from this class can have only one instance.\n\n    Implements mechanism to ensure that only one instance of the class exists by using a metaclass.\n    \"\"\"",
            "name_column": 6
        },
        "__str__": {
            "type": "FunctionDef",
            "name": "__str__",
            "md_content": "**__str__**\n\nPythonprintstr()__str__\n\n__str__self.__class__.__name__\n\n****\n\n****ToolServer: toolserver1",
            "code_start_line": 81,
            "code_end_line": 82,
            "parent": "ToolCallStatusCode",
            "have_return": true,
            "code_content": "    def __str__(self):\n        return self.__class__.__name__ + \": \" + self.name\n",
            "name_column": 8
        },
        "load_from_json": {
            "type": "FunctionDef",
            "name": "load_from_json",
            "md_content": "**load_from_json**: json\n\nfunction_output_itemfunction_output_item\"subtask name\"self.name\"field subtask name not exist\"function_output_item\"goal\"\"goal\"\"goal\"self.goal\"field goal.goal not exist\"function_output_item\"goal\"\"goal\"\"criticism\"self.prior_plan_criticism\"field goal.criticism not exist\"function_output_item\"milestones\"self.milestones\n\n****: \n- function_output_item\n- function_output_item\n- function_output_item\n\n\nXAgent/workflow/plan_exec.py\n\n```python\ndef plan_function_output_parser(function_output_item: dict) -> Plan:\n    \"\"\"Plan\n\n    Args:\n        function_output_item (dict): \n\n    Returns:\n        Plan: Plan\n    \"\"\"\n    subtask_node = TaskSaveItem()\n    subtask_node.load_from_json(function_output_item=function_output_item)\n    subplan = Plan(subtask_node)\n    return subplan\n```\nload_from_jsonfunction_output_itemTaskSaveItemload_from_jsonPlan\n\ndeal_subtask_modifyload_from_jsondeal_subtask_modifyload_from_jsonfunction_inputnew_data\n\n****: load_from_jsonfunction_output_item",
            "code_start_line": 167,
            "code_end_line": 195,
            "parent": "TaskSaveItem",
            "have_return": false,
            "code_content": "    def load_from_json(self, function_output_item):\n        \"\"\"Load data from the json representation\"\"\"\n        if \"subtask name\" in function_output_item.keys():\n            self.name = function_output_item[\"subtask name\"]\n        else:\n            print(f\"field subtask name not exist\")\n            \n        if \"goal\" in function_output_item.keys() and \"goal\" in function_output_item[\"goal\"].keys():\n            self.goal=function_output_item[\"goal\"][\"goal\"]\n        else:\n            print(f\"field goal.goal not exist\")\n\n        if \"goal\" in function_output_item.keys() and \"criticism\" in function_output_item[\"goal\"].keys():\n            self.prior_plan_criticism=function_output_item[\"goal\"][\"criticism\"]\n        else:\n            print(f\"field goal.criticism not exist\")\n        \n        # if \"handler\" in function_output_item.keys():\n        #     self.handler=function_output_item[\"handler\"]\n        # else:\n        #     print(f\"field handler not exist\")\n\n        # if \"tool_budget\" in function_output_item.keys():\n        #     self.tool_budget=function_output_item[\"tool_budget\"]\n        # else:\n        #     print(f\"field tool_budget not exist\")\n\n        if \"milestones\" in function_output_item.keys():\n            self.milestones = function_output_item[\"milestones\"]\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**json\n\nposteriorjson_data\"name\"\"goal\"\"prior_plan_criticsim\"\"milestones\"\"exceute_status\"posteriorTrueaction_list_summaryjson_data\n\njson_data\n\n****posteriorFalseposteriorTrue\n\n****\n```\nname = \"XAgent\"\ngoal = \"Perform various tasks\"\nprior_plan_criticsim = True\nmilestones = [\"Task1\", \"Task2\", \"Task3\"]\nstatus = \"DOING\"\naction_list_summary = \"Summary of action list\"\n\n\n{\n    \"name\": \"XAgent\",\n    \"goal\": \"Perform various tasks\",\n    \"prior_plan_criticsim\": True,\n    \"milestones\": [\"Task1\", \"Task2\", \"Task3\"],\n    \"exceute_status\": \"DOING\",\n    \"action_list_summary\": \"Summary of action list\"\n}\n```",
            "code_start_line": 199,
            "code_end_line": 218,
            "parent": "TaskSaveItem",
            "have_return": true,
            "code_content": "    def to_json(self, posterior=False):\n        \"\"\"Convert the object to json representation.\"\"\"\n        json_data = {\n            \"name\": self.name,\n            \"goal\": self.goal,\n            # \"handler\": self.handler,\n            # \"tool_budget\": self.tool_budget,\n            \"prior_plan_criticsim\": self.prior_plan_criticism,\n            \"milestones\": self.milestones,\n            # \"expected_tools\": self.expected_tools,\n            \"exceute_status\": self.status.name,\n        }\n        if posterior:\n            if self.action_list_summary != \"\":\n                json_data[\"action_list_summary\"] =  self.action_list_summary\n            # if self.posterior_plan_reflection != []:\n            #     json_data[\"posterior_plan_reflection\"] = self.posterior_plan_reflection\n            # if self.tool_reflection != []:\n            #     json_data[\"tool_reflection\"] = self.tool_reflection\n        return json_data\n",
            "name_column": 8
        },
        "raw": {
            "type": "FunctionDef",
            "name": "raw",
            "md_content": "**raw**JSON\n\n`json.dumps()`JSON\n\n****\n- `to_json()`JSON\n- JSON\n\n****`to_json()`JSON\n```json\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"city\": \"New York\"\n}\n```\n`raw()`\n```json\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"city\": \"New York\"\n}\n```",
            "code_start_line": 221,
            "code_end_line": 223,
            "parent": "TaskSaveItem",
            "have_return": true,
            "code_content": "    def raw(self) -> str:\n        \"\"\"Convert the object to a raw json string\"\"\"\n        return json.dumps(self.to_json(posterior=True), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "__call__": {
            "type": "FunctionDef",
            "name": "__call__",
            "md_content": "**__call__**\n\n__call____call___instances\n\n****\n- \n- \n\n****\n```\n<__main__.Singleton object at 0x7f9b8c6a2a90>\n```",
            "code_start_line": 234,
            "code_end_line": 238,
            "parent": "Singleton",
            "have_return": true,
            "code_content": "    def __call__(cls, *args, **kwargs):\n        \"\"\"Call method for the singleton metaclass.\"\"\"\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n",
            "name_column": 8
        }
    },
    "XAgent/logs.py": {
        "JsonFileHandler": {
            "type": "ClassDef",
            "name": "JsonFileHandler",
            "md_content": "**JsonFileHandler**: JSON\n\nJsonFileHandlerlogging.FileHandlerJSON\n\n- `__init__(self, filename, mode=\"a\", encoding=None, delay=False)`: JsonFileHandler\n  - `filename`\n  - `mode`\"a\"\n  - `encoding`None\n  - `delay`False\n\n- `emit(self, record)`: emitJSON\n  - `record`\n\nemitJSON`open`UTF-8JSON`json.dump`JSON`ensure_ascii=False`ASCII`indent=4`JSON\n\nJsonFileHandlerJSONXAgent/logs.py`log_json`JsonFileHandlerJsonFormatterjson_loggerjson_loggerdebugJSONjson_loggerJsonFileHandler\n\n****JsonFileHandlerJsonFileHandler",
            "code_start_line": 17,
            "code_end_line": 24,
            "parent": null,
            "have_return": false,
            "code_content": "class JsonFileHandler(logging.FileHandler):\n    def __init__(self, filename, mode=\"a\", encoding=None, delay=False):\n        super().__init__(filename, mode, encoding, delay)\n\n    def emit(self, record):\n        json_data = json.loads(self.format(record))\n        with open(self.baseFilename, \"w\", encoding=\"utf-8\") as f:\n            json.dump(json_data, f, ensure_ascii=False, indent=4)\n",
            "name_column": 6
        },
        "JsonFormatter": {
            "type": "ClassDef",
            "name": "JsonFormatter",
            "md_content": "**JsonFormatter**: JSON\n\nJsonFormatterlogging.Formatterformatformatrecord\n\nformatJsonFormatterrecord.msg\n\nJsonFormatterJsonFileHandler\n\n```python\ndef log_json(self, data: Any, file_name: str) -> None:\n    # \n    this_files_dir_path = os.path.dirname(__file__)\n    log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n    # JSON\n    json_file_path = os.path.join(log_dir, file_name)\n    json_data_handler = JsonFileHandler(json_file_path)\n    json_data_handler.setFormatter(JsonFormatter())\n\n    # JSON\n    self.json_logger.addHandler(json_data_handler)\n    self.json_logger.debug(data)\n    self.json_logger.removeHandler(json_data_handler)\n```\n\nlog_dirfile_nameJSONjson_file_pathJsonFileHandlerjson_data_handlerJsonFormatter()json_data_handlerself.json_loggerdebugdatajson_data_handler\n\n****: JsonFormatter\n- JsonFormatterJSON\n- JsonFormatterJsonFileHandlerJSON\n\n****:\n\"Hello, world!\"JsonFormatter\"Hello, world!\"",
            "code_start_line": 27,
            "code_end_line": 29,
            "parent": null,
            "have_return": true,
            "code_content": "class JsonFormatter(logging.Formatter):\n    def format(self, record):\n        return record.msg\n",
            "name_column": 6
        },
        "Logger": {
            "type": "ClassDef",
            "name": "Logger",
            "md_content": "**Logger**: Loggeractivity.logerrors.log\n\n__init__\n\nself.typing_console_handlerINFORecordFormatter\n\nself.console_handlerDEBUGRecordFormatter\n\nINFOself.file_handlerDEBUGRecordFormatter\n\nERRORerror_handlerERRORRecordFormatter\n\nself.typing_loggerself.loggerself.json_loggerDEBUG\n\nself.speak_modeself.chat_pluginsself.log_lock\n\n****: \n- Logger\n- Loggeractivity.logerrors.log\n- self.typing_console_handlerself.console_handler\n- \n- Loggerdebuginfowarnerror\n\n****:\n```\n2021-01-01 12:00:00 INFO Title Message\n2021-01-01 12:00:01 DEBUG Title Message\n2021-01-01 12:00:02 WARNING Title Message\n2021-01-01 12:00:03 ERROR Title Message\n```",
            "code_start_line": 32,
            "code_end_line": 200,
            "parent": null,
            "have_return": true,
            "code_content": "class Logger(metaclass=Singleton):\n    \"\"\"\n    Logger that handle titles in different colors.\n    Outputs logs in console, activity.log, and errors.log\n    For console handler: simulates typing\n    \"\"\"\n\n    def __init__(self):\n        # create log directory if it doesn't exist\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        log_file = \"activity.log\"\n        error_file = \"error.log\"\n\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        \n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(title)s %(message_no_color)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        self.typing_logger = logging.getLogger(\"TYPER\")\n        self.typing_logger.addHandler(self.typing_console_handler)\n        self.typing_logger.addHandler(self.file_handler)\n        self.typing_logger.addHandler(error_handler)\n        self.typing_logger.setLevel(logging.DEBUG)\n\n        self.logger = logging.getLogger(\"LOGGER\")\n        self.logger.addHandler(self.console_handler)\n        self.logger.addHandler(self.file_handler)\n        self.logger.addHandler(error_handler)\n        self.logger.setLevel(logging.DEBUG)\n\n        self.json_logger = logging.getLogger(\"JSON_LOGGER\")\n        self.json_logger.addHandler(self.file_handler)\n        self.json_logger.addHandler(error_handler)\n        self.json_logger.setLevel(logging.DEBUG)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n        self.log_lock = Lock()\n\n\n    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n        self.log_lock.acquire()\n        self.typing_logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n        self.log_lock.release()\n\n    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n\n    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n\n    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n\n    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n\n    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n\n    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n\n    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n\n    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n\n    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 6
        },
        "TypingConsoleHandler": {
            "type": "ClassDef",
            "name": "TypingConsoleHandler",
            "md_content": "**TypingConsoleHandler**\n\nlogging.StreamHandleremit\n\nemit0.050.01\n\nself.handleError\n\n****\n- \n- \n- ",
            "code_start_line": 208,
            "code_end_line": 227,
            "parent": null,
            "have_return": false,
            "code_content": "class TypingConsoleHandler(logging.StreamHandler):\n    def emit(self, record):\n        min_typing_speed = 0.05\n        max_typing_speed = 0.01\n\n        msg = self.format(record)\n        try:\n            words = msg.split()\n            for i, word in enumerate(words):\n                print(word, end=\"\", flush=True)\n                if i < len(words) - 1:\n                    print(\" \", end=\"\", flush=True)\n                typing_speed = random.uniform(min_typing_speed, max_typing_speed)\n                time.sleep(typing_speed)\n                # type faster after each word\n                min_typing_speed = min_typing_speed * 0.95\n                max_typing_speed = max_typing_speed * 0.95\n            print()\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "ConsoleHandler": {
            "type": "ClassDef",
            "name": "ConsoleHandler",
            "md_content": "**ConsoleHandler**: \n\nConsoleHandlerloggingHandlerlogging.StreamHandleremit\n\nemitself.format(record)msgprintmsgself.handleError(record)\n\nXAgent/logs.pyConsoleHandlertyping_console_handlerconsole_handler\n\n__init__log_dirlog_fileerror_file\n\nconsole_formatter\n\nTypingConsoleHandlertyping_console_handlerINFOconsole_formatter\n\nConsoleHandlerconsole_handlerDEBUGconsole_formatter\n\nFileHandlerfile_handleractivity.logDEBUGinfo_formatter\n\nFileHandlererror_handlererror.logERRORerror_formatter\n\nLoggertyping_loggerloggerjson_loggertyping_console_handlerfile_handlererror_handlerLogger\n\nspeak_modechat_pluginslog_lock\n\n****: ConsoleHandler\n- ConsoleHandlerlogging\n- ConsoleHandlerLoggerConsoleHandlerLogger\n- ConsoleHandler\n- ConsoleHandleremithandleError",
            "code_start_line": 230,
            "code_end_line": 236,
            "parent": null,
            "have_return": false,
            "code_content": "class ConsoleHandler(logging.StreamHandler):\n    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "RecordFormatter": {
            "type": "ClassDef",
            "name": "RecordFormatter",
            "md_content": "**RecordFormatter**\n\nRecordFormatterlogging.FormatterformatformatLogRecord\n\nformatLogRecord\"color\"\"color\"\"title\"Style.RESET_ALLrecord.title_color\"color\"\"record.title\"record.title_color\n\nLogRecord\"msg\"\"msg\"record.message_no_color\"msg\"record.message_no_color\n\nlogging.Formatterformatrecord\n\n\n\n****RecordFormatter\n- RecordFormatterFileHandlerConsoleHandlersetFormatter\n- format\n\n****LogRecord\n- color: \"\\033[1;31m\"\n- title: \"ERROR\"\n- msg: \"An error occurred.\"\n\nRecordFormatterformat\n\"\\033[1;31mERROR An error occurred.\"",
            "code_start_line": 239,
            "code_end_line": 258,
            "parent": null,
            "have_return": true,
            "code_content": "class RecordFormatter(logging.Formatter):\n    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 6
        },
        "remove_color_codes": {
            "type": "FunctionDef",
            "name": "remove_color_codes",
            "md_content": "**remove_color_codes**\n\n\n\nANSI`ansi_escape``\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])`ANSI`sub`\n\n`XAgent/logs.py`\n```python\ndef format(self, record: LogRecord) -> str:\n    if hasattr(record, \"color\"):\n        record.title_color = (\n            getattr(record, \"color\")\n            + getattr(record, \"title\", \"\")\n            + \" \"\n            + Style.RESET_ALL\n        )\n    else:\n        record.title_color = getattr(record, \"title\", \"\")\n\n    # Add this line to set 'title' to an empty string if it doesn't exist\n    record.title = getattr(record, \"title\", \"\")\n\n    if hasattr(record, \"msg\"):\n        record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n    else:\n        record.message_no_color = \"\"\n    return super().format(record)\n```\n\n`remove_color_codes``record``record``msg``msg``remove_color_codes``record``message_no_color``format`\n\n****\n- \n- ANSI\n\n****\"\\x1B[31mHello World\\x1B[0m\"\"Hello World\"",
            "code_start_line": 261,
            "code_end_line": 268,
            "parent": null,
            "have_return": true,
            "code_content": "def remove_color_codes(s: str) -> str:\n    if not isinstance(s,str):\n        try:\n            s = json.dumps(s)\n        except:\n            s = str(s)\n    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n    return ansi_escape.sub(\"\", s)\n",
            "name_column": 4
        },
        "print_task_save_items": {
            "type": "FunctionDef",
            "name": "print_task_save_items",
            "md_content": "**print_task_save_items**: \n\nitemTaskSaveItem\n\nlogger.typewriter_log\n\n****: \n- logger.typewriter_log\n- itemTaskSaveItem\n- ",
            "code_start_line": 274,
            "code_end_line": 322,
            "parent": null,
            "have_return": false,
            "code_content": "def print_task_save_items(\n    item: TaskSaveItem,\n) -> None:\n\n    logger.typewriter_log(\n        f\"Task Name:\", Fore.YELLOW, f\"{item.name}\"\n    )\n    logger.typewriter_log(\n        f\"Task Goal:\", Fore.YELLOW, f\"{item.goal}\"\n    )\n    logger.typewriter_log(\n        f\"Task Prior-Criticism:\", Fore.YELLOW, f\"{item.prior_plan_criticism}\"\n    )\n    if len(item.posterior_plan_reflection) > 0:\n        logger.typewriter_log(\n            f\"Task Posterior-Criticism:\", Fore.YELLOW\n        )\n        for line in item.posterior_plan_reflection:\n            line = line.lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n    if len(item.milestones) > 0:\n        logger.typewriter_log(\n            f\"Task Milestones:\", Fore.YELLOW,\n        )\n        for line in item.milestones:\n            line = line.lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n    # if len(item.expected_tools) > 0:\n    #     logger.typewriter_log(\n    #         f\"Expected Tools:\", Fore.YELLOW,\n    #     )\n    #     for line in item.expected_tools:\n    #         line = f\"{line['tool_name']}: {line['reason']}\".lstrip(\"- \")\n    #         logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n    if len(item.tool_reflection) > 0:\n        logger.typewriter_log(\n            f\"Posterior Tool Reflections:\", Fore.YELLOW,\n        )\n        for line in item.tool_reflection:\n            line = f\"{line['target_tool_name']}: {line['reflection']}\".lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n    logger.typewriter_log(\n        f\"Task Status:\", Fore.YELLOW, f\"{item.status.name}\"\n    )\n    if item.action_list_summary != \"\":\n        logger.typewriter_log(\n            f\"Action Summary:\", Fore.YELLOW, f\"{item.action_list_summary}\"\n        )\n",
            "name_column": 4
        },
        "print_assistant_thoughts": {
            "type": "FunctionDef",
            "name": "print_assistant_thoughts",
            "md_content": "**print_assistant_thoughts**: \n\n\n- assistant_reply_json_valid: JSON\n- speak_mode: \n\nID\n\n\n1. None\n2. JSON\n3. \n4. logger.typewriter_log\n5. logger.typewriter_log\n6. 0logger.typewriter_log\n7. logger.typewriter_log\n8. logger.typewriter_log\n9. ID\n\n****: \n\n****: ",
            "code_start_line": 324,
            "code_end_line": 370,
            "parent": null,
            "have_return": true,
            "code_content": "def print_assistant_thoughts(\n    # ai_name: object,\n    assistant_reply_json_valid: object,\n    speak_mode: bool = False,\n) -> None:\n    assistant_thoughts_reasoning = None\n    assistant_thoughts_plan = None\n    assistant_thoughts_speak = None\n    assistant_thoughts_criticism = None\n\n    assistant_thoughts = assistant_reply_json_valid.get(\"thoughts\", {})\n    assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n    assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n    if assistant_thoughts:\n        assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n        assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n        assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n    if assistant_thoughts_text is not None and assistant_thoughts_text != \"\":\n        logger.typewriter_log(\n            f\"THOUGHTS:\", Fore.YELLOW, f\"{assistant_thoughts_text}\"\n        )\n    if assistant_thoughts_reasoning is not None and assistant_thoughts_reasoning != \"\":\n        logger.typewriter_log(\"REASONING:\", Fore.YELLOW, f\"{assistant_thoughts_reasoning}\")\n        \n    if assistant_thoughts_plan is not None and len(assistant_thoughts_plan) > 0:\n        logger.typewriter_log(\"PLAN:\", Fore.YELLOW, \"\")\n        # If it's a list, join it into a string\n        if isinstance(assistant_thoughts_plan, list):\n            assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n        elif isinstance(assistant_thoughts_plan, dict):\n            assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n        # Split the input_string using the newline character and dashes\n        lines = assistant_thoughts_plan.split(\"\\n\")\n        for line in lines:\n            line = line.lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n            \n    if assistant_thoughts_criticism is not None and assistant_thoughts_criticism != \"\":\n        logger.typewriter_log(\"CRITICISM:\", Fore.YELLOW, f\"{assistant_thoughts_criticism}\")\n    return {\n        \"thoughts\": assistant_thoughts_text,\n        \"reasoning\": assistant_thoughts_reasoning,\n        \"plan\": assistant_thoughts_plan,\n        \"criticism\": assistant_thoughts_criticism,\n        \"node_id\": uuid.uuid4().hex\n    }",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**logs.py\n\nactivity.logerror.log\n\ntyping_console_handlerconsole_handlertyping_console_handlerconsole_handler\n\nfile_handleractivity.log\n\nerror_handlererror.log\n\ntyping_loggerloggerjson_logger\n\nspeak_modechat_pluginslog_lock\n\n****\n- \n- \n- \n- ",
            "code_start_line": 39,
            "code_end_line": 104,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def __init__(self):\n        # create log directory if it doesn't exist\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        log_file = \"activity.log\"\n        error_file = \"error.log\"\n\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        \n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(title)s %(message_no_color)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        self.typing_logger = logging.getLogger(\"TYPER\")\n        self.typing_logger.addHandler(self.typing_console_handler)\n        self.typing_logger.addHandler(self.file_handler)\n        self.typing_logger.addHandler(error_handler)\n        self.typing_logger.setLevel(logging.DEBUG)\n\n        self.logger = logging.getLogger(\"LOGGER\")\n        self.logger.addHandler(self.console_handler)\n        self.logger.addHandler(self.file_handler)\n        self.logger.addHandler(error_handler)\n        self.logger.setLevel(logging.DEBUG)\n\n        self.json_logger = logging.getLogger(\"JSON_LOGGER\")\n        self.json_logger.addHandler(self.file_handler)\n        self.json_logger.addHandler(error_handler)\n        self.json_logger.setLevel(logging.DEBUG)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n        self.log_lock = Lock()\n",
            "name_column": 8
        },
        "emit": {
            "type": "FunctionDef",
            "name": "emit",
            "md_content": "**emit**\n\nrecordself.format(record)msgmsgself.handleError(record)\n\n****\n- \n- self.handleError(record)",
            "code_start_line": 231,
            "code_end_line": 236,
            "parent": "ConsoleHandler",
            "have_return": false,
            "code_content": "    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 8
        },
        "format": {
            "type": "FunctionDef",
            "name": "format",
            "md_content": "**format**LogRecord\n\nLogRecordcolortitle_colorcolortitleStyle.RESET_ALLcolortitle_colortitle\n\nLogRecordmsgmessage_no_colormsgmsgmessage_no_color\n\nformatLogRecord\n\n****\n- LogRecordcolormsg\n- color\n- title\n\n****LogRecordcolor\"\\033[1;31m\"title\"Error\"msg\"An error occurred\"\"\\033[1;31mError An error occurred\"",
            "code_start_line": 240,
            "code_end_line": 258,
            "parent": "RecordFormatter",
            "have_return": true,
            "code_content": "    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 8
        },
        "typewriter_log": {
            "type": "FunctionDef",
            "name": "typewriter_log",
            "md_content": "**typewriter_log**: \n\n\n- title: \n- title_color: \n- content: \n- speak_text: False\n- level: logging.INFO\n\nself.chat_pluginscontentcontentself.log_lock.acquire()self.typing_logger.log()self.log_lock.release()\n\n****: \n- self.chat_pluginsself.typing_logger\n- speak_textTrueself.speak_modeTrue\n- ",
            "code_start_line": 107,
            "code_end_line": 124,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n        self.log_lock.acquire()\n        self.typing_logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n        self.log_lock.release()\n",
            "name_column": 8
        },
        "debug": {
            "type": "FunctionDef",
            "name": "debug",
            "md_content": "**debug**\n\n\n- message\n- title\n- title_color\n\n`_log`\n\n****",
            "code_start_line": 126,
            "code_end_line": 132,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n",
            "name_column": 8
        },
        "info": {
            "type": "FunctionDef",
            "name": "info",
            "md_content": "**info**INFO\n\n\n- message\n- title\n- title_color\n\n`_log``_log`\n\n****\n- INFO\n- ",
            "code_start_line": 134,
            "code_end_line": 140,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n",
            "name_column": 8
        },
        "warn": {
            "type": "FunctionDef",
            "name": "warn",
            "md_content": "**warn**\n\n\n- message\n- title\n- title_color\n\n`_log``_log``logging.WARN`\n\n****\n- `message`\n- `title``title_color`\n- ",
            "code_start_line": 142,
            "code_end_line": 148,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n",
            "name_column": 8
        },
        "error": {
            "type": "FunctionDef",
            "name": "error",
            "md_content": "**error**\n\ntitlemessagetitlemessage_logERROR\n\n\n1. XAgent/agent/dispatcher_agent/agent.pyextract_prompts_from_responseerrorerrordispatcher\n\n2. XAgent/message_history.pyupdate_running_summaryerrorerrorJSON\n\n****error",
            "code_start_line": 150,
            "code_end_line": 151,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n",
            "name_column": 8
        },
        "_log": {
            "type": "FunctionDef",
            "name": "_log",
            "md_content": "**_log**: \n\n\n- title: \n- title_color: \n- message: \n- level: logginglogging.INFO\n\nmessagemessage\n\nself.logger.loglevelmessageextraextratitletitle_color\n\n_log\nXAgent/logs.py\n\n    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n\n[]\n\n    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n\n[]\n\n    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n\n[]\n\n    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n\n[]\n[XAgent/logs.py]\n\n****: \n- titletitle_color\n- message\n- levellogging.INFODEBUGINFOWARNERROR\n- self.logger.log",
            "code_start_line": 153,
            "code_end_line": 165,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n",
            "name_column": 8
        },
        "set_level": {
            "type": "FunctionDef",
            "name": "set_level",
            "md_content": "**set_level**\n\nlevelself.logger.setLevel(level)self.typing_logger.setLevel(level)\n\n****\n- levellogging.DEBUGlogging.INFO\n- ",
            "code_start_line": 167,
            "code_end_line": 169,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n",
            "name_column": 8
        },
        "double_check": {
            "type": "FunctionDef",
            "name": "double_check",
            "md_content": "**double_check**\n\nadditionalTextadditionalTextself.typewriter_log\"DOUBLE CHECK CONFIGURATION\"Fore.YELLOWadditionalText\n\n****\n- \n- https://github.com/Torantulino/Auto-GPT#readme\n- github issuediscord",
            "code_start_line": 171,
            "code_end_line": 180,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n",
            "name_column": 8
        },
        "log_json": {
            "type": "FunctionDef",
            "name": "log_json",
            "md_content": "**log_json**JSON\n\ndatafile_namedatafile_name\n\nosdirnameosjoinJSON\n\nJsonFileHandlerJSONJsonFileHandlerJSONsetFormatterJsonFormatter\n\njson_loggerJSONjson_loggerdebugdataJSON\n\njson_loggerJSON\n\n****\n- dataJSON\n- file_namelogs\n- logsFileNotFoundError",
            "code_start_line": 182,
            "code_end_line": 195,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n",
            "name_column": 8
        },
        "get_log_directory": {
            "type": "FunctionDef",
            "name": "get_log_directory",
            "md_content": "**get_log_directory**\n\noslogs\n\n****\n- osos\n- \n\n****\"/Users/logic/Documents/THUNLP/XAgent/XAgent\"\"/Users/logic/Documents/THUNLP/XAgent/XAgent/logs\"",
            "code_start_line": 197,
            "code_end_line": 200,
            "parent": "Logger",
            "have_return": true,
            "code_content": "    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 8
        }
    },
    "XAgent/function_handler.py": {
        "FunctionHandler": {
            "type": "ClassDef",
            "name": "FunctionHandler",
            "md_content": "**FunctionHandler**: \n\nFunctionHandlerToolServerInterface\n\n\n- toolserver_interfaceToolServerInterface\n- config\n- interactionXAgentInteraction\n- recorderRunningRecoder\n- logger\n\n\n- log_task_submit(arguments)\n- change_subtask_handle_function_enum(function_name_list)\n- intrinsic_tools(enable_ask_human_for_help)\n- get_functions(config)\n- long_result_summary(command, result)\n- handle_tool_call(node)\n- handle_subtask_submit(arguments)\n- handle_human_help(arguments)\n\n\n- ToolServerInterfaceXAgentInteractionRunningRecoder\n- FunctionHandler\n\n\n```\nCommand subtask_submit returned: {\"content\": \"you have successfully submit the subtask as XXX\"}\nTOOL STATUS CODE: TOOL_CALL_SUCCESS\n```\n\nFunctionHandlerXAgent",
            "code_start_line": 21,
            "code_end_line": 355,
            "parent": null,
            "have_return": true,
            "code_content": "class FunctionHandler():\n    \"\"\"\n    The handler for functions.\n    \"\"\"\n\n    def __init__(self,\n                 toolserver_interface: ToolServerInterface,\n                 config,\n                 interaction: XAgentInteraction,\n                 recorder: RunningRecoder,\n                 logger=None):\n        self.logger = logger\n        self.toolserver_interface = toolserver_interface\n        self.config = config\n        self.interaction = interaction\n        self.recorder = recorder\n        self.subtask_submit_function = function_manager.get_function_schema(\n            'subtask_submit')\n\n        # TODO: support more complex versions of human help, like collaborative debugging.\n        self.ask_human_for_help_function = function_manager.get_function_schema(\n            'ask_human_for_help')\n        self.human_interruption_function = function_manager.get_function_schema(\n            'human_interruption')\n\n        self.avaliable_tools_description_list = []\n\n    def log_task_submit(self, arguments):\n        \"\"\"\n        Log the task submission.\n\n        Args:\n            arguments: The arguments of the task submission.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= SUBTASK SUBMITTED -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.logger.typewriter_log(\n            f\"submit_type:\", Fore.YELLOW, f\"{arguments['submit_type']}\"\n        )\n        self.logger.typewriter_log(\n            f\"success:\", Fore.YELLOW, f\"{arguments['result']['success']}\"\n        )\n        self.logger.typewriter_log(\n            f\"conclusion:\", Fore.YELLOW, f\"{arguments['result']['conclusion']}\"\n        )\n        if \"milestones\" in arguments[\"result\"].keys():\n            self.logger.typewriter_log(\n                f\"milestones:\", Fore.YELLOW\n            )\n            for milestone in arguments[\"result\"][\"milestones\"]:\n                line = milestone.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        self.logger.typewriter_log(\n            f\"need_for_plan_refine:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']}\"\n        )\n        self.logger.typewriter_log(\n            f\"plan_suggestions:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['reason']}\"\n        )\n\n    def change_subtask_handle_function_enum(self, function_name_list: List[str]):\n        \"\"\"\n        Change the subtask handling function enumeration.\n\n        Args:\n            function_name_list: The list of function names.\n        \"\"\"\n        match self.config.default_request_type:\n            case 'openai':\n                self.subtask_handle_function = function_manager.get_function_schema(\n                    'subtask_handle')\n                self.subtask_handle_function[\"parameters\"][\"properties\"][\"tool_call\"][\n                    \"properties\"][\"tool_name\"][\"enum\"] = function_name_list\n            case 'xagent':\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Request type {self.config.default_request_type} not implemented\")\n\n    def intrinsic_tools(self, enable_ask_human_for_help):\n        \"\"\"\n        Get the intrinsic tools.\n\n        Args:\n            enable_ask_human_for_help: Whether to enable the ask_human_for_help function.\n\n        Returns:\n            The intrinsic tools.\n        \"\"\"\n        tools = [self.subtask_submit_function,]\n        if enable_ask_human_for_help:\n            tools.append(self.ask_human_for_help_function)\n        tools.extend(self.avaliable_tools_description_list)\n        return tools\n\n    def get_functions(self, config):\n        \"\"\"\n        Get the functions.\n\n        Args:\n            config: The configuration for the functions.\n\n        Returns:\n            The intrinsic tools and the description of the tools.\n        \"\"\"\n        output = self.toolserver_interface.get_available_tools()\n\n        available_tools: list = output['available_tools']\n        openai_function_jsons: dict = output['tools_json']\n\n        black_list = set(config.tool_blacklist)\n        for item in black_list:\n            try:\n                available_tools.remove(item)\n            except ValueError:\n                pass\n        openai_function_jsons = [\n            openai_function_json for openai_function_json in openai_function_jsons if openai_function_json['name'] not in black_list]\n\n        self.tool_names = available_tools\n        self.change_subtask_handle_function_enum(available_tools)\n        self.avaliable_tools_description_list = openai_function_jsons\n        for tool_json in openai_function_jsons:\n            function_manager.register_function(tool_json)\n        return self.intrinsic_tools(config.enable_ask_human_for_help), self.avaliable_tools_description_list\n\n    def long_result_summary(self, command: dict, result):\n        \"\"\"\n        Summarize the long result.\n\n        Args:\n            command (dict): The command.\n            result: The result.\n\n        Returns:\n            The summarized result.\n        \"\"\"\n        if command['name'] == 'WebEnv_browse_website':\n            if not isinstance(result, str):\n                result = str(result)\n            result = function_manager(\n                'parse_web_text', webpage=result[:8096], prompt=command['arguments']['goals_to_browse'])\n            result['useful_hyperlinks'] = result['useful_hyperlinks'][:3]\n        if command['name'] == 'WebEnv_search_and_browse':\n            with ThreadPoolExecutor(max_workers=len(result)) as pool:\n                f = []\n                for ret in result:\n                    f.append(pool.submit(function_manager, 'parse_web_text',\n                             webpage=ret['page'][:8096], prompt=command['arguments']['goals_to_browse']))\n                for ret, thd in zip(result, f):\n                    ret['page'] = thd.result()\n                    ret['page']['useful_hyperlinks'] = ret['page']['useful_hyperlinks'][:3]\n\n        if isinstance(result, str) and len(result) > 2000:\n            # need to summarize\n            pass\n        return result\n\n    def handle_tool_call(self, node: ToolNode):\n        \"\"\"\n        Handle the tool call.\n\n        Args:\n            node (ToolNode): The tool node.\n\n        Returns:\n            The result, tool output status code, whether to refine the plan, and the tools used.\n        \"\"\"\n        plan_refine = False\n        command_name = node.data[\"command\"][\"properties\"][\"name\"]\n        arguments = node.data[\"command\"][\"properties\"][\"args\"]\n\n        self.logger.typewriter_log(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND: {Fore.CYAN}{command_name}{Style.RESET_ALL}  \\n\"\n            f\"ARGUMENTS: \\n{Fore.CYAN}{arguments}{Style.RESET_ALL}\",\n        )\n\n        if command_name == \"subtask_submit\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_subtask_submit(\n                arguments)\n        elif command_name == \"ask_human_for_help\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_human_help(\n                arguments)\n        elif command_name == \"human_interruption\":\n            assert False, \"Never call this function\"\n        elif command_name == '' or command_name is None:\n            command_result = ''\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        else:\n            command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                command_name,\n                arguments,\n                # input_hash_id,\n            )\n            # retry to get the result\n            MAX_RETRY = 10\n            retry_time = 0\n            while retry_time < MAX_RETRY and tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and isinstance(command_result['detail'], dict) and 'type' in command_result['detail'] and command_result['detail']['type'] == 'retry':\n                time.sleep(3)\n                retry_time += 1\n                command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                    command_result['detail']['next_calling'],\n                    command_result['detail']['arguments'],\n                )\n\n            if tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and retry_time == MAX_RETRY:\n                command_result = \"Timeout and no content returned! Please check the content you submit!\"\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            command_result = self.long_result_summary(\n                {'name': command_name, 'arguments': arguments}, command_result)\n\n        result = f\"Command {command_name} returned: \" + f\"{command_result}\"\n\n        node.data[\"tool_output\"] = command_result\n        node.data[\"tool_status_code\"] = tool_output_status_code\n\n        # node.workspace_hash_id = output_hash_id\n        if result is not None:\n            node.history.add(\"system\", result, \"action_result\")\n            self.logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, result)\n        else:\n            node.history.add(\n                \"system\", \"Unable to execute command\", \"action_result\")\n            self.logger.typewriter_log(\n                \"SYSTEM: \", Fore.YELLOW, \"Unable to execute command\"\n            )\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            color = Fore.GREEN\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n            color = Fore.YELLOW\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n            color = Fore.BLUE\n        else:\n            color = Fore.RED\n\n        self.logger.typewriter_log(\n            \"TOOL STATUS CODE: \", Fore.YELLOW, f\"{color}{tool_output_status_code.name}{Style.RESET_ALL}\"\n        )\n\n        self.recorder.regist_tool_call(\n            tool_name=command_name,\n            tool_input=arguments,\n            tool_output=command_result,\n            tool_status_code=tool_output_status_code.name,\n            thought_data={\n                \"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]},\n        )\n\n        using_tools = {\n            \"tool_name\": command_name,\n            \"tool_input\": arguments,\n            \"tool_output\": command_result,\n            \"tool_status_code\": tool_output_status_code.name,\n            \"thought_data\": {\"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]}\n        }\n\n        if tool_output_status_code in [ToolCallStatusCode.SUBMIT_AS_SUCCESS, ToolCallStatusCode.SUBMIT_AS_FAILED]:\n            self.log_task_submit(arguments)\n\n        return result, tool_output_status_code, plan_refine, using_tools\n\n    def handle_subtask_submit(self, arguments):\n        \"\"\"\n        Handle the subtask submission.\n\n        Args:\n            arguments: The arguments of the subtask submission.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        plan_refine = False\n        if arguments[\"result\"][\"success\"]:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_SUCCESS\n        else:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_FAILED\n        if arguments[\"suggestions_for_latter_subtasks_plan\"][\"need_for_plan_refine\"]:\n            plan_refine = True\n        answer = {\n            \"content\": f\"you have successfully submit the subtask as {arguments['submit_type']}\"\n        }\n        command_result = json.dumps(answer, ensure_ascii=False)\n\n        return plan_refine, tool_output_status_code, command_result\n\n    def handle_human_help(self, arguments):\n        \"\"\"\n        Handle the ask for human help.\n\n        Args:\n            arguments: The arguments for asking human help.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        self.logger.typewriter_log(\n            \"ASK For Human Help\",\n            Fore.RED,\n            \"You must give some suggestions, please type in your feedback and then press 'Enter' to send and continue the loop\"\n        )\n        url = \"ask_human\"\n        payload = arguments\n        tool_cache = self.recorder.query_tool_server_cache(\n            url=url, payload=payload)\n        if tool_cache != None:\n            command_result = tool_cache[\"tool_output\"]\n            status_code = tool_cache[\"response_status_code\"]\n        else:\n            prompt = \"ASK For Human Help: \\n You must give some suggestions, \\\n                  please type in your feedback and then press 'Enter' \\\n                  to send and continue the loop.\"\n            human_suggestion = self.interaction.ask_for_human_help(\n                prompt)\n            command_result = json.dumps(\n                {\"output\": f\"{human_suggestion}\"}, ensure_ascii=False)\n            status_code = \"human has no status :)\"\n        self.recorder.regist_tool_server(\n            url=url,\n            payload=payload,\n            tool_output=command_result,\n            response_status_code=status_code,\n        )\n\n        plan_refine = False\n        return plan_refine, ToolCallStatusCode.TOOL_CALL_SUCCESS, command_result\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**FunctionHandler\n\n\n- toolserver_interface: ToolServerInterfaceToolServer\n- config: \n- interaction: XAgentInteraction\n- recorder: RunningRecoder\n- logger: \n\ntoolserver_interfaceself.toolserver_interfaceconfigself.configinteractionself.interactionrecorderself.recorderloggerself.logger\n\nfunction_manager.get_function_schemasubtask_submitask_human_for_helphuman_interruptionsubtask_submitself.subtask_submit_functionask_human_for_helpself.ask_human_for_help_functionhuman_interruptionself.human_interruption_function\n\navaliable_tools_description_listself.avaliable_tools_description_list\n\n****\n- toolserver_interfaceconfiginteractionrecorderlogger\n- function_managersubtask_submitask_human_for_helphuman_interruption",
            "code_start_line": 26,
            "code_end_line": 46,
            "parent": "FunctionHandler",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 toolserver_interface: ToolServerInterface,\n                 config,\n                 interaction: XAgentInteraction,\n                 recorder: RunningRecoder,\n                 logger=None):\n        self.logger = logger\n        self.toolserver_interface = toolserver_interface\n        self.config = config\n        self.interaction = interaction\n        self.recorder = recorder\n        self.subtask_submit_function = function_manager.get_function_schema(\n            'subtask_submit')\n\n        # TODO: support more complex versions of human help, like collaborative debugging.\n        self.ask_human_for_help_function = function_manager.get_function_schema(\n            'ask_human_for_help')\n        self.human_interruption_function = function_manager.get_function_schema(\n            'human_interruption')\n\n        self.avaliable_tools_description_list = []\n",
            "name_column": 8
        },
        "log_task_submit": {
            "type": "FunctionDef",
            "name": "log_task_submit",
            "md_content": "**log_task_submit**: \n\narguments\n\nlogger.typewriter_log\"-=-=-=-=-=-=-= SUBTASK SUBMITTED -=-=-=-=-=-=-=\"\"submit_type:\"\"success:\"\"conclusion:\"arguments[\"result\"]\"milestones\"\"milestones:\"arguments[\"result\"][\"milestones\"]\"need_for_plan_refine:\"\"plan_suggestions:\"\n\n\n- XAgent/function_handler.py\n\nhandle_tool_callcommand_namecommand_name\"subtask_submit\"handle_subtask_submitcommand_name\"ask_human_for_help\"handle_human_helpcommand_name\"human_interruption\"command_nameNonecommand_resulttool_output_status_codeToolCallStatusCode.TOOL_CALL_SUCCESStoolserver_interface.execute_command_clientToolCallStatusCode.TIMEOUT_ERROR\"type\"\"retry\"10command_result\"Timeout and no content returned! Please check the content you submit!\"ToolCallStatusCode.TOOL_CALL_SUCCESSlong_result_summarynodedata\n\ntool_output_status_codeToolCallStatusCode.TOOL_CALL_SUCCESStool_output_status_codeToolCallStatusCode.SUBMIT_AS_SUCCESStool_output_status_codeToolCallStatusCode.SUBMIT_AS_FAILEDrecorder\n\n****: argumentsloggerrecorder",
            "code_start_line": 48,
            "code_end_line": 81,
            "parent": "FunctionHandler",
            "have_return": false,
            "code_content": "    def log_task_submit(self, arguments):\n        \"\"\"\n        Log the task submission.\n\n        Args:\n            arguments: The arguments of the task submission.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= SUBTASK SUBMITTED -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.logger.typewriter_log(\n            f\"submit_type:\", Fore.YELLOW, f\"{arguments['submit_type']}\"\n        )\n        self.logger.typewriter_log(\n            f\"success:\", Fore.YELLOW, f\"{arguments['result']['success']}\"\n        )\n        self.logger.typewriter_log(\n            f\"conclusion:\", Fore.YELLOW, f\"{arguments['result']['conclusion']}\"\n        )\n        if \"milestones\" in arguments[\"result\"].keys():\n            self.logger.typewriter_log(\n                f\"milestones:\", Fore.YELLOW\n            )\n            for milestone in arguments[\"result\"][\"milestones\"]:\n                line = milestone.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        self.logger.typewriter_log(\n            f\"need_for_plan_refine:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']}\"\n        )\n        self.logger.typewriter_log(\n            f\"plan_suggestions:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['reason']}\"\n        )\n",
            "name_column": 8
        },
        "change_subtask_handle_function_enum": {
            "type": "FunctionDef",
            "name": "change_subtask_handle_function_enum",
            "md_content": "**change_subtask_handle_function_enum**\n\nfunction_name_list\n\nself.config.default_request_type\n- self.config.default_request_type'openai'function_manager.get_function_schema('subtask_handle')\"tool_call\"\"tool_name\"function_name_list\n- self.config.default_request_type'xagent'\n- self.config.default_request_typeNotImplementedError\n\n****\n- function_name_list\n- self.config.default_request_type\n\n\n- XAgent/function_handler.py\n- \n```python\ndef get_functions(self, config):\n    \"\"\"\n    Get the functions.\n\n    Args:\n        config: The configuration for the functions.\n\n    Returns:\n        The intrinsic tools and the description of the tools.\n    \"\"\"\n    output = self.toolserver_interface.get_available_tools()\n\n    available_tools: list = output['available_tools']\n    openai_function_jsons: dict = output['tools_json']\n\n    black_list = set(config.tool_blacklist)\n    for item in black_list:\n        try:\n            available_tools.remove(item)\n        except ValueError:\n            pass\n    openai_function_jsons = [\n        openai_function_json for openai_function_json in openai_function_jsons if openai_function_json['name'] not in black_list]\n\n    self.tool_names = available_tools\n    self.change_subtask_handle_function_enum(available_tools)\n    self.avaliable_tools_description_list = openai_function_jsons\n    for tool_json in openai_function_jsons:\n        function_manager.register_function(tool_json)\n    return self.intrinsic_tools(config.enable_ask_human_for_help), self.avaliable_tools_description_list\n```\n- get_functions\n\n- XAgent/workflow/task_handler.py\n- \n```python\ndef inner_loop(self, plan: Plan, ):\n    \"\"\"\n    Generates search plan and process it for the current task.\n\n    Args:\n        plan (Plan): The plan to be processed.\n\n    Raises:\n        AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n    Returns:\n        ReACTChainSearch: Instance of the search plan.\n    \"\"\"\n    task_ids_str = plan.get_subtask_id(to_str=True)\n    self.logger.typewriter_log(\n        f\"-=-=-=-=-=-=-= Performing Task {task_ids_str} ({plan.data.name}): Begin -=-=-=-=-=-=-=\",\n        Fore.GREEN,\n        \"\",\n    )\n    self.xagent_core.print_task_save_items(plan.data)\n\n    agent = self.agent_dispatcher.dispatch(\n        RequiredAbilities.tool_tree_search,\n        json.dumps(plan.data.to_json(), indent=2, ensure_ascii=False),\n        # avaliable_tools_description_list=self.avaliable_tools_description_list\n    )\n\n    plan.data.status = TaskStatusCode.DOING\n\n    if self.config.rapidapi_retrieve_tool_count > 0:\n        retrieve_string = summarize_plan(plan.to_json())\n        rapidapi_tool_names, rapidapi_tool_jsons = self.toolserver_interface.retrieve_rapidapi_tools(\n            retrieve_string, top_k=self.config.rapidapi_retrieve_tool_count)\n        if rapidapi_tool_names is not None:\n            self.function_handler.change_subtask_handle_function_enum(\n                self.function_handler.tool_names + rapidapi_tool_names)\n            self.function_handler.avaliable_tools_description_list += rapidapi_tool_jsons\n        else:\n            print(\"bug: no rapidapi tool retrieved, need to fix here\")\n\n    search_method = ReACTChainSearch(\n        xagent_core_components=self.xagent_core,)\n\n    arguments = function_manager.get_function_schema('action_reasoning')[\n        'parameters']\n    search_method.run(config=self.config,\n                      agent=agent,\n                      arguments=arguments,\n                      functions=self.function_handler.intrinsic_tools(\n                          self.config.enable_ask_human_for_help),\n                      task_id=task_ids_str,\n                      now_dealing_task=self.now_dealing_task,\n                      plan_agent=self.plan_agent)\n\n    if search_method.status == SearchMethodStatusCode.SUCCESS:\n        plan.data.status = TaskStatusCode.SUCCESS\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Solved -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n    elif search_method.status == SearchMethodStatusCode.FAIL:\n        plan.data.status = TaskStatusCode.FAIL\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Failed -=-=-=-=-=-=-=\",\n            Fore.RED,\n            \"\",\n        )\n    else:\n        assert False, f\"{plan.data.name}\"\n    return search_method\n```\n- inner_looprapidapi_retrieve_tool_countRapidAPI\n\n[End of XAgent/function_handler.py]\n[End of XAgent/workflow/task_handler.py]",
            "code_start_line": 83,
            "code_end_line": 100,
            "parent": "FunctionHandler",
            "have_return": false,
            "code_content": "    def change_subtask_handle_function_enum(self, function_name_list: List[str]):\n        \"\"\"\n        Change the subtask handling function enumeration.\n\n        Args:\n            function_name_list: The list of function names.\n        \"\"\"\n        match self.config.default_request_type:\n            case 'openai':\n                self.subtask_handle_function = function_manager.get_function_schema(\n                    'subtask_handle')\n                self.subtask_handle_function[\"parameters\"][\"properties\"][\"tool_call\"][\n                    \"properties\"][\"tool_name\"][\"enum\"] = function_name_list\n            case 'xagent':\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Request type {self.config.default_request_type} not implemented\")\n",
            "name_column": 8
        },
        "intrinsic_tools": {
            "type": "FunctionDef",
            "name": "intrinsic_tools",
            "md_content": "**intrinsic_tools**\n\nenable_ask_human_for_helpask_human_for_help\n\n\n\ntools[self.subtask_submit_function]\n\nenable_ask_human_for_helpTrueself.ask_human_for_help_functiontools\n\nself.avaliable_tools_description_listtools\n\ntools\n\n****\n- enable_ask_human_for_helpask_human_for_help\n- \n\n****enable_ask_human_for_helpTrueself.avaliable_tools_description_list['tool1', 'tool2'][self.subtask_submit_function, self.ask_human_for_help_function, 'tool1', 'tool2']",
            "code_start_line": 102,
            "code_end_line": 116,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def intrinsic_tools(self, enable_ask_human_for_help):\n        \"\"\"\n        Get the intrinsic tools.\n\n        Args:\n            enable_ask_human_for_help: Whether to enable the ask_human_for_help function.\n\n        Returns:\n            The intrinsic tools.\n        \"\"\"\n        tools = [self.subtask_submit_function,]\n        if enable_ask_human_for_help:\n            tools.append(self.ask_human_for_help_function)\n        tools.extend(self.avaliable_tools_description_list)\n        return tools\n",
            "name_column": 8
        },
        "get_functions": {
            "type": "FunctionDef",
            "name": "get_functions",
            "md_content": "**get_functions**\n\nconfig\n\n\n- toolserver_interfaceget_available_tools\n- tool_blacklistopenai_function_jsons\n- self.tool_names\n- self.avaliable_tools_description_list\n- openai_function_jsonsfunction_managerregister_function\n- \n\n****\n- config\n- toolserver_interfaceget_available_tools\n\n****\n```\n([\n    'subtask_function_1',\n    'subtask_function_2',\n    ...\n], [\n    {\n        'name': 'tool_1',\n        'description': '1'\n    },\n    {\n        'name': 'tool_2',\n        'description': '2'\n    },\n    ...\n])\n```",
            "code_start_line": 118,
            "code_end_line": 147,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def get_functions(self, config):\n        \"\"\"\n        Get the functions.\n\n        Args:\n            config: The configuration for the functions.\n\n        Returns:\n            The intrinsic tools and the description of the tools.\n        \"\"\"\n        output = self.toolserver_interface.get_available_tools()\n\n        available_tools: list = output['available_tools']\n        openai_function_jsons: dict = output['tools_json']\n\n        black_list = set(config.tool_blacklist)\n        for item in black_list:\n            try:\n                available_tools.remove(item)\n            except ValueError:\n                pass\n        openai_function_jsons = [\n            openai_function_json for openai_function_json in openai_function_jsons if openai_function_json['name'] not in black_list]\n\n        self.tool_names = available_tools\n        self.change_subtask_handle_function_enum(available_tools)\n        self.avaliable_tools_description_list = openai_function_jsons\n        for tool_json in openai_function_jsons:\n            function_manager.register_function(tool_json)\n        return self.intrinsic_tools(config.enable_ask_human_for_help), self.avaliable_tools_description_list\n",
            "name_column": 8
        },
        "long_result_summary": {
            "type": "FunctionDef",
            "name": "long_result_summary",
            "md_content": "**long_result_summary**\n\ncommandresultcommandresult\n\n'WebEnv_browse_website'8096function_manager'WebEnv_search_and_browse'8096function_manager\n\n2000\n\n\n\n****\n\n****'WebEnv_browse_website'\n\n```python\n{\n    'text': '',\n    'useful_hyperlinks': ['1', '2', '3']\n}\n```",
            "code_start_line": 149,
            "code_end_line": 179,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def long_result_summary(self, command: dict, result):\n        \"\"\"\n        Summarize the long result.\n\n        Args:\n            command (dict): The command.\n            result: The result.\n\n        Returns:\n            The summarized result.\n        \"\"\"\n        if command['name'] == 'WebEnv_browse_website':\n            if not isinstance(result, str):\n                result = str(result)\n            result = function_manager(\n                'parse_web_text', webpage=result[:8096], prompt=command['arguments']['goals_to_browse'])\n            result['useful_hyperlinks'] = result['useful_hyperlinks'][:3]\n        if command['name'] == 'WebEnv_search_and_browse':\n            with ThreadPoolExecutor(max_workers=len(result)) as pool:\n                f = []\n                for ret in result:\n                    f.append(pool.submit(function_manager, 'parse_web_text',\n                             webpage=ret['page'][:8096], prompt=command['arguments']['goals_to_browse']))\n                for ret, thd in zip(result, f):\n                    ret['page'] = thd.result()\n                    ret['page']['useful_hyperlinks'] = ret['page']['useful_hyperlinks'][:3]\n\n        if isinstance(result, str) and len(result) > 2000:\n            # need to summarize\n            pass\n        return result\n",
            "name_column": 8
        },
        "handle_tool_call": {
            "type": "FunctionDef",
            "name": "handle_tool_call",
            "md_content": "**handle_tool_call**\n\nToolNode\n\n\"subtask_submit\"handle_subtask_submit\"ask_human_for_help\"handle_human_help\"human_interruption\"None\n\ntoolserver_interfaceexecute_command_client10\n\nlong_result_summarydata\n\n\n\n****\n- nodeToolNode\n- \n- \n\n****\"subtask_submit\"{\"task_id\": 123}TOOL_CALL_SUCCESS\"\"False{\"tool_name\": \"subtask_submit\", \"tool_input\": {\"task_id\": 123}, \"tool_output\": \"\", \"tool_status_code\": \"TOOL_CALL_SUCCESS\", \"thought_data\": {\"thought\": \"\", \"content\": \"",
            "code_start_line": 181,
            "code_end_line": 286,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def handle_tool_call(self, node: ToolNode):\n        \"\"\"\n        Handle the tool call.\n\n        Args:\n            node (ToolNode): The tool node.\n\n        Returns:\n            The result, tool output status code, whether to refine the plan, and the tools used.\n        \"\"\"\n        plan_refine = False\n        command_name = node.data[\"command\"][\"properties\"][\"name\"]\n        arguments = node.data[\"command\"][\"properties\"][\"args\"]\n\n        self.logger.typewriter_log(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND: {Fore.CYAN}{command_name}{Style.RESET_ALL}  \\n\"\n            f\"ARGUMENTS: \\n{Fore.CYAN}{arguments}{Style.RESET_ALL}\",\n        )\n\n        if command_name == \"subtask_submit\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_subtask_submit(\n                arguments)\n        elif command_name == \"ask_human_for_help\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_human_help(\n                arguments)\n        elif command_name == \"human_interruption\":\n            assert False, \"Never call this function\"\n        elif command_name == '' or command_name is None:\n            command_result = ''\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        else:\n            command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                command_name,\n                arguments,\n                # input_hash_id,\n            )\n            # retry to get the result\n            MAX_RETRY = 10\n            retry_time = 0\n            while retry_time < MAX_RETRY and tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and isinstance(command_result['detail'], dict) and 'type' in command_result['detail'] and command_result['detail']['type'] == 'retry':\n                time.sleep(3)\n                retry_time += 1\n                command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                    command_result['detail']['next_calling'],\n                    command_result['detail']['arguments'],\n                )\n\n            if tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and retry_time == MAX_RETRY:\n                command_result = \"Timeout and no content returned! Please check the content you submit!\"\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            command_result = self.long_result_summary(\n                {'name': command_name, 'arguments': arguments}, command_result)\n\n        result = f\"Command {command_name} returned: \" + f\"{command_result}\"\n\n        node.data[\"tool_output\"] = command_result\n        node.data[\"tool_status_code\"] = tool_output_status_code\n\n        # node.workspace_hash_id = output_hash_id\n        if result is not None:\n            node.history.add(\"system\", result, \"action_result\")\n            self.logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, result)\n        else:\n            node.history.add(\n                \"system\", \"Unable to execute command\", \"action_result\")\n            self.logger.typewriter_log(\n                \"SYSTEM: \", Fore.YELLOW, \"Unable to execute command\"\n            )\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            color = Fore.GREEN\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n            color = Fore.YELLOW\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n            color = Fore.BLUE\n        else:\n            color = Fore.RED\n\n        self.logger.typewriter_log(\n            \"TOOL STATUS CODE: \", Fore.YELLOW, f\"{color}{tool_output_status_code.name}{Style.RESET_ALL}\"\n        )\n\n        self.recorder.regist_tool_call(\n            tool_name=command_name,\n            tool_input=arguments,\n            tool_output=command_result,\n            tool_status_code=tool_output_status_code.name,\n            thought_data={\n                \"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]},\n        )\n\n        using_tools = {\n            \"tool_name\": command_name,\n            \"tool_input\": arguments,\n            \"tool_output\": command_result,\n            \"tool_status_code\": tool_output_status_code.name,\n            \"thought_data\": {\"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]}\n        }\n\n        if tool_output_status_code in [ToolCallStatusCode.SUBMIT_AS_SUCCESS, ToolCallStatusCode.SUBMIT_AS_FAILED]:\n            self.log_task_submit(arguments)\n\n        return result, tool_output_status_code, plan_refine, using_tools\n",
            "name_column": 8
        },
        "handle_subtask_submit": {
            "type": "FunctionDef",
            "name": "handle_subtask_submit",
            "md_content": "**handle_subtask_submit**\n\narguments\n\n\n\nplan_refineFalsearguments\"result\"tool_output_status_codeToolCallStatusCode.SUBMIT_AS_SUCCESStool_output_status_codeToolCallStatusCode.SUBMIT_AS_FAILEDarguments\"suggestions_for_latter_subtasks_plan\"plan_refineTrueanswerJSONcommand_resultplan_refinetool_output_status_codecommand_result\n\n****arguments\n\n****arguments{\"result\": {\"success\": True}, \"submit_type\": \"type1\"}(False, ToolCallStatusCode.SUBMIT_AS_SUCCESS, '{\"content\": \"you have successfully submit the subtask as type1\"}')",
            "code_start_line": 288,
            "code_end_line": 312,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def handle_subtask_submit(self, arguments):\n        \"\"\"\n        Handle the subtask submission.\n\n        Args:\n            arguments: The arguments of the subtask submission.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        plan_refine = False\n        if arguments[\"result\"][\"success\"]:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_SUCCESS\n        else:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_FAILED\n        if arguments[\"suggestions_for_latter_subtasks_plan\"][\"need_for_plan_refine\"]:\n            plan_refine = True\n        answer = {\n            \"content\": f\"you have successfully submit the subtask as {arguments['submit_type']}\"\n        }\n        command_result = json.dumps(answer, ensure_ascii=False)\n\n        return plan_refine, tool_output_status_code, command_result\n",
            "name_column": 8
        },
        "handle_human_help": {
            "type": "FunctionDef",
            "name": "handle_human_help",
            "md_content": "**handle_human_help**\n\narguments\n\nlogger.typewriter_logEnter\n\nurlpayloadrecorder.query_tool_server_cachecommand_resultstatus_code\n\ninteraction.ask_for_human_helpcommand_resultstatus_code\"human has no status :)\"\n\nrecorder.regist_tool_serverurlpayloadcommand_resultstatus_code\n\nplan_refineToolCallStatusCode.TOOL_CALL_SUCCESScommand_result\n\n****\n- arguments\n- logger.typewriter_log\n\n****\"\"\n```\n(\n    False,\n    ToolCallStatusCode.TOOL_CALL_SUCCESS,\n    '{\"output\": \"\"}'\n)\n```",
            "code_start_line": 314,
            "code_end_line": 355,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def handle_human_help(self, arguments):\n        \"\"\"\n        Handle the ask for human help.\n\n        Args:\n            arguments: The arguments for asking human help.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        self.logger.typewriter_log(\n            \"ASK For Human Help\",\n            Fore.RED,\n            \"You must give some suggestions, please type in your feedback and then press 'Enter' to send and continue the loop\"\n        )\n        url = \"ask_human\"\n        payload = arguments\n        tool_cache = self.recorder.query_tool_server_cache(\n            url=url, payload=payload)\n        if tool_cache != None:\n            command_result = tool_cache[\"tool_output\"]\n            status_code = tool_cache[\"response_status_code\"]\n        else:\n            prompt = \"ASK For Human Help: \\n You must give some suggestions, \\\n                  please type in your feedback and then press 'Enter' \\\n                  to send and continue the loop.\"\n            human_suggestion = self.interaction.ask_for_human_help(\n                prompt)\n            command_result = json.dumps(\n                {\"output\": f\"{human_suggestion}\"}, ensure_ascii=False)\n            status_code = \"human has no status :)\"\n        self.recorder.regist_tool_server(\n            url=url,\n            payload=payload,\n            tool_output=command_result,\n            response_status_code=status_code,\n        )\n\n        plan_refine = False\n        return plan_refine, ToolCallStatusCode.TOOL_CALL_SUCCESS, command_result\n",
            "name_column": 8
        }
    },
    "XAgent/message_history.py": {
        "MessageDict": {
            "type": "ClassDef",
            "name": "MessageDict",
            "md_content": "**MessageDict**: TypedDict\n\n****:\n- role (MessageRole): 'system''user''assistant''function'\n- content (str): \n- function_call (dict): \n\n**MessageDict.raw()**: \n\n****:\n- MessageDict: 'role''content'\n\n****:\ndataself.roleself.contentself.function_callNonedatadata\n\n****: :\n- MessageDictrolecontent\n- function_call\n- rawfunction_call\n\nMessageDict\n\n****: Markdown",
            "code_start_line": 16,
            "code_end_line": 28,
            "parent": null,
            "have_return": false,
            "code_content": "class MessageDict(TypedDict):\n    \"\"\"\n    Typed dictionary to keep track of message attributes.\n\n    Attributes:\n        role (MessageRole): Source of the message. Can be either 'system', 'user', 'assistant', or 'function'.\n        content (str): The message content.\n        function_call (dict): Callable method.\n    \"\"\"\n\n    role: MessageRole\n    content: str\n    function_call: dict\n",
            "name_column": 6
        },
        "Message": {
            "type": "ClassDef",
            "name": "Message",
            "md_content": "**Message Function**: \n\n\n\n**role (MessageRole)**:  'system''user''assistant'  'function'\n\n**content (str)**: \n\n**type (MessageType)**:  'ai_response'AI 'action_result'API\n\n**function_call (dict)**: API\n\n**raw()**: \n\n**Returns**:\n    MessageDict:  'role'  'content' \n\n**to_json()**: JSON\n\n**Returns**:\n    MessageDict: JSON\n\n**equal(cls, a: Message, b: Message)**: \n\n**Args**:\n    a (Message): \n    b (Message): \n\n**Returns**:\n    bool: TrueFalse\n\n****: \n\n**Output Example**: \n```python\n{\n    \"role\": \"user\",\n    \"content\": \"Hello, how are you?\"\n}\n```",
            "code_start_line": 31,
            "code_end_line": 86,
            "parent": null,
            "have_return": true,
            "code_content": "class Message:\n    \"\"\"OpenAI Message class.\n\n    A class representing a message from an agent, a user, or a system function.\n\n    Attributes:\n        role (MessageRole): Source of the message, can be either 'system', 'user', 'assistant', or 'function'.\n        content (str): The actual content of the message.\n        type (MessageType): The type of message, either 'ai_response' for AI dialogue messages or 'action_result' for results of API calls.\n        function_call (dict): A dictionary representing the method invocation in programmable API calls.\n    \"\"\"\n\n    role: MessageRole\n    content: str\n    type: MessageType | None = None\n    function_call: dict | None = None\n\n    def raw(self) -> MessageDict:\n        \"\"\"Extracts raw content of the message, stripping away other metadata.\n\n        Returns:\n            MessageDict: Dictionary containing 'role' and 'content'.\n        \"\"\"\n        data = {\"role\": self.role, \"content\": self.content}\n        if self.function_call != None:\n            data[\"function_call\"] = self.function_call\n        return data\n        \n    def to_json(self):\n        \"\"\"Convert the message into JSON format.\n\n        Returns:\n            MessageDict: JSON representation of the message.\n        \"\"\"\n        return self.raw()\n\n    @classmethod\n    def equal(cls, a: Message, b: Message):\n        \"\"\"Checks if two messages are equal by comparing all their attributes.\n\n        Args:\n            a (Message): first message to be compared.\n            b (Message): second message to be compared.\n\n        Returns:\n            bool: Returns True if both messages are equal in all their attributes; False otherwise.\n        \"\"\"\n        if a.role != b.role:\n            return False\n        if a.content != b.content:\n            return False\n        if a.type != b.type:\n            return False\n        if a.function_call != b.function_call:\n            return False\n        return True\n",
            "name_column": 6
        },
        "ModelInfo": {
            "type": "ClassDef",
            "name": "ModelInfo",
            "md_content": "**ModelInfo**: \n\n\n\n- name (str): \n- prompt_token_cost (float): token\n- completion_token_cost (float): token\n- max_tokens (int): token\n\n\n\nXAgent/message_history.py\n\nclass ChatModelInfo(ModelInfo):\n    \"\"\"\"\"\"\n\n[]\n\nclass TextModelInfo(ModelInfo):\n    \"\"\"\"\"\"\n\n[]\n\nclass EmbeddingModelInfo(ModelInfo):\n    \"\"\"\n\n    :\n        embedding_dimensions (int): \n    \"\"\"\n\n    embedding_dimensions: int\n\n[]\n[End of XAgent/message_history.py]\n\n****: \n\n- tokentokentoken\n- ",
            "code_start_line": 89,
            "code_end_line": 102,
            "parent": null,
            "have_return": false,
            "code_content": "class ModelInfo:\n    \"\"\"Data class to store model information.\n\n    Attributes:\n        name (str): Model name\n        prompt_token_cost (float): Token cost per prompt\n        completion_token_cost (float): Token cost per completion\n        max_tokens (int): Maximum tokens that can be generated\n    \"\"\"\n\n    name: str\n    prompt_token_cost: float\n    completion_token_cost: float\n    max_tokens: int\n",
            "name_column": 6
        },
        "ChatModelInfo": {
            "type": "ClassDef",
            "name": "ChatModelInfo",
            "md_content": "**ChatModelInfo**\n\nChatModelInfoModelInfo\n\n\n\n****",
            "code_start_line": 106,
            "code_end_line": 107,
            "parent": null,
            "have_return": false,
            "code_content": "class ChatModelInfo(ModelInfo):\n    \"\"\"Data class to store chat model information.\"\"\"\n",
            "name_column": 6
        },
        "TextModelInfo": {
            "type": "ClassDef",
            "name": "TextModelInfo",
            "md_content": "**TextModelInfo**\n\nTextModelInfoModelInfoModelInfo\n\nModelInfoTextModelInfoModelInfo\n\nTextModelInfo\n\n****TextModelInfo",
            "code_start_line": 111,
            "code_end_line": 112,
            "parent": null,
            "have_return": false,
            "code_content": "class TextModelInfo(ModelInfo):\n    \"\"\"Data class to store text generation model information.\"\"\"\n",
            "name_column": 6
        },
        "EmbeddingModelInfo": {
            "type": "ClassDef",
            "name": "EmbeddingModelInfo",
            "md_content": "**EmbeddingModelInfo**\n\nModelInfoembedding_dimensions\n\n****\n- EmbeddingModelInfoembedding_dimensions\n- embedding_dimensions",
            "code_start_line": 116,
            "code_end_line": 123,
            "parent": null,
            "have_return": false,
            "code_content": "class EmbeddingModelInfo(ModelInfo):\n    \"\"\"Data class to store embedding model information.\n\n    Attributes:\n        embedding_dimensions (int): Number of dimensions in the embedding model.\n    \"\"\"\n\n    embedding_dimensions: int\n",
            "name_column": 6
        },
        "MessageHistory": {
            "type": "ClassDef",
            "name": "MessageHistory",
            "md_content": "**MessageHistory**: \n\n\n\n****:\n- messages (list[Message]): \n- summary (str): /\n- last_trimmed_index (int): \n\n****:\n- `__getitem__(self, i: int) -> Message`: \n- `__iter__(self) -> iterator`: \n- `__len__(self) -> int`: \n- `add(self, role: MessageRole, content: str, type: MessageType | None = None, function_call: str | None = None) -> None`: \n- `append(self, message: Message) -> None`: \n- `trim_messages(self, current_message_chain: list[Message]) -> tuple[Message, list[Message]]`: \n- `per_cycle(self, messages: list[Message] | None = None) -> tuple[Message, Message, Message]`: AI\n- `summary_message(self) -> Message`: \n- `update_running_summary(self, new_events: list[Message]) -> Message`: \n\n****: \n- `add``role`'system''user''assistant''function'\n- `trim_messages``current_message_chain`\n- `per_cycle``messages`None`self.messages`\n- `update_running_summary``new_events`\n\n****:\n```python\nhistory = MessageHistory()\nhistory.add(MessageRole.USER, \"Hello!\")\nhistory.add(MessageRole.ASSISTANT, \"Hi there!\")\nhistory.add(MessageRole.USER, \"How are you?\")\nprint(len(history))  # Output: 3\n\nfor message in history:\n    print(message.content)\n# Output:\n# Hello!\n# Hi there!\n# How are you?\n\nsummary_message = history.summary_message()\nprint(summary_message.content)\n# Output: This reminds you of these events from your past: \\nI was created\n```",
            "code_start_line": 127,
            "code_end_line": 369,
            "parent": null,
            "have_return": true,
            "code_content": "class MessageHistory:\n    \"\"\"Data class to store the history of messages.\n\n    Contains methods to add, retrieve, trim the stored messages.\n\n    Attributes:\n        messages (list[Message]): List of messages in order of their creation.\n        summary (str): String representing the summary of the conversation/history.\n        last_trimmed_index (int): The index of the last erased message from the history.\n    \"\"\"\n\n    messages: list[Message] = field(default_factory=list)\n    summary: str = \"I was created\"\n\n    last_trimmed_index: int = 0\n\n    def __getitem__(self, i: int):\n        \"\"\"Enables accessing messages by their index.\n\n        Args:\n            i (int): Index of the message in the messages list.\n\n        Returns:\n            Message: Message at index i in the messages list.\n        \"\"\"\n        return self.messages[i]\n\n    def __iter__(self):\n        \"\"\"Returns an iterator over the messages list.\n\n        Returns:\n            iterator: An iterator over the messages list.\n        \"\"\"\n        return iter(self.messages)\n\n    def __len__(self):\n        \"\"\"Returns the count of messages in the messages list.\n\n        Returns:\n            int: Total number of messages in the messages list.\n        \"\"\"\n        return len(self.messages)\n\n    def add(\n        self,\n        role: MessageRole,\n        content: str,\n        type: MessageType | None = None,\n        function_call: str | None = None,\n    ):\n        \"\"\"Adds a new message to the messages list.\n\n        Args:\n            role (MessageRole): Source of the message, either 'system', 'user', 'assistant', or 'function'.\n            content (str): Actual content of the message.\n            type (MessageType): Type of the message, 'ai_response' for AI dialogue messages or 'action_result' for results of API calls. Default to None if not specified.\n            function_call (str): A dictionary representing the method invocation in programmable API calls. Default to None if not specified.\n\n        Returns:\n            None\n        \"\"\"\n        if function_call == None:\n            message = Message(role, content, type)\n        else:\n            message = Message(role, content, type, function_call)\n        return self.append(message)\n\n    def append(self, message: Message):\n        \"\"\"Appends a new message to the messages list.\n\n        Args:\n            message (Message): Message to append to the list.\n\n        Returns:\n            None.\n        \"\"\"\n        return self.messages.append(message)\n\n    def trim_messages(\n        self,\n        current_message_chain: list[Message],\n    ) -> tuple[Message, list[Message]]:\n        \"\"\"\n        Returns a list of trimmed messages: messages which are in the message history\n        but not in current_message_chain.\n\n        Args:\n            current_message_chain (list[Message]): The messages currently in the context.\n\n        Returns:\n            Message: A message with the new running summary after adding the trimmed messages.\n            list[Message]: A list of messages that are in full_message_history with an index higher than last_trimmed_index and absent from current_message_chain.\n        \"\"\"\n        # Select messages in full_message_history with an index higher than last_trimmed_index\n        new_messages = [\n            msg for i, msg in enumerate(self) if i > self.last_trimmed_index\n        ]\n\n        # Remove messages that are already present in current_message_chain\n        new_messages_not_in_chain = [\n            msg for msg in new_messages if msg not in current_message_chain\n        ]\n\n        if not new_messages_not_in_chain:\n            return self.summary_message(), []\n\n        new_summary_message = self.update_running_summary(\n            new_events=new_messages_not_in_chain\n        )\n\n        # Find the index of the last message processed\n        last_message = new_messages_not_in_chain[-1]\n        self.last_trimmed_index = self.messages.index(last_message)\n\n        return new_summary_message, new_messages_not_in_chain\n\n    def per_cycle(self, messages: list[Message] | None = None):\n        \"\"\"\n        This method yields user, ai, and result messages from the conversation cycle.\n\n        Args:\n            messages (list[Message]): The messages currently in the context. If None, uses self.messages.\n\n        Yields:\n            tuple: A tuple containing:\n                - user_message (Message): a message containing user input\n                - ai_message (Message): a message from the AI containing a proposed action\n                - result_message (Message): the message containing the result of the AI's proposed action\n        \"\"\"\n        messages = messages or self.messages\n        for i in range(0, len(messages) - 1):\n\n            ai_message = messages[i]\n\n            if ai_message.type != \"ai_response\":\n                continue\n\n            user_message = (\n                messages[i - 1] if i > 0 and messages[i - 1].role == \"user\" else None\n            )\n            result_message = messages[i + 1]\n            try:\n                assert result_message.type == \"action_result\"\n\n                yield user_message, ai_message, result_message\n            except AssertionError as err:\n                logger.debug(\n                    f\"Invalid item in message history: {err}; Messages: {messages[i-1:i+2]}\"\n                )\n\n    def summary_message(self) -> Message:\n        \"\"\"Build summary message from the current summary.\n\n        Returns:\n            Message: A system message containing the current summary\n        \"\"\"\n        return Message(\n            \"system\",\n            f\"This reminds you of these events from your past: \\n{self.summary}\",\n        )\n\n    def update_running_summary(self, new_events: list[Message]) -> Message:\n        \"\"\"\n        This function takes a list of dictionaries representing new events and combines them with the current summary,\n        focusing on key and potentially important information to remember. The updated summary is returned in a message\n        formatted in the 1st person past tense.\n\n        Args:\n            new_events (List[Dict]): A list of dictionaries containing the latest events to be added to the summary.\n\n        Returns:\n            str: A message containing the updated summary of actions, formatted in the 1st person past tense.\n\n        Example:\n            new_events = [{\"event\": \"entered the kitchen.\"}, {\"event\": \"found a scrawled note with the number 7\"}]\n            update_running_summary(new_events)\n            # Returns: \"This reminds you of these events from your past: \\nI entered the kitchen and found a scrawled note saying 7.\"\n        \"\"\"\n        cfg = Config()\n\n        if not new_events:\n            return self.summary_message()\n\n        # Create a copy of the new_events list to prevent modifying the original list\n        new_events = copy.deepcopy(new_events)\n\n        # Replace \"assistant\" with \"you\". This produces much better first person past tense results.\n        for event in new_events:\n            if event.role.lower() == \"assistant\":\n                event.role = \"you\"\n\n                # Remove \"thoughts\" dictionary from \"content\"\n                try:\n                    content_dict = json.loads(event.content)\n                    if \"thoughts\" in content_dict:\n                        del content_dict[\"thoughts\"]\n                    event.content = json.dumps(content_dict)\n                except json.decoder.JSONDecodeError:\n                    if cfg.debug_mode:\n                        logger.error(f\"Error: Invalid JSON: {event.content}\\n\")\n\n            elif event.role.lower() == \"system\":\n                event.role = \"your computer\"\n\n            # Delete all user messages\n            elif event.role == \"user\":\n                new_events.remove(event)\n\n        prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\nSummary So Far:\n\"\"\"\n{self.summary}\n\"\"\"\n\nLatest Development:\n\"\"\"\n{new_events or \"Nothing new happened.\"}\n\"\"\"\n'''\n\n        prompt = ChatSequence.for_model(cfg.fast_llm_model, [Message(\"user\", prompt)])\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            prompt.raw(),\n            PROMPT_SUMMARY_FILE_NAME,\n        )\n\n        self.summary = create_chat_completion(prompt)\n\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            self.summary,\n            SUMMARY_FILE_NAME,\n        )\n\n        return self.summary_message()",
            "name_column": 6
        },
        "raw": {
            "type": "FunctionDef",
            "name": "raw",
            "md_content": "**raw**\n\n'role''content'\n\n****\nMessage(function_call)\n\n\n\n****Message\n\n****\n```\n{\n    \"role\": \"user\",\n    \"content\": \"Hello, how are you?\"\n}\n```",
            "code_start_line": 48,
            "code_end_line": 57,
            "parent": "Message",
            "have_return": true,
            "code_content": "    def raw(self) -> MessageDict:\n        \"\"\"Extracts raw content of the message, stripping away other metadata.\n\n        Returns:\n            MessageDict: Dictionary containing 'role' and 'content'.\n        \"\"\"\n        data = {\"role\": self.role, \"content\": self.content}\n        if self.function_call != None:\n            data[\"function_call\"] = self.function_call\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**JSON\n\nJSONself.raw()JSON\n\n****\n- MessageHistory\n\n****\n```\n{\n    \"id\": 1,\n    \"timestamp\": \"2022-01-01 12:00:00\",\n    \"sender\": \"user\",\n    \"content\": \"Hello\",\n    \"metadata\": {}\n}\n```",
            "code_start_line": 59,
            "code_end_line": 65,
            "parent": "Message",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"Convert the message into JSON format.\n\n        Returns:\n            MessageDict: JSON representation of the message.\n        \"\"\"\n        return self.raw()\n",
            "name_column": 8
        },
        "equal": {
            "type": "FunctionDef",
            "name": "equal",
            "md_content": "**equal**\n\nab\n\nTrueFalse\n\n\n\n****Message\n\n****ababTrueFalse",
            "code_start_line": 68,
            "code_end_line": 86,
            "parent": "Message",
            "have_return": true,
            "code_content": "    def equal(cls, a: Message, b: Message):\n        \"\"\"Checks if two messages are equal by comparing all their attributes.\n\n        Args:\n            a (Message): first message to be compared.\n            b (Message): second message to be compared.\n\n        Returns:\n            bool: Returns True if both messages are equal in all their attributes; False otherwise.\n        \"\"\"\n        if a.role != b.role:\n            return False\n        if a.content != b.content:\n            return False\n        if a.type != b.type:\n            return False\n        if a.function_call != b.function_call:\n            return False\n        return True\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "**__getitem__**\n\ni\n\ni\n\n****\n- i\n- \n\n****\"Hello\", \"World\", \"!\"`__getitem__(1)`\"World\"",
            "code_start_line": 143,
            "code_end_line": 152,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def __getitem__(self, i: int):\n        \"\"\"Enables accessing messages by their index.\n\n        Args:\n            i (int): Index of the message in the messages list.\n\n        Returns:\n            Message: Message at index i in the messages list.\n        \"\"\"\n        return self.messages[i]\n",
            "name_column": 8
        },
        "__iter__": {
            "type": "FunctionDef",
            "name": "__iter__",
            "md_content": "**__iter__**\n\niter()self.messages\n\n****\n- \n- fornext()\n\n****messages3['Hello', 'World', '!']__iter__\n```python\nmessages = ['Hello', 'World', '!']\niterator = messages.__iter__()\nfor message in iterator:\n    print(message)\n```\n\n```\nHello\nWorld\n!\n```",
            "code_start_line": 154,
            "code_end_line": 160,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def __iter__(self):\n        \"\"\"Returns an iterator over the messages list.\n\n        Returns:\n            iterator: An iterator over the messages list.\n        \"\"\"\n        return iter(self.messages)\n",
            "name_column": 8
        },
        "__len__": {
            "type": "FunctionDef",
            "name": "__len__",
            "md_content": "**__len__**\n\nlen\n\n****\n- \n- \n\n****55",
            "code_start_line": 162,
            "code_end_line": 168,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def __len__(self):\n        \"\"\"Returns the count of messages in the messages list.\n\n        Returns:\n            int: Total number of messages in the messages list.\n        \"\"\"\n        return len(self.messages)\n",
            "name_column": 8
        },
        "add": {
            "type": "FunctionDef",
            "name": "add",
            "md_content": "**add**: \n\n\n- role (MessageRole): 'system''user''assistant''function'\n- content (str): \n- type (MessageType): 'ai_response'AI'action_result'APINone\n- function_call (str): APINone\n\nNone\n\nMessage\n\n****: \n- role'system''user''assistant''function'\n- typeMessageType\n- function_callNone\n\n****:\n```\nadd('user', 'Hello, how are you?', MessageType.AI_RESPONSE, 'api_call')\n```",
            "code_start_line": 170,
            "code_end_line": 192,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def add(\n        self,\n        role: MessageRole,\n        content: str,\n        type: MessageType | None = None,\n        function_call: str | None = None,\n    ):\n        \"\"\"Adds a new message to the messages list.\n\n        Args:\n            role (MessageRole): Source of the message, either 'system', 'user', 'assistant', or 'function'.\n            content (str): Actual content of the message.\n            type (MessageType): Type of the message, 'ai_response' for AI dialogue messages or 'action_result' for results of API calls. Default to None if not specified.\n            function_call (str): A dictionary representing the method invocation in programmable API calls. Default to None if not specified.\n\n        Returns:\n            None\n        \"\"\"\n        if function_call == None:\n            message = Message(role, content, type)\n        else:\n            message = Message(role, content, type, function_call)\n        return self.append(message)\n",
            "name_column": 8
        },
        "append": {
            "type": "FunctionDef",
            "name": "append",
            "md_content": "**append**\n\nmessage\n\n\n\n****\nappendmessagemessages\n\n****messageMessage\n\n****",
            "code_start_line": 194,
            "code_end_line": 203,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def append(self, message: Message):\n        \"\"\"Appends a new message to the messages list.\n\n        Args:\n            message (Message): Message to append to the list.\n\n        Returns:\n            None.\n        \"\"\"\n        return self.messages.append(message)\n",
            "name_column": 8
        },
        "trim_messages": {
            "type": "FunctionDef",
            "name": "trim_messages",
            "md_content": "**trim_messages**\n\n\n- current_message_chainlist[Message]\n\n\n- Message\n- list[Message]full_message_historylast_trimmed_indexcurrent_message_chain\n\n\n1. full_message_historylast_trimmed_indexnew_messages\n2. new_messagescurrent_message_chainnew_messages_not_in_chain\n3. new_messages_not_in_chain\n4. update_running_summarynew_messages_not_in_chainnew_summary_message\n5. new_messages_not_in_chainself.last_trimmed_index\n6. new_summary_messagenew_messages_not_in_chain\n\n****\n- current_message_chainMessage\n- full_message_historyMessage\n- last_trimmed_index\n\n****\n```\nnew_summary_message = Message(\"New running summary\", \"This is the updated summary.\")\nnew_messages_not_in_chain = [\n    Message(\"Message 1\", \"This is message 1.\"),\n    Message(\"Message 2\", \"This is message 2.\")\n]\n\n(new_summary_message, new_messages_not_in_chain)\n```",
            "code_start_line": 205,
            "code_end_line": 241,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def trim_messages(\n        self,\n        current_message_chain: list[Message],\n    ) -> tuple[Message, list[Message]]:\n        \"\"\"\n        Returns a list of trimmed messages: messages which are in the message history\n        but not in current_message_chain.\n\n        Args:\n            current_message_chain (list[Message]): The messages currently in the context.\n\n        Returns:\n            Message: A message with the new running summary after adding the trimmed messages.\n            list[Message]: A list of messages that are in full_message_history with an index higher than last_trimmed_index and absent from current_message_chain.\n        \"\"\"\n        # Select messages in full_message_history with an index higher than last_trimmed_index\n        new_messages = [\n            msg for i, msg in enumerate(self) if i > self.last_trimmed_index\n        ]\n\n        # Remove messages that are already present in current_message_chain\n        new_messages_not_in_chain = [\n            msg for msg in new_messages if msg not in current_message_chain\n        ]\n\n        if not new_messages_not_in_chain:\n            return self.summary_message(), []\n\n        new_summary_message = self.update_running_summary(\n            new_events=new_messages_not_in_chain\n        )\n\n        # Find the index of the last message processed\n        last_message = new_messages_not_in_chain[-1]\n        self.last_trimmed_index = self.messages.index(last_message)\n\n        return new_summary_message, new_messages_not_in_chain\n",
            "name_column": 8
        },
        "per_cycle": {
            "type": "FunctionDef",
            "name": "per_cycle",
            "md_content": "**per_cycle**AI\n\nmessageslist[Message]NoneNonemessagesNoneself.messages\n\nmessagesAI\n\n\n1. messagesmessagesself.messages\n2. messages0len(messages)-1\n3. ai_message\n4. ai_messagetype\"ai_response\"\n5. ai_messagetype\"ai_response\"\n   - i0messages[i-1]role\"user\"messages[i-1]user_messageuser_messageNone\n   - messages[i+1]result_message\n   - result_messagetype\"action_result\"AssertionError\n   - yielduser_messageai_messageresult_message\n   - logger.debug()\n\n****\n- \n- typeAI\n- typeAssertionError\n- yield\n\nper_cycle",
            "code_start_line": 243,
            "code_end_line": 275,
            "parent": "MessageHistory",
            "have_return": false,
            "code_content": "    def per_cycle(self, messages: list[Message] | None = None):\n        \"\"\"\n        This method yields user, ai, and result messages from the conversation cycle.\n\n        Args:\n            messages (list[Message]): The messages currently in the context. If None, uses self.messages.\n\n        Yields:\n            tuple: A tuple containing:\n                - user_message (Message): a message containing user input\n                - ai_message (Message): a message from the AI containing a proposed action\n                - result_message (Message): the message containing the result of the AI's proposed action\n        \"\"\"\n        messages = messages or self.messages\n        for i in range(0, len(messages) - 1):\n\n            ai_message = messages[i]\n\n            if ai_message.type != \"ai_response\":\n                continue\n\n            user_message = (\n                messages[i - 1] if i > 0 and messages[i - 1].role == \"user\" else None\n            )\n            result_message = messages[i + 1]\n            try:\n                assert result_message.type == \"action_result\"\n\n                yield user_message, ai_message, result_message\n            except AssertionError as err:\n                logger.debug(\n                    f\"Invalid item in message history: {err}; Messages: {messages[i-1:i+2]}\"\n                )\n",
            "name_column": 8
        },
        "summary_message": {
            "type": "FunctionDef",
            "name": "summary_message",
            "md_content": "**summary_message**\n\n\n\n****\n\n\n****\n- Messagesummary\n- \n\n****\n```\nMessage(\n    \"system\",\n    \"This reminds you of these events from your past: \\n{self.summary}\",\n)\n```",
            "code_start_line": 277,
            "code_end_line": 286,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def summary_message(self) -> Message:\n        \"\"\"Build summary message from the current summary.\n\n        Returns:\n            Message: A system message containing the current summary\n        \"\"\"\n        return Message(\n            \"system\",\n            f\"This reminds you of these events from your past: \\n{self.summary}\",\n        )\n",
            "name_column": 8
        },
        "update_running_summary": {
            "type": "FunctionDef",
            "name": "update_running_summary",
            "md_content": "**update_running_summary**\n\n****\n- new_eventsList[Dict]\n\n****\n- str\n\n****\n```python\nnew_events = [{\"event\": \"\"}, {\"event\": \"7\"}]\nupdate_running_summary(new_events)\n# \"\\n7\"\n```\n\n**update_running_summary**\nnew_events\n\n1. Configcfg\n2. new_eventsself.summary_message()\n3. new_events\n4. new_events\"assistant\"\"you\"\"content\"\"thoughts\"\n5. \"system\"\"your computer\"\n6. \"user\"new_events\n7. prompt\n8. ChatSequence.for_modelcfg.fast_llm_modelChatSequenceprompt\n9. prompt\n10. create_chat_completionprompt\n11. \n12. self.summary_message()\n\n****\n- new_eventsnew_events\n- Configcfg\n- self.summary_message()\n\n****\n\n7",
            "code_start_line": 288,
            "code_end_line": 369,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def update_running_summary(self, new_events: list[Message]) -> Message:\n        \"\"\"\n        This function takes a list of dictionaries representing new events and combines them with the current summary,\n        focusing on key and potentially important information to remember. The updated summary is returned in a message\n        formatted in the 1st person past tense.\n\n        Args:\n            new_events (List[Dict]): A list of dictionaries containing the latest events to be added to the summary.\n\n        Returns:\n            str: A message containing the updated summary of actions, formatted in the 1st person past tense.\n\n        Example:\n            new_events = [{\"event\": \"entered the kitchen.\"}, {\"event\": \"found a scrawled note with the number 7\"}]\n            update_running_summary(new_events)\n            # Returns: \"This reminds you of these events from your past: \\nI entered the kitchen and found a scrawled note saying 7.\"\n        \"\"\"\n        cfg = Config()\n\n        if not new_events:\n            return self.summary_message()\n\n        # Create a copy of the new_events list to prevent modifying the original list\n        new_events = copy.deepcopy(new_events)\n\n        # Replace \"assistant\" with \"you\". This produces much better first person past tense results.\n        for event in new_events:\n            if event.role.lower() == \"assistant\":\n                event.role = \"you\"\n\n                # Remove \"thoughts\" dictionary from \"content\"\n                try:\n                    content_dict = json.loads(event.content)\n                    if \"thoughts\" in content_dict:\n                        del content_dict[\"thoughts\"]\n                    event.content = json.dumps(content_dict)\n                except json.decoder.JSONDecodeError:\n                    if cfg.debug_mode:\n                        logger.error(f\"Error: Invalid JSON: {event.content}\\n\")\n\n            elif event.role.lower() == \"system\":\n                event.role = \"your computer\"\n\n            # Delete all user messages\n            elif event.role == \"user\":\n                new_events.remove(event)\n\n        prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\nSummary So Far:\n\"\"\"\n{self.summary}\n\"\"\"\n\nLatest Development:\n\"\"\"\n{new_events or \"Nothing new happened.\"}\n\"\"\"\n'''\n\n        prompt = ChatSequence.for_model(cfg.fast_llm_model, [Message(\"user\", prompt)])\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            prompt.raw(),\n            PROMPT_SUMMARY_FILE_NAME,\n        )\n\n        self.summary = create_chat_completion(prompt)\n\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            self.summary,\n            SUMMARY_FILE_NAME,\n        )\n\n        return self.summary_message()",
            "name_column": 8
        }
    },
    "XAgent/toolserver_interface.py": {
        "is_wrapped_response": {
            "type": "FunctionDef",
            "name": "is_wrapped_response",
            "md_content": "**is_wrapped_response**\n\nobjTrueFalse\n\nobj'type'['simple', 'composite', 'binary']'data'\n\nXAgent/toolserver_interface.pyunwrap_tool_responseunwrap_tool_responseunwrap_tool_responseobjis_wrapped_responseTrueobj'type''type''simple'obj'data''type''binary''data''media_type''name''media_type''file_name''type''composite'unwrap_tool_response'data'is_wrapped_responseFalseobj\n\nis_wrapped_responseobjobjobjobjNoneNoneobjNone\n\n****\n- obj\n- obj'type''data'\n- 'type'['simple', 'composite', 'binary']\n\n****\n```python\nTrue\n```",
            "code_start_line": 14,
            "code_end_line": 26,
            "parent": null,
            "have_return": true,
            "code_content": "def is_wrapped_response(obj: dict) -> bool:\n    \"\"\"\n    Check if the response object is wrapped.\n\n    Args:\n        obj (dict): The response object.\n\n    Returns:\n        bool: True if the response object is wrapped, False otherwise.\n    \"\"\"\n    if 'type' in obj and obj['type'] in ['simple', 'composite', 'binary'] and 'data' in obj:\n        return True\n    return False\n",
            "name_column": 4
        },
        "unwrap_tool_response": {
            "type": "FunctionDef",
            "name": "unwrap_tool_response",
            "md_content": "**unwrap_tool_response**\n\n\n- obj\n- logger\n\n\n\n\n- objis_wrapped_responseobj['type']\n  - obj['type']'simple'obj['data']\n  - obj['type']'binary'objnameobj['media_type']'.png''.png'obj['data']\n  - obj['type']'composite'obj['data']unwrap_tool_response\n- objobj\n- objNoneNone\n- objlogger\"Unknown type {type(obj)} in unwrap_tool_response\"None\n\n****\n- is_wrapped_response\n- \n\n****\n```python\n{\n    'media_type': 'image/png',\n    'file_name': 'example.png'\n}\n```",
            "code_start_line": 29,
            "code_end_line": 66,
            "parent": null,
            "have_return": true,
            "code_content": "def unwrap_tool_response(obj, logger=None):\n    \"\"\"\n    Unwrap the tool response object.\n\n    Args:\n        obj: The tool response object.\n        logger: The logger.\n\n    Returns:\n        The unwrapped tool response object.\n    \"\"\"\n    if isinstance(obj, dict):\n        if is_wrapped_response(obj):\n            match obj['type']:\n                case 'simple':\n                    return obj['data']\n                case 'binary':\n                    name = obj.get('name', uuid.uuid4().hex)\n                    if obj['media_type'] == 'image/png' and not str(name).endswith('.png'):\n                        name += '.png'\n                    with open(os.path.join('local_workspace', name), 'wb') as f:\n                        f.write(base64.b64decode(obj['data']))\n                    return {\n                        'media_type': obj['media_type'],\n                        'file_name': name\n                    }\n                case 'composite':\n                    return [unwrap_tool_response(o, logger) for o in obj['data']]\n        else:\n            return obj\n    elif isinstance(obj, (str, int, float, bool, list)):\n        return obj\n    elif obj is None:\n        return None\n    else:\n        logger.typewriter_log(\n            f'Unknown type {type(obj)} in unwrap_tool_response', Fore.YELLOW)\n        return None\n",
            "name_column": 4
        },
        "ToolServerInterface": {
            "type": "ClassDef",
            "name": "ToolServerInterface",
            "md_content": "**ToolServerInterface**: ToolServer\n\nToolServerToolServer\n\nRunningRecoderloggerRunningRecoderself.recorderloggerself.logger\n\nlazy_initToolServerconfigToolServerconfigToolServerself.urlconfigToolServerURLNotImplementedErrorToolServerself.urlPOSTToolServercookiecookieself.cookies\n\ncloseToolServerself.urlPOSTToolServer\n\nupload_fileToolServerfile_pathURLrequestsURLPOSTmultipart/form-dataJSON\n\ndownload_fileToolServerfile_pathURLpayloadrequestsURLPOSTpayloadJSON\n\nget_workspace_structureToolServerURLrequestsURLPOSTJSON\n\ndownload_all_filesToolServerURLrequestsURLPOST\n\nget_available_toolsToolServerURLrequestsURLPOSTJSON\n\nretrieve_rapidapi_toolsToolServerRapidAPIquerytop_kURLpayloadtop_krequestsURLPOSTpayloadJSON\n\nget_json_schema_for_toolsJSONcommand_namesJSONURLpayloadJSONrequestsURLPOSTpayloadJSONJSON\n\nexecute_command_clientToolServercommand_nameargumentsURLpayloadrequestsURLPOSTpayloadJSONJSON\n\n****: ToolServerupload_filedownload_fileget_available_toolsretrieve_rapidapi_toolsget_json_schema_for_toolsexecute_command_client\n\n****:\n```\n{\n    \"tool_name\": \"tool1\",\n    \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n    }\n}\n```",
            "code_start_line": 69,
            "code_end_line": 364,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolServerInterface():\n    \"\"\"\n    The interface to communicate with the ToolServer.\n    \"\"\"\n\n    def __init__(self, recorder: RunningRecoder, logger=None):\n        self.recorder = recorder\n        self.logger = logger\n\n    def lazy_init(self, config):\n        \"\"\"\n        Lazy initialization of the ToolServer interface.\n\n        Args:\n            config: The configuration for the ToolServer.\n\n        Raises:\n            NotImplementedError: If trying to use a non-selfhost ToolServer.\n        \"\"\"\n        self.config = config\n        if config.use_selfhost_toolserver:\n            self.url = config.selfhost_toolserver_url\n        else:\n            raise NotImplementedError('Please use selfhost toolserver')\n        self.logger.typewriter_log(\"ToolServer connected in\", Fore.RED, self.url)\n        response = requests.post(f'{self.url}/get_cookie',)\n        self.cookies = response.cookies\n\n    def close(self):\n        \"\"\"\n        Close the ToolServer session.\n        \"\"\"\n        requests.post(f'{self.url}/close_session', cookies=self.cookies)\n\n    def upload_file(self, file_path) -> str:\n        \"\"\"\n        Upload a file to the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be uploaded.\n\n        Returns:\n            str: The response from the ToolServer.\n        \"\"\"\n        url = f\"{self.url}/upload_file\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,\n                                 files={'file': open(file_path, 'rb'), 'filename': os.path.basename(file_path)})\n        response.raise_for_status()\n        response = response.json()\n        return response\n\n    def download_file(self, file_path) -> str:\n        \"\"\"\n        Download a file from the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be downloaded.\n\n        Returns:\n            str: The save path of the downloaded file.\n        \"\"\"\n        url = f\"{self.url}/download_file\"\n        payload = {\n            'file_path': file_path\n        }\n        response = requests.post(\n            url, json=payload, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(self.recorder.record_root_dir, file_path)\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n\n    def get_workspace_structure(self) -> dict:\n        \"\"\"\n        Get the structure of the workspace from the ToolServer.\n\n        Returns:\n            dict: The structure of the workspace.\n        \"\"\"\n        url = f\"{self.url}/get_workspace_structure\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n        response = response.json()\n        return response\n\n    def download_all_files(self):\n        \"\"\"\n        Download all the files in the workspace from the ToolServer.\n\n        Returns:\n            str: The save path of the downloaded workspace.\n        \"\"\"\n        url = f\"{self.url}/download_workspace\"\n        response = requests.post(url, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(\n            self.recorder.record_root_dir, 'workspace.zip')\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n\n    def get_available_tools(self):\n        \"\"\"\n        Get the available tools from the ToolServer.\n\n        Returns:\n            The available tools.\n        \"\"\"\n        payload = {\n        }\n        url = f\"{self.url}/get_available_tools\"\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"response_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response.raise_for_status()\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            return response\n        except Exception as e:\n            raise Exception(f\"Error when fetching available tools: {e}\")\n\n    def retrieve_rapidapi_tools(self, query: str, top_k: int = 10):\n        \"\"\"\n        Retrieve RapidAPI tools from the ToolServer.\n\n        Args:\n            query (str): The query for retrieving tools.\n            top_k (int, optional): The number of tools to retrieve. Defaults to 10.\n\n        Returns:\n            The retrieved tools and the description of the tools in JSON format.\n        \"\"\"\n        url = f\"{self.url}/retrieving_tools\"\n        payload = {\n            \"question\": query,\n            \"top_k\": top_k\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=20, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            retrieved_tools = response[\"retrieved_tools\"]\n            tools_json = response[\"tools_json\"]\n            for tool_json in tools_json:\n                function_manager.register_function(tool_json)\n        except Exception as e:\n            self.logger.typewriter_log(\n                \"Tool Retrieval Failed, nothing will be retrieved, please fix here.\",\n                Fore.RED,\n            )\n            print(f\"Error when retrieving tools: {e}\")\n            print(response)\n            return None, None\n\n        return retrieved_tools, tools_json\n\n    def get_json_schema_for_tools(self, command_names):\n        \"\"\"\n        Get the JSON schema for the specified tools from the ToolServer.\n\n        Args:\n            command_names: The names of the tools.\n\n        Returns:\n            The JSON schema for the tools.\n        \"\"\"\n        url = f\"{self.url}/get_json_schema_for_tools\"\n        payload = {\n            \"tool_names\": command_names\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    try:\n                        response = json.loads(response)\n                    except:\n                        pass\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            function_manager.register_function(response)\n            return response\n\n        except Exception as e:\n            print(f\"Error when fetching openai function jsons: {e}\")\n            return None\n\n    # @func_set_timeout()\n\n    def execute_command_client(\n        self,\n        command_name,\n        arguments={},\n        # input_hash_id,\n    ):\n        \"\"\"\n        Execute a command on the ToolServer.\n\n        Args:\n            command_name (str): The name of the command.\n            arguments (dict, optional): The arguments for the command. Defaults to {}.\n            input_hash_id: The hash ID of the input.\n\n        Returns:\n            mixed: The result of the command and the tool output status code.\n        \"\"\"\n        # return \"sorry, the server is not available now\", ToolCallStatusCode.SERVER_ERROR, input_hash_id\n        url = f\"{self.url}/execute_tool\"\n        if isinstance(arguments, str):\n            try:\n                arguments = json.loads(arguments)\n            except:\n                pass\n        payload = {\n            \"tool_name\": command_name,\n            \"arguments\": arguments,\n            # \"hash_id\": input_hash_id,\n        }\n\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n\n        if self.config['experiment']['redo_action'] or cache_output is None:\n            response = requests.post(url, json=payload, cookies=self.cookies)\n            response_status_code = response.status_code\n            if response.status_code == 200 or response.status_code == 450:\n                command_result = response.json()\n                command_result = unwrap_tool_response(command_result, self.logger)\n            else:\n                command_result = response.text\n\n        if cache_output != None:\n            command_result = cache_output[\"tool_output\"]\n            response_status_code = cache_output[\"response_status_code\"]\n\n        self.recorder.regist_tool_server(url=url,\n                                         payload=payload,\n                                         tool_output=command_result,\n                                         response_status_code=response_status_code)\n\n        # setting tool_output_status_code according to status_code\n        if response_status_code == 200:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        elif response_status_code == 404:\n            tool_output_status_code = ToolCallStatusCode.HALLUCINATE_NAME\n        elif response_status_code == 422:\n            tool_output_status_code = ToolCallStatusCode.FORMAT_ERROR\n        elif response_status_code == 450:\n            tool_output_status_code = ToolCallStatusCode.TIMEOUT_ERROR\n        elif response_status_code == 500:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_FAILED\n        elif response_status_code == 503:\n            tool_output_status_code = ToolCallStatusCode.SERVER_ERROR\n            raise Exception(\"Server Error: \" + command_result)\n        else:\n            tool_output_status_code = ToolCallStatusCode.OTHER_ERROR\n\n        return command_result, tool_output_status_code",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**ToolserverInterface\n\nrecorderloggerrecorderRunningRecoderlogger\n\nrecorderself.recorderloggerself.logger\n\n****RunningRecoderrecorderlogger",
            "code_start_line": 74,
            "code_end_line": 76,
            "parent": "ToolServerInterface",
            "have_return": false,
            "code_content": "    def __init__(self, recorder: RunningRecoder, logger=None):\n        self.recorder = recorder\n        self.logger = logger\n",
            "name_column": 8
        },
        "lazy_init": {
            "type": "FunctionDef",
            "name": "lazy_init",
            "md_content": "**lazy_init**ToolServer\n\nconfigToolServer\n\nconfiguse_selfhost_toolserverTrueselfhost_toolserver_urlurlNotImplementedErrorselfhost toolserver\n\nrequestsself.urlPOST\"{self.url}/get_cookie\"cookiesself.cookies\n\nself.logger.typewriter_log\"ToolServer connected in\"self.url\n\n****\n- ToolServerconfig\n- selfhost ToolServerNotImplementedErrorselfhost ToolServer",
            "code_start_line": 78,
            "code_end_line": 95,
            "parent": "ToolServerInterface",
            "have_return": false,
            "code_content": "    def lazy_init(self, config):\n        \"\"\"\n        Lazy initialization of the ToolServer interface.\n\n        Args:\n            config: The configuration for the ToolServer.\n\n        Raises:\n            NotImplementedError: If trying to use a non-selfhost ToolServer.\n        \"\"\"\n        self.config = config\n        if config.use_selfhost_toolserver:\n            self.url = config.selfhost_toolserver_url\n        else:\n            raise NotImplementedError('Please use selfhost toolserver')\n        self.logger.typewriter_log(\"ToolServer connected in\", Fore.RED, self.url)\n        response = requests.post(f'{self.url}/get_cookie',)\n        self.cookies = response.cookies\n",
            "name_column": 8
        },
        "close": {
            "type": "FunctionDef",
            "name": "close",
            "md_content": "**close**: ToolServer\n\nPOSTToolServerURLself.url'/close_session'cookiescookiesToolServerInterface\n\nXAgent/core.pyclosetoolserver_interfacedownload_all_filestoolserver_interfaceclose\n\n****: \n- closedownload_all_files\n- ToolServerInterfaceURLcookies",
            "code_start_line": 97,
            "code_end_line": 101,
            "parent": "ToolServerInterface",
            "have_return": false,
            "code_content": "    def close(self):\n        \"\"\"\n        Close the ToolServer session.\n        \"\"\"\n        requests.post(f'{self.url}/close_session', cookies=self.cookies)\n",
            "name_column": 8
        },
        "upload_file": {
            "type": "FunctionDef",
            "name": "upload_file",
            "md_content": "**upload_file**ToolServer\n\nfile_path\n\nURLrequestsPOSTToolServerToolServer\n\n****ToolServerfile_path\n\n****ToolServer\"Upload successful\"\"Upload successful\"",
            "code_start_line": 103,
            "code_end_line": 118,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def upload_file(self, file_path) -> str:\n        \"\"\"\n        Upload a file to the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be uploaded.\n\n        Returns:\n            str: The response from the ToolServer.\n        \"\"\"\n        url = f\"{self.url}/upload_file\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,\n                                 files={'file': open(file_path, 'rb'), 'filename': os.path.basename(file_path)})\n        response.raise_for_status()\n        response = response.json()\n        return response\n",
            "name_column": 8
        },
        "download_file": {
            "type": "FunctionDef",
            "name": "download_file",
            "md_content": "**download_file**ToolServer\n\nfile_path\n\nURLfile_pathpayloadToolServerPOSTcookies\n\nsave_pathsave_path\n\nsave_path\n\n****ToolServerURLcookies\n\n****\"/Users/logic/Documents/THUNLP/XAgent/XAgent/recordings/file.txt\"\"/Users/logic/Documents/THUNLP/XAgent/XAgent/recordings/file.txt\"",
            "code_start_line": 120,
            "code_end_line": 142,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def download_file(self, file_path) -> str:\n        \"\"\"\n        Download a file from the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be downloaded.\n\n        Returns:\n            str: The save path of the downloaded file.\n        \"\"\"\n        url = f\"{self.url}/download_file\"\n        payload = {\n            'file_path': file_path\n        }\n        response = requests.post(\n            url, json=payload, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(self.recorder.record_root_dir, file_path)\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n",
            "name_column": 8
        },
        "get_workspace_structure": {
            "type": "FunctionDef",
            "name": "get_workspace_structure",
            "md_content": "**get_workspace_structure**ToolServer\n\nToolServerPOSTURL`{self.url}/get_workspace_structure`10cookiesJSON\n\n****\n- ToolServerURLToolServer\n- ToolServercookies\n\n****\n```python\n{\n    \"workspace\": {\n        \"name\": \"MyWorkspace\",\n        \"folders\": [\n            {\n                \"name\": \"Folder1\",\n                \"files\": [\n                    {\n                        \"name\": \"File1.txt\",\n                        \"size\": \"10KB\"\n                    },\n                    {\n                        \"name\": \"File2.txt\",\n                        \"size\": \"5KB\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"Folder2\",\n                \"files\": [\n                    {\n                        \"name\": \"File3.txt\",\n                        \"size\": \"8KB\"\n                    }\n                ]\n            }\n        ]\n    }\n}\n```",
            "code_start_line": 144,
            "code_end_line": 155,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def get_workspace_structure(self) -> dict:\n        \"\"\"\n        Get the structure of the workspace from the ToolServer.\n\n        Returns:\n            dict: The structure of the workspace.\n        \"\"\"\n        url = f\"{self.url}/get_workspace_structure\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n        response = response.json()\n        return response\n",
            "name_column": 8
        },
        "download_all_files": {
            "type": "FunctionDef",
            "name": "download_all_files",
            "md_content": "**download_all_files**ToolServer\n\nURLPOSTURL\n\nURLURLself.url/download_workspaceself.urlToolServerURL/download_workspaceURL\n\nrequestsPOSTURLcookiesrequests.postPOSTresponse\n\nresponse.raise_for_status()\n\nsave_pathos.path.joinself.recorder.record_root_dir'workspace.zip'self.recorder.record_root_dir'workspace.zip'\n\nos.makedirs\n\nwith open\n\nsave_path\n\n****ToolServerURLcookies\n\n****'/path/to/workspace.zip''/path/to/workspace.zip'",
            "code_start_line": 157,
            "code_end_line": 173,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def download_all_files(self):\n        \"\"\"\n        Download all the files in the workspace from the ToolServer.\n\n        Returns:\n            str: The save path of the downloaded workspace.\n        \"\"\"\n        url = f\"{self.url}/download_workspace\"\n        response = requests.post(url, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(\n            self.recorder.record_root_dir, 'workspace.zip')\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n",
            "name_column": 8
        },
        "get_available_tools": {
            "type": "FunctionDef",
            "name": "get_available_tools",
            "md_content": "**get_available_tools**ToolServer\n\npayloadself.urlurlself.recorder.query_tool_server_cacheToolServerurlpayloadresponsestatus_coderequestsPOSTurlpayloadtimeoutcookies200JSONresponseJSONself.recorder.regist_tool_serverurlpayload\n\n****ToolServerURLpayloadcookies\n\n****\n```\n{\n    \"available_tools\": [\"tool1\", \"tool2\", \"tool3\"],\n    \"tools_json\": {\n        \"tool1\": {\n            \"name\": \"tool1\",\n            \"description\": \"This is tool1\"\n        },\n        \"tool2\": {\n            \"name\": \"tool2\",\n            \"description\": \"This is tool2\"\n        },\n        \"tool3\": {\n            \"name\": \"tool3\",\n            \"description\": \"This is tool3\"\n        }\n    }\n}\n```\n",
            "code_start_line": 175,
            "code_end_line": 206,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def get_available_tools(self):\n        \"\"\"\n        Get the available tools from the ToolServer.\n\n        Returns:\n            The available tools.\n        \"\"\"\n        payload = {\n        }\n        url = f\"{self.url}/get_available_tools\"\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"response_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response.raise_for_status()\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            return response\n        except Exception as e:\n            raise Exception(f\"Error when fetching available tools: {e}\")\n",
            "name_column": 8
        },
        "retrieve_rapidapi_tools": {
            "type": "FunctionDef",
            "name": "retrieve_rapidapi_tools",
            "md_content": "**retrieve_rapidapi_tools**ToolServerRapidAPI\n\n\n- querystr\n- top_kint10\n\nJSON\n\n\n- URLpayload\n- self.recorder.query_tool_server_cache\n- responsestatus_code\n- POSTToolServerresponse\n- self.recorder\n- function_manager\n\n\n- None\n\n\n```\nretrieved_tools = [\"Tool1\", \"Tool2\", \"Tool3\"]\ntools_json = [\n    {\n        \"name\": \"Tool1\",\n        \"description\": \"This is Tool1\"\n    },\n    {\n        \"name\": \"Tool2\",\n        \"description\": \"This is Tool2\"\n    },\n    {\n        \"name\": \"Tool3\",\n        \"description\": \"This is Tool3\"\n    }\n]\n```",
            "code_start_line": 208,
            "code_end_line": 253,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def retrieve_rapidapi_tools(self, query: str, top_k: int = 10):\n        \"\"\"\n        Retrieve RapidAPI tools from the ToolServer.\n\n        Args:\n            query (str): The query for retrieving tools.\n            top_k (int, optional): The number of tools to retrieve. Defaults to 10.\n\n        Returns:\n            The retrieved tools and the description of the tools in JSON format.\n        \"\"\"\n        url = f\"{self.url}/retrieving_tools\"\n        payload = {\n            \"question\": query,\n            \"top_k\": top_k\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=20, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            retrieved_tools = response[\"retrieved_tools\"]\n            tools_json = response[\"tools_json\"]\n            for tool_json in tools_json:\n                function_manager.register_function(tool_json)\n        except Exception as e:\n            self.logger.typewriter_log(\n                \"Tool Retrieval Failed, nothing will be retrieved, please fix here.\",\n                Fore.RED,\n            )\n            print(f\"Error when retrieving tools: {e}\")\n            print(response)\n            return None, None\n\n        return retrieved_tools, tools_json\n",
            "name_column": 8
        },
        "get_json_schema_for_tools": {
            "type": "FunctionDef",
            "name": "get_json_schema_for_tools",
            "md_content": "**get_json_schema_for_tools**: ToolServerJSON\n\ncommand_names\n\nURLpayload\n\nrecorderquery_tool_server_cacheURLpayloadPOSTURLpayloadJSON10cookies\n\nJSONJSON\n\nrecorderregist_tool_serverURLpayloadrecorder\n\nfunction_managerregister_functionfunction_manager\n\n\n\nNone\n\n****: \n- ToolServerURL\n- ToolServercookies\n- ToolServerJSON\n\n****\n\n```python\n{\n    \"tool1\": {\n        \"input\": {\n            \"type\": \"string\",\n            \"description\": \"Input string\"\n        },\n        \"output\": {\n            \"type\": \"string\",\n            \"description\": \"Output string\"\n        }\n    },\n    \"tool2\": {\n        \"input\": {\n            \"type\": \"number\",\n            \"description\": \"Input number\"\n        },\n        \"output\": {\n            \"type\": \"number\",\n            \"description\": \"Output number\"\n        }\n    }\n}\n```",
            "code_start_line": 255,
            "code_end_line": 293,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def get_json_schema_for_tools(self, command_names):\n        \"\"\"\n        Get the JSON schema for the specified tools from the ToolServer.\n\n        Args:\n            command_names: The names of the tools.\n\n        Returns:\n            The JSON schema for the tools.\n        \"\"\"\n        url = f\"{self.url}/get_json_schema_for_tools\"\n        payload = {\n            \"tool_names\": command_names\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    try:\n                        response = json.loads(response)\n                    except:\n                        pass\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            function_manager.register_function(response)\n            return response\n\n        except Exception as e:\n            print(f\"Error when fetching openai function jsons: {e}\")\n            return None\n",
            "name_column": 8
        },
        "execute_command_client": {
            "type": "FunctionDef",
            "name": "execute_command_client",
            "md_content": "**execute_command_client**ToolServer\n\n\n- command_namestr\n- argumentsdict{}\n- input_hash_idID\n\n\n- mixed\n\n\n- URL\n- argumentsJSON\n- payloadtool_namearguments\n- self.recorder.query_tool_server_cache\n- self.config['experiment']['redo_action']TruePOSTToolServer\n- \n  - 200450JSON\n  - \n- \n- self.recorder.regist_tool_serverURLpayload\n- \n- \n\n****\n- command_namearguments\n- \n\n****(\"Command result\", ToolCallStatusCode.TOOL_CALL_SUCCESS)",
            "code_start_line": 297,
            "code_end_line": 364,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def execute_command_client(\n        self,\n        command_name,\n        arguments={},\n        # input_hash_id,\n    ):\n        \"\"\"\n        Execute a command on the ToolServer.\n\n        Args:\n            command_name (str): The name of the command.\n            arguments (dict, optional): The arguments for the command. Defaults to {}.\n            input_hash_id: The hash ID of the input.\n\n        Returns:\n            mixed: The result of the command and the tool output status code.\n        \"\"\"\n        # return \"sorry, the server is not available now\", ToolCallStatusCode.SERVER_ERROR, input_hash_id\n        url = f\"{self.url}/execute_tool\"\n        if isinstance(arguments, str):\n            try:\n                arguments = json.loads(arguments)\n            except:\n                pass\n        payload = {\n            \"tool_name\": command_name,\n            \"arguments\": arguments,\n            # \"hash_id\": input_hash_id,\n        }\n\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n\n        if self.config['experiment']['redo_action'] or cache_output is None:\n            response = requests.post(url, json=payload, cookies=self.cookies)\n            response_status_code = response.status_code\n            if response.status_code == 200 or response.status_code == 450:\n                command_result = response.json()\n                command_result = unwrap_tool_response(command_result, self.logger)\n            else:\n                command_result = response.text\n\n        if cache_output != None:\n            command_result = cache_output[\"tool_output\"]\n            response_status_code = cache_output[\"response_status_code\"]\n\n        self.recorder.regist_tool_server(url=url,\n                                         payload=payload,\n                                         tool_output=command_result,\n                                         response_status_code=response_status_code)\n\n        # setting tool_output_status_code according to status_code\n        if response_status_code == 200:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        elif response_status_code == 404:\n            tool_output_status_code = ToolCallStatusCode.HALLUCINATE_NAME\n        elif response_status_code == 422:\n            tool_output_status_code = ToolCallStatusCode.FORMAT_ERROR\n        elif response_status_code == 450:\n            tool_output_status_code = ToolCallStatusCode.TIMEOUT_ERROR\n        elif response_status_code == 500:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_FAILED\n        elif response_status_code == 503:\n            tool_output_status_code = ToolCallStatusCode.SERVER_ERROR\n            raise Exception(\"Server Error: \" + command_result)\n        else:\n            tool_output_status_code = ToolCallStatusCode.OTHER_ERROR\n\n        return command_result, tool_output_status_code",
            "name_column": 8
        }
    },
    "XAgent/spinner.py": {
        "Spinner": {
            "type": "ClassDef",
            "name": "Spinner",
            "md_content": "**Spinner**: with\n\n:\n- delay (float): \n- message (str): \n- plain_output (bool): \n- running (bool): \n- spinner (iter): \n- spinner_thread (Thread): \n\n****: \n\n****: \n\nSpinner\"Loading...\"0.1False\n\n:\n\n- `__init__(self, message: str = \"Loading...\", delay: float = 0.1, plain_output: bool = False) -> None`: \n\n- `spin(self) -> None`: True\n\n- `print_message(self)`: \n\n- `__enter__(self)`: True\n\n- `__exit__(self, exc_type, exc_value, exc_traceback) -> None`: \n\n- `update_message(self, new_message, delay=0.1)`: \n\n:\n```python\nwith Spinner(\"Loading...\", 0.1, False) as spinner:\n    # \n    spinner.update_message(\"Processing...\", 0.2)\n    # \n```\n\n****: Spinner`update_message``with`\n\n****:\n```\n- Loading...\n/ Loading...\n| Loading...\n\\ Loading...\n```\n\n",
            "code_start_line": 8,
            "code_end_line": 96,
            "parent": null,
            "have_return": true,
            "code_content": "class Spinner:\n    \"\"\"\n    A simple class for implementing a spinner functionality. It starts a new\n    thread on initialization and can be used in with statement.\n    \n    Attributes:\n        delay (float): The delay between each spinner update.\n        message (str): The message to display along with the spinner.\n        plain_output (bool): Whether to display the spinner or not.\n        running (bool): Indicates whether the spinner is currently running.\n        spinner (iter): An infinite iterator cycling over spinner characters.\n        spinner_thread (Thread): The thread on which the spinner is running.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str = \"Loading...\",\n        delay: float = 0.1,\n        plain_output: bool = False,\n    ) -> None:\n        \"\"\"Initializes the spinner with the given message, delay, and output type.\n\n        Args:\n            message (str): The message to display. Defaults to 'Loading...'.\n            delay (float): The delay in seconds between each spinner update. Defaults to 0.1.\n            plain_output (bool): If True, the spinner will not be displayed.\n                                  Defaults to False.\n        \"\"\"\n        self.plain_output = plain_output\n        self.spinner = itertools.cycle([\"-\", \"/\", \"|\", \"\\\\\"])\n        self.delay = delay\n        self.message = message\n        self.running = False\n        self.spinner_thread = None\n\n    def spin(self) -> None:\n        \"\"\"Runs the spinner while it is marked as running.\n\n        If plain_output is set to True, it will only print the message and return.\n        \"\"\"\n        if self.plain_output:\n            self.print_message()\n            return\n        while self.running:\n            self.print_message()\n            time.sleep(self.delay)\n\n    def print_message(self):\n        \"\"\"\n        Prints the message with spinner symbol at the beginning and then erases it.\n        \"\"\"\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.write(f\"{next(self.spinner)} {self.message}\\r\")\n        sys.stdout.flush()\n\n    def __enter__(self):\n        \"\"\"Sets the running marker to True and starts the spinner thread.\"\"\"\n        self.running = True\n        self.spinner_thread = threading.Thread(target=self.spin)\n        self.spinner_thread.start()\n\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_traceback) -> None:\n        \"\"\"Stops the spinner.\n\n        Args:\n            exc_type (Exception): The exception type.\n            exc_value (Exception): The exception value.\n            exc_traceback (Exception): The exception traceback.\n        \"\"\"\n        self.running = False\n        if self.spinner_thread is not None:\n            self.spinner_thread.join()\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.flush()\n\n    def update_message(self, new_message, delay=0.1):\n        \"\"\"Updates the message and the delay for the spinner.\n\n        Args:\n            new_message (str): New message to display.\n            delay (float): The delay in seconds between each spinner update.\n                           Defaults to 0.1.\n        \"\"\"\n        self.delay = delay\n        self.message = new_message\n        if self.plain_output:\n            self.print_message()",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Spinner\n\n\n- message (str)'Loading...'\n- delay (float)Spinner0.1\n- plain_output (bool)TrueSpinnerFalse\n\n\n- self.plain_outputSpinnerplain_output\n- self.spinnerSpinneritertools.cycle\"-\", \"/\", \"|\", \"\\\\\"\n- self.delaySpinnerdelay\n- self.messagemessage\n- self.runningSpinnerFalse\n- self.spinner_threadSpinnerNone\n\n****\n- message\n- delaySpinner\n- plain_outputSpinnerTrueSpinner",
            "code_start_line": 22,
            "code_end_line": 41,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        message: str = \"Loading...\",\n        delay: float = 0.1,\n        plain_output: bool = False,\n    ) -> None:\n        \"\"\"Initializes the spinner with the given message, delay, and output type.\n\n        Args:\n            message (str): The message to display. Defaults to 'Loading...'.\n            delay (float): The delay in seconds between each spinner update. Defaults to 0.1.\n            plain_output (bool): If True, the spinner will not be displayed.\n                                  Defaults to False.\n        \"\"\"\n        self.plain_output = plain_output\n        self.spinner = itertools.cycle([\"-\", \"/\", \"|\", \"\\\\\"])\n        self.delay = delay\n        self.message = message\n        self.running = False\n        self.spinner_thread = None\n",
            "name_column": 8
        },
        "spin": {
            "type": "FunctionDef",
            "name": "spin",
            "md_content": "**spin**\n\nplain_outputTrue\n\ntime.sleep\n\n****\n- plain_outputTrue\n- delay\n\n****\n```\n[INFO] ...\n[INFO] ...\n[INFO] ...\n...\n```",
            "code_start_line": 43,
            "code_end_line": 53,
            "parent": "Spinner",
            "have_return": true,
            "code_content": "    def spin(self) -> None:\n        \"\"\"Runs the spinner while it is marked as running.\n\n        If plain_output is set to True, it will only print the message and return.\n        \"\"\"\n        if self.plain_output:\n            self.print_message()\n            return\n        while self.running:\n            self.print_message()\n            time.sleep(self.delay)\n",
            "name_column": 8
        },
        "print_message": {
            "type": "FunctionDef",
            "name": "print_message",
            "md_content": "**print_message**\n\nsys.stdout.writesys.stdout.flushsys.stdout.writesys.stdout.flush\n\n\nXAgent/spinner.py\n\n```python\ndef spin(self) -> None:\n    \"\"\"\n\n    plain_outputTrue\n    \"\"\"\n    if self.plain_output:\n        self.print_message()\n        return\n    while self.running:\n        self.print_message()\n        time.sleep(self.delay)\n```\nspinplain_outputTrueprint_messagewhileprint_messagetime.sleep\n\n```python\ndef update_message(self, new_message, delay=0.1):\n    \"\"\"\n\n    Args:\n        new_message (str): \n        delay (float): 0.1\n    \"\"\"\n    self.delay = delay\n    self.message = new_message\n    if self.plain_output:\n        self.print_message()\n```\nupdate_messagedelayself.delaynew_messageself.messageplain_outputTrueprint_message\n\n****\n- \n- update_message\n- runningFalse\n- update_messagedelay",
            "code_start_line": 55,
            "code_end_line": 61,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def print_message(self):\n        \"\"\"\n        Prints the message with spinner symbol at the beginning and then erases it.\n        \"\"\"\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.write(f\"{next(self.spinner)} {self.message}\\r\")\n        sys.stdout.flush()\n",
            "name_column": 8
        },
        "__enter__": {
            "type": "FunctionDef",
            "name": "__enter__",
            "md_content": "**__enter__**True\n\nPython`__enter__``__exit__`\n\n`running`True`spin`\n\n`self`\n\n****\n- \n- `__exit__`\n\n****\n```python\n<spinner.Spinner object at 0x7f9a2e9d3a90>\n```",
            "code_start_line": 63,
            "code_end_line": 69,
            "parent": "Spinner",
            "have_return": true,
            "code_content": "    def __enter__(self):\n        \"\"\"Sets the running marker to True and starts the spinner thread.\"\"\"\n        self.running = True\n        self.spinner_thread = threading.Thread(target=self.spin)\n        self.spinner_thread.start()\n\n        return self\n",
            "name_column": 8
        },
        "__exit__": {
            "type": "FunctionDef",
            "name": "__exit__",
            "md_content": "**__exit__**\n\nPython`__exit__`\n\n`exc_type``exc_value``exc_traceback`\n\n`running`False`join()``spinner_thread``sys.stdout.write()``sys.stdout.flush()`\n\n****\n- \n- `with`\n- `__exit__`\n\n`__exit__`",
            "code_start_line": 71,
            "code_end_line": 83,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def __exit__(self, exc_type, exc_value, exc_traceback) -> None:\n        \"\"\"Stops the spinner.\n\n        Args:\n            exc_type (Exception): The exception type.\n            exc_value (Exception): The exception value.\n            exc_traceback (Exception): The exception traceback.\n        \"\"\"\n        self.running = False\n        if self.spinner_thread is not None:\n            self.spinner_thread.join()\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.flush()\n",
            "name_column": 8
        },
        "update_message": {
            "type": "FunctionDef",
            "name": "update_message",
            "md_content": "**update_message**\n\n\n- new_message (str)\n- delay (float)0.1\n\ndelaymessageplain_outputTrueprint_message()\n\n****\n- update_message\n- 0.1\n- plain_outputTrueprint_message()",
            "code_start_line": 85,
            "code_end_line": 96,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def update_message(self, new_message, delay=0.1):\n        \"\"\"Updates the message and the delay for the spinner.\n\n        Args:\n            new_message (str): New message to display.\n            delay (float): The delay in seconds between each spinner update.\n                           Defaults to 0.1.\n        \"\"\"\n        self.delay = delay\n        self.message = new_message\n        if self.plain_output:\n            self.print_message()",
            "name_column": 8
        }
    },
    "XAgent/global_vars.py": {},
    "XAgent/data_structure/tree.py": {
        "TaskSearchTree": {
            "type": "ClassDef",
            "name": "TaskSearchTree",
            "md_content": "**TaskSearchTree**: TaskSearchTree\n\nTaskSearchTree\n- root (ToolNode): \n- now_expand_num (int): \n\nTaskSearchTree\n\n1. \\_\\_init\\_\\_()\n   - TaskSearchTree\n   - \n   - \n   - \n\n2. get_depth()\n   - \n   - \n   - int\n   - \n\n3. get_subtree_size()\n   - \n   - \n   - int\n   - \n\n4. make_father_relation(father, child)\n   - \n   - \n     - father (ToolNode): \n     - child (ToolNode): \n   - \n   - \n     - TypeError: fatherchildToolNode\n\n****\n- ToolNode\n\n****\n```python\ntree = TaskSearchTree()\ndepth = tree.get_depth()\nsubtree_size = tree.get_subtree_size()\nfather = ToolNode()\nchild = ToolNode()\ntree.make_father_relation(father, child)\n```",
            "code_start_line": 4,
            "code_end_line": 55,
            "parent": null,
            "have_return": true,
            "code_content": "class TaskSearchTree:\n    \"\"\"\n    TaskSearchTree represents a tree data structure with specific task searching behavior. \n\n    Attributes:\n        root (ToolNode): Root node of the tree.\n        now_expand_num (int): Maintains current expanding number for nodes during traversal.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initializes TaskSearchTree with a root ToolNode and default expanding number.\"\"\"\n        self.root: ToolNode = ToolNode()\n        self.root.expand_num = 0\n        self.now_expand_num = 1\n\n    def get_depth(self):\n        \"\"\"\n        Gets the depth of the tree from the current root node.\n\n        Returns:\n            int: The depth of the tree\n        \"\"\"\n        return self.root.get_depth()\n    \n    def get_subtree_size(self):\n        \"\"\"\n        Gets the number of nodes (or size) of the subtree from the current root node.\n\n        Returns:\n            int: The number of nodes in the subtree\n        \"\"\"\n        return self.root.get_subtree_size()\n    \n    def make_father_relation(self, father, child):\n        \"\"\"\n        Establishes a parent-child relationship between two given nodes.\n\n        Args:\n            father (ToolNode): The parent node in the relation.\n            child (ToolNode): The child node in the relation.\n\n        Raises:\n            TypeError: If the father or child is not a ToolNode instance.\n        \"\"\"\n        if not (isinstance(father, ToolNode) and isinstance(child, ToolNode)):\n            raise TypeError(\"Father and child both need to be instances of ToolNode.\")\n\n        child.expand_num = self.now_expand_num\n        self.now_expand_num += 1\n\n        child.father = father\n        father.children.append(child)",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**TaskSearchTreeToolNode\n\n__init__TaskSearchTreeToolNodeself.root01\n\nTaskSearchTree\n\n****\n- \n- expand_num\n- ",
            "code_start_line": 13,
            "code_end_line": 17,
            "parent": "TaskSearchTree",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"Initializes TaskSearchTree with a root ToolNode and default expanding number.\"\"\"\n        self.root: ToolNode = ToolNode()\n        self.root.expand_num = 0\n        self.now_expand_num = 1\n",
            "name_column": 8
        },
        "get_depth": {
            "type": "FunctionDef",
            "name": "get_depth",
            "md_content": "**get_depth**\n\nget_depth\n\n****\n- Tree\n- \n\n****33",
            "code_start_line": 19,
            "code_end_line": 26,
            "parent": "TaskSearchTree",
            "have_return": true,
            "code_content": "    def get_depth(self):\n        \"\"\"\n        Gets the depth of the tree from the current root node.\n\n        Returns:\n            int: The depth of the tree\n        \"\"\"\n        return self.root.get_depth()\n",
            "name_column": 8
        },
        "get_subtree_size": {
            "type": "FunctionDef",
            "name": "get_subtree_size",
            "md_content": "**get_subtree_size**\n\nget_subtree_size\n\n****\n- \n- \n\n****55",
            "code_start_line": 28,
            "code_end_line": 35,
            "parent": "TaskSearchTree",
            "have_return": true,
            "code_content": "    def get_subtree_size(self):\n        \"\"\"\n        Gets the number of nodes (or size) of the subtree from the current root node.\n\n        Returns:\n            int: The number of nodes in the subtree\n        \"\"\"\n        return self.root.get_subtree_size()\n",
            "name_column": 8
        },
        "make_father_relation": {
            "type": "FunctionDef",
            "name": "make_father_relation",
            "md_content": "**make_father_relation**\n\n\n- fatherToolNode\n- childToolNode\n\nfatherchildToolNodeTypeError\n\nfatherchildToolNodeTypeErrorfatherchildToolNode\n\nchildexpand_numexpand_numexpand_num1\n\nchildfatherfatherchildfatherchildren\n\n****\n- fatherchildToolNode\n- fatherchild",
            "code_start_line": 37,
            "code_end_line": 55,
            "parent": "TaskSearchTree",
            "have_return": false,
            "code_content": "    def make_father_relation(self, father, child):\n        \"\"\"\n        Establishes a parent-child relationship between two given nodes.\n\n        Args:\n            father (ToolNode): The parent node in the relation.\n            child (ToolNode): The child node in the relation.\n\n        Raises:\n            TypeError: If the father or child is not a ToolNode instance.\n        \"\"\"\n        if not (isinstance(father, ToolNode) and isinstance(child, ToolNode)):\n            raise TypeError(\"Father and child both need to be instances of ToolNode.\")\n\n        child.expand_num = self.now_expand_num\n        self.now_expand_num += 1\n\n        child.father = father\n        father.children.append(child)",
            "name_column": 8
        }
    },
    "XAgent/data_structure/plan.py": {
        "Plan": {
            "type": "ClassDef",
            "name": "Plan",
            "md_content": "**Plan**\n\nPlan\n\n:\n- father (Optional[Plan]): \n- children (List[Plan]): \n- data (TaskSaveItem): \n- process_node (ToolNode): \n\n:\n- `__init__(self, data: TaskSaveItem)`: Plan\n- `to_json(self, posterior=True) -> dict`: PlanJSON\n- `get_subtask_id(self, to_str=False) -> Union[list, str]`: ID\n- `get_subtask_id_list(self) -> List[int]`: ID\n- `get_root(self) -> Plan`: Plan\n- `get_depth(self) -> int`: Plan\n- `get_inorder_travel(cls, now_plan) -> List[Plan]`: Plan\n- `pop_next_subtask(cls, now_plan) -> Optional[Plan]`: \n- `get_remaining_subtask(cls, now_plan) -> List[Plan]`: \n- `make_relation(cls, father, child)`: \n\n****: Planto_jsonPlanJSONget_subtask_idIDget_rootPlanget_depthPlanget_inorder_travelPlan\n\n****:\n```\n{\n  \"father\": null,\n  \"children\": [],\n  \"data\": {\n    \"name\": \"task1\",\n    \"goal\": \"complete task1\",\n    ...\n  },\n  \"process_node\": null\n}\n```\n\n****: PlanJSON",
            "code_start_line": 5,
            "code_end_line": 152,
            "parent": null,
            "have_return": true,
            "code_content": "class Plan():\n    \"\"\"Class representing a task plan.\n\n    Attributes:\n        father (Optional[Plan]): Parent task plan.\n        children (List[Plan]): List of child task plans.\n        data (TaskSaveItem): Data items related to the task plan.\n        process_node (ToolNode): Node responsible for the task plan processing.\n    \"\"\"\n    \n    def __init__(self, data: TaskSaveItem):\n        \"\"\"Initialises a Plan object.\n\n        Args:\n            data (TaskSaveItem): Data related to the task plan.\n        \"\"\"\n        self.father: Optional[Plan] = None\n        self.children: List[Plan] = []\n        self.data: TaskSaveItem = data\n        self.process_node: ToolNode = None \n    \n    def to_json(self, posterior=True):\n        \"\"\"Converts Plan object to JSON.\n\n        Args:\n            posterior (bool): Determines whether the task's posterior data \n                              is also returned.\n\n        Returns:\n            root_json (dict): JSON format representation of the Plan object.\n        \"\"\"\n        root_json = self.data.to_json(posterior=posterior)\n        if self.process_node:\n            root_json[\"submit_result\"] = self.process_node.data[\"command\"][\"properties\"]\n\n        # if self.father != None:\n        root_json[\"task_id\"] = self.get_subtask_id(to_str=True)\n        if len(self.children) > 0:\n            root_json[\"subtask\"] = [ subtask.to_json() for subtask in self.children]\n        return root_json\n    \n    def get_subtask_id(self, to_str=False):\n        \"\"\"Gets the subtask ID.\n\n        Args:\n            to_str (bool): Determines if returned ID is string.\n\n        Returns:\n            subtask_id_list (list): List of subtask IDs.\n        \"\"\"\n        subtask_id_list = self.get_subtask_id_list()\n        if to_str:\n            subtask_id_list = [str(cont) for cont in subtask_id_list]\n            return \".\".join(subtask_id_list)\n        else:\n            return subtask_id_list\n\n    def get_subtask_id_list(self):\n        \"\"\"Gets the subtask ID list.\n\n        Returns:\n            Array of subtask IDs if father is not none else [1].\n        \"\"\"\n        if self.father == None:\n            return [1]\n        fahter_subtask_id = self.father.get_subtask_id()\n        child_id = self.father.children.index(self) + 1\n        fahter_subtask_id.append(child_id)\n        return fahter_subtask_id\n    \n    @classmethod\n    def make_relation(cls, father, child):\n        \"\"\"Establishes a parent-child relationship between two plans.\n\n        Args:\n            father: Parent plan.\n            child: Child plan.\n        \"\"\"\n        father.children.append(child)\n        child.father = father\n\n    def get_root(self):\n        \"\"\"Fetches the root of the Plan tree.\n\n        Returns:\n            Root Plan object.\n        \"\"\"\n        if self.father == None:\n            return self\n        return self.father.get_root()\n\n    def get_depth(self):\n        \"\"\"Returns the depth of the Plan tree.\n\n        Returns:\n            Tree depth as an integer.\n        \"\"\"\n        if self.father == None:\n            return 1\n        return 1 + self.father.get_depth()\n\n    @classmethod\n    def get_inorder_travel(cls, now_plan):\n        \"\"\"Performs an inorder traversal of the plan tree.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            All plans in the tree in inorder.\n        \"\"\"\n        result_list = [now_plan]\n        for child in now_plan.children:\n            result_list.extend(Plan.get_inorder_travel(child))\n        return result_list\n\n    @classmethod\n    def pop_next_subtask(cls, now_plan):\n        \"\"\"Fetches the next subtask in the queue.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Next subtask in the queue.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        for subtask in all_plans[order_id + 1:]:\n            if subtask.data.status == TaskStatusCode.TODO:\n                return subtask\n        return None\n\n    @classmethod\n    def get_remaining_subtask(cls, now_plan):\n        \"\"\"Gets all remaining subtasks from a given point.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Array of all remaining subtasks.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        return all_plans[order_id:]",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Plan\n\nTaskSaveItemdata\n\nfatherPlanchildrenPlandataTaskSaveItemprocess_nodeToolNode\n\n****\n- dataTaskSaveItem\n- fatherchildren\n- process_node",
            "code_start_line": 15,
            "code_end_line": 24,
            "parent": "Plan",
            "have_return": false,
            "code_content": "    def __init__(self, data: TaskSaveItem):\n        \"\"\"Initialises a Plan object.\n\n        Args:\n            data (TaskSaveItem): Data related to the task plan.\n        \"\"\"\n        self.father: Optional[Plan] = None\n        self.children: List[Plan] = []\n        self.data: TaskSaveItem = data\n        self.process_node: ToolNode = None \n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**: PlanJSON\n\nposterior\n\nroot_jsonPlanJSON\n\nself.data.to_json(posterior=posterior)PlandataJSONroot_json\n\nself.process_nodeself.process_node.data[\"command\"][\"properties\"]root_json\"submit_result\"\n\nself.get_subtask_id(to_str=True)root_json\"task_id\"\n\nself.children0self.childrento_json()root_json\"subtask\"\n\nroot_json\n\n****: \n- posterior\n- self.process_nodeself.process_node.data[\"command\"][\"properties\"]root_json\"submit_result\"\n- self.fatherNoneself.get_subtask_id(to_str=True)root_json\"task_id\"\n- self.children0self.childrento_json()root_json\"subtask\"\n\n****:\n```\n{\n  \"task_id\": \"123456\",\n  \"subtask\": [\n    {\n      \"task_id\": \"123456-1\",\n      \"name\": \"1\",\n      \"goal\": \"1\",\n      \"handler\": \"1\",\n      \"tool_budget\": 100,\n      \"subtask\": []\n    },\n    {\n      \"task_id\": \"123456-2\",\n      \"name\": \"2\",\n      \"goal\": \"2\",\n      \"handler\": \"2\",\n      \"tool_budget\": 200,\n      \"subtask\": []\n    }\n  ]\n}\n```",
            "code_start_line": 26,
            "code_end_line": 44,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def to_json(self, posterior=True):\n        \"\"\"Converts Plan object to JSON.\n\n        Args:\n            posterior (bool): Determines whether the task's posterior data \n                              is also returned.\n\n        Returns:\n            root_json (dict): JSON format representation of the Plan object.\n        \"\"\"\n        root_json = self.data.to_json(posterior=posterior)\n        if self.process_node:\n            root_json[\"submit_result\"] = self.process_node.data[\"command\"][\"properties\"]\n\n        # if self.father != None:\n        root_json[\"task_id\"] = self.get_subtask_id(to_str=True)\n        if len(self.children) > 0:\n            root_json[\"subtask\"] = [ subtask.to_json() for subtask in self.children]\n        return root_json\n",
            "name_column": 8
        },
        "get_subtask_id": {
            "type": "FunctionDef",
            "name": "get_subtask_id",
            "md_content": "**get_subtask_id**ID\n\n`to_str`ID\n\nID\n\n`to_str`TrueIDID\n\n****`to_str`FalseID[1, 2, 3][1, 2, 3]\n\n\n\nXAgent/data_structure/plan.py\n\n```python\nroot_json[\"task_id\"] = self.get_subtask_id(to_str=True)\n```\n\nXAgent/workflow/plan_exec.py\n\n```python\nsubtask_id = now_dealing_task.get_subtask_id(to_str=True)\n```\n\nXAgent/workflow/task_handler.py\n\n```python\ntask_id = self.now_dealing_task.get_subtask_id(to_str=True)\n```\n\nXAgent/workflow/working_memory.py\n\n```python\nsubtask_id = terminal_plan.get_subtask_id(to_str=True)\n```\n\n\n- Markdown\n- ",
            "code_start_line": 46,
            "code_end_line": 60,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_subtask_id(self, to_str=False):\n        \"\"\"Gets the subtask ID.\n\n        Args:\n            to_str (bool): Determines if returned ID is string.\n\n        Returns:\n            subtask_id_list (list): List of subtask IDs.\n        \"\"\"\n        subtask_id_list = self.get_subtask_id_list()\n        if to_str:\n            subtask_id_list = [str(cont) for cont in subtask_id_list]\n            return \".\".join(subtask_id_list)\n        else:\n            return subtask_id_list\n",
            "name_column": 8
        },
        "get_subtask_id_list": {
            "type": "FunctionDef",
            "name": "get_subtask_id_list",
            "md_content": "**get_subtask_id_list**ID\n\nID1IDID\n\n****\n- ID\n- \n\n****ID2ID3[2, 3]",
            "code_start_line": 62,
            "code_end_line": 73,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_subtask_id_list(self):\n        \"\"\"Gets the subtask ID list.\n\n        Returns:\n            Array of subtask IDs if father is not none else [1].\n        \"\"\"\n        if self.father == None:\n            return [1]\n        fahter_subtask_id = self.father.get_subtask_id()\n        child_id = self.father.children.index(self) + 1\n        fahter_subtask_id.append(child_id)\n        return fahter_subtask_id\n",
            "name_column": 8
        },
        "make_relation": {
            "type": "FunctionDef",
            "name": "make_relation",
            "md_content": "**make_relation**\n\nfatherchildchildfatherchildrenfatherchildfather\n\n\nXAgent/workflow/plan_exec.py\n\n```python\ndef initial_plan_generation(self, agent_dispatcher):\n    \"\"\"\n\n    \n    \"\"\"\n    logger.typewriter_log(\n        f\"-=-=-=-=-=-=-=  -=-=-=-=-=-=-=\",\n        Fore.GREEN,\n        \"\",\n    )\n\n    split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n    agent = agent_dispatcher.dispatch(\n        RequiredAbilities.plan_generation,\n        target_task=f\"{self.query.task}\",\n        # avaliable_tools_description_list=self.avaliable_tools_description_list\n    )\n\n    # TODO: not robust. dispatcher generated prompt may not contain these specified placeholders?\n    new_message , _ = agent.parse(\n        placeholders={\n            \"system\": {\n                # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n            },\n            \"user\": {\n                \"query\": self.plan.data.raw\n            }\n        },\n        arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n        functions=[split_functions], \n    )\n    \n    subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n    for subtask_item in subtasks[\"subtasks\"]:\n        subplan = plan_function_output_parser(subtask_item)\n        Plan.make_relation(self.plan, subplan)\n```\n\n```python\ndef deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n    \"\"\"\n\n    \n\n    \n        function_input (dict)\n        now_dealing_task (Plan)\n\n    \n        str\n        PlanOperationStatusCode\n    \"\"\"\n    print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n    inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n    target_subtask_id = function_input[\"target_subtask_id\"].strip()\n    all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n    can_edit = False\n    for k, subtask in enumerate(inorder_subtask_stack):\n        if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n            \n            can_edit = True\n\n        if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n            if not can_edit:\n                return json.dumps({\"error\": f\"TODO'>= {now_dealing_task.get_subtask_id(to_str=True)}'\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n            \n            # if not subtask.data.status == TaskStatusCode.FAIL:\n            #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status.name}' Task. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n            if subtask.get_depth() >= self.config.max_plan_tree_depth:\n                return json.dumps({\"error\": f\"{self.config.max_plan_tree_depth}'{subtask.data.name}'{subtask.get_depth()}\"}), PlanOperationStatusCode.OTHER_ERROR\n\n            for new_subtask in function_input[\"subtasks\"]:\n                new_subplan = plan_function_output_parser(new_subtask)\n                Plan.make_relation(subtask,new_subplan)\n            subtask.data.status = TaskStatusCode.SPLIT\n            return json.dumps({\"success\": f\"'{target_subtask_id}'\"}), PlanOperationStatusCode.MODIFY_SUCCESS\n\n    return json.dumps({\"error\": f\"ID '{target_subtask_id}'\"}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n```\n",
            "code_start_line": 76,
            "code_end_line": 84,
            "parent": "Plan",
            "have_return": false,
            "code_content": "    def make_relation(cls, father, child):\n        \"\"\"Establishes a parent-child relationship between two plans.\n\n        Args:\n            father: Parent plan.\n            child: Child plan.\n        \"\"\"\n        father.children.append(child)\n        child.father = father\n",
            "name_column": 8
        },
        "get_root": {
            "type": "FunctionDef",
            "name": "get_root",
            "md_content": "**get_root**\n\n\n\nget_root\n\n****\n- \n- \n\n****",
            "code_start_line": 86,
            "code_end_line": 94,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_root(self):\n        \"\"\"Fetches the root of the Plan tree.\n\n        Returns:\n            Root Plan object.\n        \"\"\"\n        if self.father == None:\n            return self\n        return self.father.get_root()\n",
            "name_column": 8
        },
        "get_depth": {
            "type": "FunctionDef",
            "name": "get_depth",
            "md_content": "**get_depth**\n\nget_depth11\n\n****get_depth\n\n****33",
            "code_start_line": 96,
            "code_end_line": 104,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_depth(self):\n        \"\"\"Returns the depth of the Plan tree.\n\n        Returns:\n            Tree depth as an integer.\n        \"\"\"\n        if self.father == None:\n            return 1\n        return 1 + self.father.get_depth()\n",
            "name_column": 8
        },
        "get_inorder_travel": {
            "type": "FunctionDef",
            "name": "get_inorder_travel",
            "md_content": "**get_inorder_travel**\n\nnow_plan\n\n\n\nnow_planresult_list\n\nget_inorder_travelresult_list\n\nresult_list\n\n****\n- now_plan\n- \n\n****ABCABBCget_inorder_travelA[A, B, C]",
            "code_start_line": 107,
            "code_end_line": 119,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_inorder_travel(cls, now_plan):\n        \"\"\"Performs an inorder traversal of the plan tree.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            All plans in the tree in inorder.\n        \"\"\"\n        result_list = [now_plan]\n        for child in now_plan.children:\n            result_list.extend(Plan.get_inorder_travel(child))\n        return result_list\n",
            "name_column": 8
        },
        "pop_next_subtask": {
            "type": "FunctionDef",
            "name": "pop_next_subtask",
            "md_content": "**pop_next_subtask**\n\nnow_plan\n\nroot_planPlanget_inorder_travelall_plansindexorder_idorder_id+1all_plansTODOsubtask\n\nNone\n\n****\n- now_plan\n- None\n\n****\n\n```python\nsubtask = Plan.pop_next_subtask(now_plan)\nprint(subtask)\n```\n\n```\n<Plan object at 0x7f8a7b7e4af0>\n```",
            "code_start_line": 122,
            "code_end_line": 137,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def pop_next_subtask(cls, now_plan):\n        \"\"\"Fetches the next subtask in the queue.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Next subtask in the queue.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        for subtask in all_plans[order_id + 1:]:\n            if subtask.data.status == TaskStatusCode.TODO:\n                return subtask\n        return None\n",
            "name_column": 8
        },
        "get_remaining_subtask": {
            "type": "FunctionDef",
            "name": "get_remaining_subtask",
            "md_content": "**get_remaining_subtask**\n\nnow_plan\n\nroot_planPlanget_inorder_travelall_plansindexorder_idorder_id\n\n****Plan\n\n****all_plans[plan1, plan2, plan3, plan4]order_id2[plan3, plan4]",
            "code_start_line": 140,
            "code_end_line": 152,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_remaining_subtask(cls, now_plan):\n        \"\"\"Gets all remaining subtasks from a given point.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Array of all remaining subtasks.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        return all_plans[order_id:]",
            "name_column": 8
        }
    },
    "XAgent/data_structure/__init__.py": {},
    "XAgent/data_structure/node.py": {
        "Node": {
            "type": "ClassDef",
            "name": "Node",
            "md_content": "**Node**NodeXAgent\n\nabc\n\n**Node**\n- \n\n**Node**\n- \\_\\_init\\_\\_(self)Node\n\n**ToolNode**ToolNodeXAgent\n\nfatherchildrendataID\n\n**ToolNode**\n- father: ToolNode\n- children: ToolNode\n- expand_num: \n- data: \n- history: MessageHistory\n- workspace_hash_id: ID\n\n**ToolNode**\n- \\_\\_init\\_\\_(self)fatherchildrenexpand_numdatahistoryworkspace_hash_id\n- process(self)\n- to_json(self)dataJSONJSONdata\n- get_depth(self)0\n- get_subtree_size(self)\n\n**SummarizationNode**SummarizationNode\n\nXAgent.data_structure.nodeNode\n\n**SummarizationNode**\n- father: SummarizationNode\n- children: SummarizationNode\n- message: Message\n- summarization_from_root_to_here: \n\n**SummarizationNode**\n- \\_\\_init\\_\\_(self)SummarizationNodefatherchildrenmessagesummarization_from_root_to_here\n- add_father_child_relation(cls, father, child)\n\n****\n- Node\n- ToolNode\n- SummarizationNode",
            "code_start_line": 10,
            "code_end_line": 23,
            "parent": null,
            "have_return": false,
            "code_content": "class Node(metaclass = abc.ABCMeta):\n    \"\"\"\n    Abstract class representing a generic node in the XAgent's data structure.\n\n    This class uses the abc module to denote it as an abstract base class.\n    Other classes should inherit from this class to implement specific types of nodes.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize a new node.\n\n        As an abstract class, Node does not have any implementation details.\n        \"\"\"\n        pass\n",
            "name_column": 6
        },
        "ToolNode": {
            "type": "ClassDef",
            "name": "ToolNode",
            "md_content": "**ToolNode**ToolNodeXAgent\n\nToolNodeXAgentfatherchildrendataID\n\nToolNode\n\n- `__init__(self)`: fatherchildrenexpand_numdatahistoryworkspace_hash_id\n- `process(self)`: \n- `to_json(self)`: dataJSONdataJSON\n- `get_depth(self)`: 0\n- `get_subtree_size(self)`: \n\n****ToolNodeXAgentID\n\n****\n```python\n# ToolNode\nnode = ToolNode()\n\n# \nnode.data = {\n    \"content\": \"This is the content\",\n    \"thoughts\": {\n        \"properties\": {\n            \"thought\": \"This is a thought\",\n            \"reasoning\": \"This is a reasoning\",\n            \"plan\": \"This is a plan\",\n            \"criticism\": \"This is a criticism\"\n        }\n    },\n    \"command\": {\n        \"properties\": {\n            \"name\": \"command_name\",\n            \"args\": \"command_args\"\n        }\n    },\n    \"tool_output\": \"This is the tool output\",\n    \"tool_status_code\": \"TOOL_CALL_SUCCESS\"\n}\n\n# \ndepth = node.get_depth()\nprint(depth)  # : 0\n\n# \nsubtree_size = node.get_subtree_size()\nprint(subtree_size)  # : 1\n\n# JSON\njson_data = node.to_json()\nprint(json_data)\n# : \n# {\n#     \"content\": \"This is the content\",\n#     \"thoughts\": {\n#         \"properties\": {\n#             \"thought\": \"This is a thought\",\n#             \"reasoning\": \"This is a reasoning\",\n#             \"plan\": \"This is a plan\",\n#             \"criticism\": \"This is a criticism\"\n#         }\n#     },\n#     \"command\": {\n#         \"properties\": {\n#             \"name\": \"command_name\",\n#             \"args\": \"command_args\"\n#         }\n#     },\n#     \"tool_output\": \"This is the tool output\",\n#     \"tool_status_code\": \"TOOL_CALL_SUCCESS\"\n# }\n```",
            "code_start_line": 26,
            "code_end_line": 121,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolNode(Node):\n    \"\"\"\n    Class representing a tool node in the XAgent's data structure.\n    \n    A tool node has a father that represents its parent node, \"children\" that represents its child nodes, \n    and data containing metadata about node's status, command, tool's output, and thoughts properties.\n    It also carries a message history and a workspace hash id.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new tool node.\n\n        Setup father, children, expand_num, data, history, workspace_hash_id attributes for the instance.\n        \"\"\"\n\n        self.father: ToolNode = None\n        self.children: list[ToolNode] = []\n        self.expand_num = 0\n        self.data = {\n            \"content\": \"\",\n            \"thoughts\": {\n                \"properties\": {\n                    \"thought\": \"\",\n                    \"reasoning\": \"\",\n                    \"plan\": \"\",\n                    \"criticism\": \"\",\n                },\n            },\n            \"command\": {\n                \"properties\": {\n                    \"name\": \"\",\n                    \"args\": \"\",\n                },\n            },\n            \"tool_output\": \"\",\n            \"tool_status_code\": ToolCallStatusCode.TOOL_CALL_SUCCESS,\n        }\n        self.history: MessageHistory = MessageHistory()\n        self.workspace_hash_id = \"\"\n\n    @property\n    def process(self):\n        \"\"\"\n        Generate a list of data from current node up to root node.\n\n        Returns:\n            data (List): A list of data from current node up to root node.\n        \"\"\"\n\n        data = []\n        now_node = self\n        while now_node.father != None:\n            data = [now_node.data] + data\n            now_node = now_node.father\n        return data\n\n    def to_json(self):\n        \"\"\"\n        Convert the data attribute of the instance to a JSON-compatible format.\n\n        Returns:\n            data (Dict): The data attribute of the instance in a JSON-compatible format.\n        \"\"\"\n\n        data = deepcopy(self.data)\n        data[\"tool_status_code\"] = data[\"tool_status_code\"].name\n        return data\n\n    def get_depth(self):\n        \"\"\"\n        Calculate the depth of current node in the tree.\n\n        Returns:\n            depth (int): The depth of the node. Return 0 if the node is a root node.\n        \"\"\"\n        \n        if self.father == None:\n            return 0\n        return self.father.get_depth() + 1\n    \n    def get_subtree_size(self):\n        \"\"\"\n        Calculate the size of the subtree rooted at current node.\n\n        Returns:\n            size (int): The size of the subtree rooted at current node.\n        \"\"\"\n        \n        if self.children == []:\n            return 1\n        now_size = 1\n        for child in self.children:\n            now_size += child.get_subtree_size()\n        return now_size",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**\n\nfatherchildrenexpand_numdatahistoryworkspace_hash_id\n\n- fatherToolNode\n- childrenToolNode\n- expand_num\n- data\n  - content\n  - thoughts\n    - thought\n    - reasoning\n    - plan\n    - criticism\n  - command\n    - name\n    - args\n  - tool_output\n  - tool_status_codeToolCallStatusCode\n- historyMessageHistory\n- workspace_hash_idID\n\n****\n- ToolNode\n- expand_num\n- datacontentthoughtscommandtool_outputtool_status_code\n- historyMessageHistory\n- workspace_hash_id",
            "code_start_line": 36,
            "code_end_line": 66,
            "parent": "ToolNode",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"\n        Initialize a new tool node.\n\n        Setup father, children, expand_num, data, history, workspace_hash_id attributes for the instance.\n        \"\"\"\n\n        self.father: ToolNode = None\n        self.children: list[ToolNode] = []\n        self.expand_num = 0\n        self.data = {\n            \"content\": \"\",\n            \"thoughts\": {\n                \"properties\": {\n                    \"thought\": \"\",\n                    \"reasoning\": \"\",\n                    \"plan\": \"\",\n                    \"criticism\": \"\",\n                },\n            },\n            \"command\": {\n                \"properties\": {\n                    \"name\": \"\",\n                    \"args\": \"\",\n                },\n            },\n            \"tool_output\": \"\",\n            \"tool_status_code\": ToolCallStatusCode.TOOL_CALL_SUCCESS,\n        }\n        self.history: MessageHistory = MessageHistory()\n        self.workspace_hash_id = \"\"\n",
            "name_column": 8
        },
        "process": {
            "type": "FunctionDef",
            "name": "process",
            "md_content": "**process**\n\n\n\n****ToolNode\n\n****[1, 2, 3][4, 5, 6][7, 8, 9]process[7, 8, 9, 4, 5, 6, 1, 2, 3]",
            "code_start_line": 69,
            "code_end_line": 82,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def process(self):\n        \"\"\"\n        Generate a list of data from current node up to root node.\n\n        Returns:\n            data (List): A list of data from current node up to root node.\n        \"\"\"\n\n        data = []\n        now_node = self\n        while now_node.father != None:\n            data = [now_node.data] + data\n            now_node = now_node.father\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**dataJSON\n\n(deepcopy)datatool_status_codedata\n\n****\n- \n- datatool_status_code\n\n****data{\"tool_status_code\": ToolStatusCode.SUCCESS, \"data\": {\"name\": \"XAgent\"}}to_jsondata{\"tool_status_code\": \"SUCCESS\", \"data\": {\"name\": \"XAgent\"}}",
            "code_start_line": 84,
            "code_end_line": 94,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"\n        Convert the data attribute of the instance to a JSON-compatible format.\n\n        Returns:\n            data (Dict): The data attribute of the instance in a JSON-compatible format.\n        \"\"\"\n\n        data = deepcopy(self.data)\n        data[\"tool_status_code\"] = data[\"tool_status_code\"].name\n        return data\n",
            "name_column": 8
        },
        "get_depth": {
            "type": "FunctionDef",
            "name": "get_depth",
            "md_content": "**get_depth**\n\n0get_depth1\n\n****\n- \n- \n\n****get_depth0",
            "code_start_line": 96,
            "code_end_line": 106,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def get_depth(self):\n        \"\"\"\n        Calculate the depth of current node in the tree.\n\n        Returns:\n            depth (int): The depth of the node. Return 0 if the node is a root node.\n        \"\"\"\n        \n        if self.father == None:\n            return 0\n        return self.father.get_depth() + 1\n",
            "name_column": 8
        },
        "get_subtree_size": {
            "type": "FunctionDef",
            "name": "get_subtree_size",
            "md_content": "**get_subtree_size**\n\n1get_subtree_size\n\n\nXAgent/data_structure/node.py\n\n```python\ndef get_subtree_size(self):\n    \"\"\"\n    Calculate the size of the subtree rooted at current node.\n\n    Returns:\n        size (int): The size of the subtree rooted at current node.\n    \"\"\"\n    \n    if self.children == []:\n        return 1\n    now_size = 1\n    for child in self.children:\n        now_size += child.get_subtree_size()\n    return now_size\n```\n[]\n[XAgent/data_structure/node.py]\nXAgent/data_structure/tree.py\n\n```python\ndef get_subtree_size(self):\n    \"\"\"\n    Gets the number of nodes (or size) of the subtree from the current root node.\n\n    Returns:\n        int: The number of nodes in the subtree\n    \"\"\"\n    return self.root.get_subtree_size()\n```\n[]\n[XAgent/data_structure/tree.py]\n\n****\n- \n- \n\n****\n```python\nsize = node.get_subtree_size()\nprint(size)  # 5\n```\n\nget_subtree_size55",
            "code_start_line": 108,
            "code_end_line": 121,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def get_subtree_size(self):\n        \"\"\"\n        Calculate the size of the subtree rooted at current node.\n\n        Returns:\n            size (int): The size of the subtree rooted at current node.\n        \"\"\"\n        \n        if self.children == []:\n            return 1\n        now_size = 1\n        for child in self.children:\n            now_size += child.get_subtree_size()\n        return now_size",
            "name_column": 8
        }
    },
    "XAgent/ai_functions/function_manager.py": {
        "FunctionManager": {
            "type": "ClassDef",
            "name": "FunctionManager",
            "md_content": "**FunctionManager**: 'functions''pure_functions'YAML\n\n**function_cfg_dir (str)**: \n\n**pure_function_cfg_dir (str)**: \n\n**function_cfgs (dict)**: \n\n**__init__**: FunctionManager\n\n:\n- function_cfg_dir (str): \n- pure_function_cfg_dir (str): \n\n**get_function_schema**: \n\n:\n- function_name (str): \n\n:\n- dict: \n- None: None\n\n**register_function**: \n\n:\n- function_schema (dict): \n\n**execute**: \n\n:\n- function_name (str): \n- return_generation_usage (bool, optional): True\n- function_cfg (dict, optional): \n- **kwargs: \n\n:\n- Tuple[dict,Optional[dict]]: \n\n:\n- KeyError: \n\n**__getitem__**: FunctionManagerexecute\n\n:\n- function_name (str): \n- return_generation_usage (bool, optional): True\n- **kwargs: \n\n:\n- execute\n\n**__call__**: FunctionManagerexecute\n\n:\n- function_name (str): \n- return_generation_usage (bool, optional): True\n- **kwargs: \n\n:\n- execute\n\n****: :\n- FunctionManager\n- get_function_schema\n- register_function\n- execute\n- __getitem____call__\n\n****:\n```\n{\n  \"name\": \"add\",\n  \"parameters\": [\n    {\n      \"name\": \"a\",\n      \"type\": \"int\"\n    },\n    {\n      \"name\": \"b\",\n      \"type\": \"int\"\n    }\n  ],\n  \"return_type\": \"int\"\n}\n```",
            "code_start_line": 13,
            "code_end_line": 158,
            "parent": null,
            "have_return": true,
            "code_content": "class FunctionManager:\n    \"\"\"\n    This class provides methods to manage functions including registration and execution of functions.\n    The functions are defined and loaded from YAML configuration files located in the local directory\n    under subdirectories 'functions' and 'pure_functions'.\n\n    Attributes:\n      function_cfg_dir (str): The directory path where the function configuration files are located.\n      pure_function_cfg_dir (str): The directory path where the pure function configuration files are located.\n      function_cfgs (dict): A dictionary to store all loaded function configurations.\n    \"\"\"\n\n    def __init__(self,\n                 function_cfg_dir=os.path.join(os.path.dirname(__file__),'functions'),\n                 pure_function_cfg_dir=os.path.join(os.path.dirname(__file__),'pure_functions'),):\n        \"\"\"\n        Initializes the FunctionManager class with given directories for function configuration files.\n\n        Args:\n            function_cfg_dir (str): The directory path where the function configuration files are located.\n            pure_function_cfg_dir (str): The directory path where the pure function configuration files are located.\n        \"\"\"\n        self.function_cfg_dir = function_cfg_dir\n        self.pure_function_cfg_dir = pure_function_cfg_dir\n        self.function_cfgs = {}\n\n        for cfg_file in glob.glob(os.path.join(self.function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            self.function_cfgs[function_cfg['function']['name']] = function_cfg\n\n        for cfg_file in glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            for function in function_cfg['functions']:\n                self.function_cfgs[function['name']] = function\n    \n    def get_function_schema(self,function_name:str)->dict|None:\n        \"\"\"\n        Gets the schema of the function by its name.\n\n        Args:\n            function_name (str): The name of the function.\n\n        Returns:\n            dict: The schema of the function if found.\n            None: If the function is not found.\n        \"\"\"\n        return self.function_cfgs.get(function_name,None)\n    \n    def register_function(self,function_schema:dict):\n        \"\"\"\n        Registers a new function with its schema.\n\n        Args:\n            function_schema (dict): The schema of the function to register.\n        \"\"\"\n        if function_schema['name'] in self.function_cfgs:\n            return\n        self.function_cfgs[function_schema['name']] = function_schema\n        \n    def execute(self,function_name:str,return_generation_usage:bool=False,function_cfg:dict=None,**kwargs,)->Tuple[dict,Optional[dict]]:\n        \"\"\"\n        Executes a function by its name.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            function_cfg (dict, optional): The configuration of the function. If not provided, retrieves it from the loaded functions.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            Tuple[dict,Optional[dict]]: A tuple containing the returns and optionally the usage of the executed function.\n\n        Raises:\n            KeyError: If the function configuration is not found.\n        \"\"\"\n        if function_cfg is None and function_name in self.function_cfgs:\n            function_cfg = self.function_cfgs.get(function_name)\n        else:\n            raise KeyError(f'Configure for function {function_name} not found.')\n        \n        \n        logger.typewriter_log(f'Executing AI Function: {function_name}', Fore.YELLOW)\n\n        completions_kwargs:dict = function_cfg.get('completions_kwargs',{})\n        if 'model' in completions_kwargs:\n            # check whether model is configured\n            try:\n                get_apiconfig_by_model(completions_kwargs['model'])\n            except:\n                logger.typewriter_log(\"Fallback\",Fore.YELLOW,f\"Model {completions_kwargs['model']} is not configured. Using default model instead.\")\n                completions_kwargs = {}\n        function_prompt = str(function_cfg['function_prompt'])\n        function_prompt = function_prompt.format(**kwargs)\n        messages = [{'role':'user','content':function_prompt}]\n        \n        match CONFIG.default_request_type:\n            case 'openai':                \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=[function_cfg['function']],\n                    function_call={'name':function_cfg['function']['name']},\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['function_call']['arguments'])\n            case 'xagent':\n                arguments = function_cfg['function']['parameters']\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['content'])['arguments']\n        \n        if return_generation_usage:\n            return returns, response['usage']\n        return returns\n    \n    def __getitem__(self,function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to behave like a dictionary, calling the execute method by key (which is actually the function name).\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n\n    def __call__(self, function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to be callable, calling the execute method directly.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n          The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**: FunctionManager\n\n:\n- function_cfg_dirfunctions\n- pure_function_cfg_dirpure_functions\n- function_cfgs\n\n\n1. function_cfg_dir.yaml.yml\n2. yaml.loadfunction_cfg\n3. function_cfgfunction_cfgfunction_cfgs\n4. pure_function_cfg_dir.yaml.yml\n5. yaml.loadfunction_cfg\n6. function_cfgfunction_cfgs\n\n****: \n- function_cfg_dirpure_function_cfg_dir\n- .yaml.yml\n- \n\n",
            "code_start_line": 25,
            "code_end_line": 48,
            "parent": "FunctionManager",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 function_cfg_dir=os.path.join(os.path.dirname(__file__),'functions'),\n                 pure_function_cfg_dir=os.path.join(os.path.dirname(__file__),'pure_functions'),):\n        \"\"\"\n        Initializes the FunctionManager class with given directories for function configuration files.\n\n        Args:\n            function_cfg_dir (str): The directory path where the function configuration files are located.\n            pure_function_cfg_dir (str): The directory path where the pure function configuration files are located.\n        \"\"\"\n        self.function_cfg_dir = function_cfg_dir\n        self.pure_function_cfg_dir = pure_function_cfg_dir\n        self.function_cfgs = {}\n\n        for cfg_file in glob.glob(os.path.join(self.function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            self.function_cfgs[function_cfg['function']['name']] = function_cfg\n\n        for cfg_file in glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            for function in function_cfg['functions']:\n                self.function_cfgs[function['name']] = function\n",
            "name_column": 8
        },
        "get_function_schema": {
            "type": "FunctionDef",
            "name": "get_function_schema",
            "md_content": "**get_function_schema**\n\nfunction_name\n\nNone\n\n\n\n****\nfunction_namefunction_cfgsgetfunction_nameNone\n\n****\n\n****\n\n{\n    \"name\": \"function_name\",\n    \"parameters\": {\n        \"param1\": {\n            \"type\": \"string\",\n            \"description\": \"Parameter 1\"\n        },\n        \"param2\": {\n            \"type\": \"int\",\n            \"description\": \"Parameter 2\"\n        }\n    }\n}\n\nNone",
            "code_start_line": 50,
            "code_end_line": 61,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def get_function_schema(self,function_name:str)->dict|None:\n        \"\"\"\n        Gets the schema of the function by its name.\n\n        Args:\n            function_name (str): The name of the function.\n\n        Returns:\n            dict: The schema of the function if found.\n            None: If the function is not found.\n        \"\"\"\n        return self.function_cfgs.get(function_name,None)\n",
            "name_column": 8
        },
        "register_function": {
            "type": "FunctionDef",
            "name": "register_function",
            "md_content": "**register_function**\n\nfunction_schema\n\nfunction_schema'name'self.function_cfgs\n\nfunction_schema'name'self.function_cfgsself.function_cfgs\n\n****\n- function_schema'name'\n- self.function_cfgs\n\n****\n\n```python\n{\n    \"name\": \"function_name\",\n    \"description\": \"function_description\",\n    ...\n}\n```",
            "code_start_line": 63,
            "code_end_line": 72,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def register_function(self,function_schema:dict):\n        \"\"\"\n        Registers a new function with its schema.\n\n        Args:\n            function_schema (dict): The schema of the function to register.\n        \"\"\"\n        if function_schema['name'] in self.function_cfgs:\n            return\n        self.function_cfgs[function_schema['name']] = function_schema\n",
            "name_column": 8
        },
        "execute": {
            "type": "FunctionDef",
            "name": "execute",
            "md_content": "**execute**\n\n\n- function_name (str)\n- return_generation_usage (bool, )True\n- function_cfg (dict, )\n- **kwargs\n\n\n\nKeyError\n\nKeyError\n\nAI\n\ncompletions_kwargs'openai'objgenerator.chatcompletion'xagent'argumentsobjgenerator.chatcompletion\n\nreturn_generation_usage\n\n****\n- \n- \n- KeyError\n\n****\n```python\n{\n    'result': {\n        'output': 'Hello, World!',\n        'status': 'success'\n    },\n    'usage': {\n        'duration': 2.5,\n        'memory': 256\n    }\n}\n```",
            "code_start_line": 74,
            "code_end_line": 130,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def execute(self,function_name:str,return_generation_usage:bool=False,function_cfg:dict=None,**kwargs,)->Tuple[dict,Optional[dict]]:\n        \"\"\"\n        Executes a function by its name.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            function_cfg (dict, optional): The configuration of the function. If not provided, retrieves it from the loaded functions.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            Tuple[dict,Optional[dict]]: A tuple containing the returns and optionally the usage of the executed function.\n\n        Raises:\n            KeyError: If the function configuration is not found.\n        \"\"\"\n        if function_cfg is None and function_name in self.function_cfgs:\n            function_cfg = self.function_cfgs.get(function_name)\n        else:\n            raise KeyError(f'Configure for function {function_name} not found.')\n        \n        \n        logger.typewriter_log(f'Executing AI Function: {function_name}', Fore.YELLOW)\n\n        completions_kwargs:dict = function_cfg.get('completions_kwargs',{})\n        if 'model' in completions_kwargs:\n            # check whether model is configured\n            try:\n                get_apiconfig_by_model(completions_kwargs['model'])\n            except:\n                logger.typewriter_log(\"Fallback\",Fore.YELLOW,f\"Model {completions_kwargs['model']} is not configured. Using default model instead.\")\n                completions_kwargs = {}\n        function_prompt = str(function_cfg['function_prompt'])\n        function_prompt = function_prompt.format(**kwargs)\n        messages = [{'role':'user','content':function_prompt}]\n        \n        match CONFIG.default_request_type:\n            case 'openai':                \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=[function_cfg['function']],\n                    function_call={'name':function_cfg['function']['name']},\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['function_call']['arguments'])\n            case 'xagent':\n                arguments = function_cfg['function']['parameters']\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['content'])['arguments']\n        \n        if return_generation_usage:\n            return returns, response['usage']\n        return returns\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "**__getitem__**FunctionManagerexecute\n\n\n- function_namestr\n- return_generation_usageboolTrue\n- **kwargs\n\nexecute\n\n****\n__getitem__FunctionManagerexecute\n\nfunction_namereturn_generation_usage**kwargsfunction_namereturn_generation_usage**kwargs\n\nexecutefunction_namereturn_generation_usage**kwargsexecuteexecute\n\n****\n- \n- \n\n****\n```python\n# 1\nresult = function_manager_instance['function_name']\nprint(result)\n# \n# \n\n# 2\nresult, usage = function_manager_instance['function_name', True, param1='value1', param2='value2']\nprint(result)\nprint(usage)\n# \n# \n# \n```",
            "code_start_line": 132,
            "code_end_line": 144,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def __getitem__(self,function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to behave like a dictionary, calling the execute method by key (which is actually the function name).\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n",
            "name_column": 8
        },
        "__call__": {
            "type": "FunctionDef",
            "name": "__call__",
            "md_content": "**__call__**FunctionManagerexecute\n\n\n- function_namestr\n- return_generation_usageboolTrue\n- **kwargs\n\nexecute\n\n****\n__call__FunctionManagerFunctionManagerexecute__call__\n\n__call__executeexecuteexecuteFunctionManagerexecute\n\nreturn_generation_usageTrue__call__\n\n****\n- function_name\n- return_generation_usageTrue\n\n****__call__function_name='my_function'return_generation_usage=True\n```\n{\n  'result': '',\n  'usage': ''\n}\n```",
            "code_start_line": 146,
            "code_end_line": 158,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def __call__(self, function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to be callable, calling the execute method directly.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n          The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n",
            "name_column": 8
        }
    },
    "XAgent/ai_functions/__init__.py": {},
    "XAgent/ai_functions/request/error.py": {
        "FunctionCallSchemaError": {
            "type": "ClassDef",
            "name": "FunctionCallSchemaError",
            "md_content": "**FunctionCallSchemaError**: \n\n\n\n****: \n- FunctionCallSchemaError\n- \n- \n- ",
            "code_start_line": 1,
            "code_end_line": 9,
            "parent": null,
            "have_return": false,
            "code_content": "class FunctionCallSchemaError(Exception):\n    \"\"\"Exception raised when there is an error in the structure or format of a function call.\n\n    This exception does not accept any arguments or custom messages. It is thrown when there is an issue\n    with the schema or structure of a function call, such as passing the wrong data type, too many or too few\n    arguments, etc. This error is used to halt execution and signal that the function call needs to be \n    corrected before the program can continue.\n    \"\"\"\n    pass",
            "name_column": 6
        }
    },
    "XAgent/ai_functions/request/__init__.py": {},
    "XAgent/ai_functions/request/obj_generator.py": {
        "OBJGenerator": {
            "type": "ClassDef",
            "name": "OBJGenerator",
            "md_content": "**OBJGenerator**: AI\n\n\n- chatcompletion_request_funcs: \n\n\n\n1. \\_\\_init\\_\\_(self)\n   - OBJGenerator\n   - \n   - \n   - obj = OBJGenerator()\n\n2. chatcompletion(self, \\*, schema_validation=True, **kwargs)\n   - \n   - \n     - schema_validation (bool, )True\n     - kwargs (dict)\n   - AI\n   - \n     - Exception\n     - NotImplementedError\n   - response = obj.chatcompletion(schema_validation=True, request_type='openai')\n\n3. \\_get_chatcompletion_request_func(self, request_type:str)\n   - \n   - \n     - request_type (str)\n   - \n   - func = obj._get_chatcompletion_request_func('openai')\n\n4. dynamic_json_fixes(self, broken_json, function_schema, messages: list = [], error_message: str = None)\n   - JSON\n   - \n     - broken_jsonJSON\n     - function_schemaJSON\n     - messages (list, )JSON\n     - error_message (str, )JSON\n   - AI\n   - response = obj.dynamic_json_fixes(broken_json, function_schema, messages=[], error_message=None)\n\n5. load_args_with_schema_validation(self, function_schema:dict, args:str, messages:list=[], \\*, return_response=False, response=None)\n   - \n   - \n     - function_schema (dict)\n     - args (str)\n     - messages (list, )\n     - return_response (bool, )\n     - responsereturn_responseTrue\n   - return_responseTrue\n   - Exception\n   - arguments = obj.load_args_with_schema_validation(function_schema, args, messages=[], return_response=False, response=None)\n\n6. function_call_refine(self, req_kwargs, response)\n   - \n   - \n     - req_kwargs\n     - response\n   - ",
            "code_start_line": 20,
            "code_end_line": 222,
            "parent": null,
            "have_return": true,
            "code_content": "class OBJGenerator:\n    \"\"\"Handles interactions with AI responses and execution of configured requests.\n\n    Attributes:\n        chatcompletion_request_funcs: A dictionary to store functions processing chat completion requests.\n    \"\"\"\n    \n    def __init__(self,):        \n        self.chatcompletion_request_funcs = {}\n        \n    @retry(\n        stop=stop_after_attempt(3),\n        retry=retry_if_exception_type((\n            jsonschema.exceptions.ValidationError,\n            FunctionCallSchemaError\n            )),\n        )\n    def chatcompletion(self,*,schema_validation=True,**kwargs):\n        \"\"\"Processes chat completion requests and retrieves responses.\n\n        Args:\n            kwargs: Request data parameters.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n\n        Raises:\n            Exception: Error occurred while processing requests.\n            NotImplementedError: Received request type is not currently implemented.\n        \"\"\"\n        \n        request_type = kwargs.pop('request_type',CONFIG.default_request_type)\n        for k in list(kwargs.keys()):\n            if kwargs[k] is None:\n                kwargs.pop(k)\n        \n        llm_query_id = recorder.get_query_id()\n        try:   \n            copyed_kwargs = deepcopy(kwargs)\n            if (response := recorder.query_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs)) is None:\n                response = self._get_chatcompletion_request_func(request_type)(**kwargs)\n            recorder.regist_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs,output_data = response)\n        except Exception as e:\n            traceback.print_exc()\n            logger.typewriter_log(f\"chatcompletion error: {e}\",Fore.RED)\n            recorder.decrease_query_id()\n            raise e\n\n        if schema_validation:\n            # refine the response\n            match request_type:\n                case 'openai':                \n                    response = self.function_call_refine(kwargs,response)\n                case 'xagent':\n                    pass\n                case _:\n                    raise NotImplementedError(f\"Request type {request_type} not implemented\")\n        \n        return response\n        \n    def _get_chatcompletion_request_func(self, request_type:str):\n        \"\"\"Retrieves and returns the chat completion function for a particular request type\n\n        Args:\n            request_type (str): Type of the service the request has been generated for.\n\n        Returns:\n            Function object to handle chat completion for the specified request type.\n        \"\"\"\n        \n        if request_type not in self.chatcompletion_request_funcs:\n            module = importlib.import_module(f'.{request_type}','XAgent.ai_functions.request')\n            self.chatcompletion_request_funcs[request_type] = getattr(module,'chatcompletion_request')\n        return self.chatcompletion_request_funcs[request_type]\n\n    def dynamic_json_fixes(self, broken_json, function_schema, messages: list = [], error_message: str = None):\n        \"\"\"Attempts to fix invalid json and validate it against the function schema\n\n        Args:\n            broken_json: The invalid input json data.\n            function_schema: Schema to validate the json data against.\n            messages (list, optional): Additional messages related to the json validation error.\n            error_message (str, optional): Error message related to the json validation error.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n        \"\"\"\n        \n        logger.typewriter_log(\n            f'Schema Validation for Function call {function_schema[\"name\"]} failed, trying to fix it...', Fore.YELLOW)\n        repair_req_kwargs = deepcopy(CONFIG.default_completion_kwargs)\n        if messages[-1][\"role\"] == 'system' and 'Your last function call result in error' in messages[-1][\"content\"]:\n            messages = messages[:-1]\n        repair_req_kwargs['messages'] = [*messages,\n                                  {\n                                      'role': 'system',\n                                      'content': '\\n'.join([\n                                          'Your last function call result in error',\n                                          '--- Error ---',\n                                          error_message,\n                                          'Your task is to fix all errors exist in the Broken Json String to make the json validate for the schema in the given function, and use new string to call the function again.',\n                                          '--- Notice ---',\n                                          '- You need to carefully check the json string and fix the errors or adding missing value in it.',\n                                          '- Do not give your own opinion or imaging new info or delete exisiting info!',\n                                          '- Make sure the new function call does not contains information about this fix task!',\n                                          '--- Broken Json String ---',\n                                          broken_json,\n                                          'Start!'\n                                      ])\n                                  }]\n        repair_req_kwargs['functions'] = [function_schema]\n        repair_req_kwargs['function_call'] = {'name': function_schema['name']}\n        return self.chatcompletion(schema_validation=False,**repair_req_kwargs)\n    \n    def load_args_with_schema_validation(self,function_schema:dict,args:str,messages:list=[],*,return_response=False,response=None):\n        \"\"\"Validates arguments against the function schema.\n\n        Args:\n            function_schema (dict): Schema to validate the arguments against.\n            args (str): Arguments data to be validated.\n            messages (list, optional): Additional messages related to the arguments validation error.\n            return_response(bool, optional): Whether to return the response along with arguments.\n            response: response data to be returned if return_response is True.\n\n        Returns:\n            Arguments data after schema validation.\n            If return_response is set to True, response is also returned along with the arguments.\n\n        Raises:\n            Exception: Error occurred while validating the arguments.\n        \"\"\"\n        \n        # loading arguments\n        arguments = args\n        def validate():\n            nonlocal function_schema,arguments\n            if isinstance(arguments,str):\n                arguments = {} if arguments == '' else json5.loads(arguments)\n            jsonschema.validate(instance=arguments, schema=function_schema['parameters'])\n            \n        try:\n            validate()\n        except Exception as e:\n            if not isinstance(arguments,str):\n                arguments = json5.dumps(arguments)\n            # give one opportunity to fix the json string\n            response = self.dynamic_json_fixes(arguments,function_schema,messages,str(e))\n            arguments = response['choices'][0]['message']['function_call']['arguments']\n            validate()\n\n        if return_response:\n            return arguments,response\n        else:\n            return arguments\n        \n    def function_call_refine(self,req_kwargs,response):\n        \"\"\"Validates and refines the function call response.\n\n        Args:\n            req_kwargs: Request data parameters.\n            response: The response received from the service call.\n\n        Returns:\n            Refined and validated response.\n\n        Raises:\n            FunctionCallSchemaError: Error occurred during the schema validation of the function call.\n        \"\"\"\n        \n        if 'function_call' not in response['choices'][0]['message']:\n            logger.typewriter_log(\"FunctionCallSchemaError: No function call found in the response\", Fore.RED)\n            raise FunctionCallSchemaError(f\"No function call found in the response: {response['choices'][0]['message']} \")\n\n        # verify the schema of the function call if exists\n        function_schema = list(filter(lambda x: x['name'] == response['choices'][0]['message']['function_call']['name'],req_kwargs['functions']))\n        function_schema = None if len(function_schema) == 0 else function_schema[0]\n        \n        if function_schema is None:\n            if '\"{}\"'.format(response['choices'][0]['message']['function_call']['name']) in req_kwargs['messages'][0]['content']:\n                # Temporal fix for tool call without reasoning\n                logger.typewriter_log(\"Warning: Detect tool call without reasoning\",Fore.YELLOW)\n                response['choices'][0]['message']['function_call']['arguments'] = orjson.dumps({\n                    'tool_call':{\n                        'tool_name':response['choices'][0]['message']['function_call']['name'],\n                        'tool_input':response['choices'][0]['message']['function_call']['arguments']\n                    }\n                })\n                return response\n\n            error_message = {\n                'role':'system',\n                'content': f\"Error: Your last function calling call function {response['choices'][0]['message']['function_call']['name']} that is not in the provided functions. Make sure function name in list: {list(map(lambda x:x['name'],req_kwargs['functions']))}\"\n            }\n            \n            if req_kwargs['messages'][-1]['role'] == 'system' and 'Your last function calling call function' in req_kwargs['messages'][-1]['content']:\n                req_kwargs['messages'] = req_kwargs['messages'][:-1]\n            req_kwargs['messages'].append(error_message)\n                \n            logger.typewriter_log(f\"FunctionCallSchemaError: Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions.\",Fore.RED)\n            raise FunctionCallSchemaError(f\"Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions: {list(map(lambda x:x['name'],req_kwargs['functions']))}\")\n            \n        arguments,response = self.load_args_with_schema_validation(function_schema,response['choices'][0]['message']['function_call']['arguments'],req_kwargs['messages'],return_response=True,response=response)\n        return response\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**\n\n\n\n`chatcompletion_request_funcs`\n\n****\n- \n- \n- `chatcompletion_request_funcs`",
            "code_start_line": 27,
            "code_end_line": 28,
            "parent": "OBJGenerator",
            "have_return": false,
            "code_content": "    def __init__(self,):        \n        self.chatcompletion_request_funcs = {}\n",
            "name_column": 8
        },
        "chatcompletion": {
            "type": "FunctionDef",
            "name": "chatcompletion",
            "md_content": "**chatcompletion**chatcompletion\n\n\n- schema_validationTrue\n- kwargs\n\nAI\n\n\n- Exception\n- NotImplementedError\n\n\n- XAgent/agent/base_agent.pygeneratechatcompletion\n- XAgent/ai_functions/function_manager.pyexecutechatcompletion\n- XAgent/ai_functions/request/obj_generator.pydynamic_json_fixeschatcompletion\n\n**generate**generateAI\n\n\n- messagesAI\n- argumentsAI\n- functionsAI\n- function_callAI\n- stopAI\n- *args\n- **kwargs\n\nAI\n\n**Note**chatcompletiongeneratechatcompletion\n\n**Output Example**:\n```python\nmessage = {\n    'arguments': {\n        'property1': 'value1',\n        'property2': 'value2'\n    },\n    'function_call': {\n        'name': 'function_name',\n        'arguments': {\n            'arg1': 'value1',\n            'arg2': 'value2'\n        }\n    }\n}\ntokens = 100\n```\n\n\n**execute**execute\n\n\n- function_name\n- return_generation_usageTrue\n- function_cfg\n- **kwargs\n\n\n\n**Note**chatcompletionexecutechatcompletion\n\n**Output Example**:\n```python\nreturns = {\n    'property1': 'value1',\n    'property2': 'value2'\n}\nusage = 100\n```\n\n\n**dynamic_json_fixes**dynamic_json_fixesJSON\n\n\n- broken_jsonJSON\n- function_schemaJSON\n- messagesJSON\n- error_messageJSON\n\nAI\n\n**Note**dynamic_json_fixesJSONJSONchatcompletion\n\n**Output Example**:\n```python\nresponse = {\n    'property1': 'value1',\n    'property2': 'value2'\n}\n```",
            "code_start_line": 37,
            "code_end_line": 78,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def chatcompletion(self,*,schema_validation=True,**kwargs):\n        \"\"\"Processes chat completion requests and retrieves responses.\n\n        Args:\n            kwargs: Request data parameters.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n\n        Raises:\n            Exception: Error occurred while processing requests.\n            NotImplementedError: Received request type is not currently implemented.\n        \"\"\"\n        \n        request_type = kwargs.pop('request_type',CONFIG.default_request_type)\n        for k in list(kwargs.keys()):\n            if kwargs[k] is None:\n                kwargs.pop(k)\n        \n        llm_query_id = recorder.get_query_id()\n        try:   \n            copyed_kwargs = deepcopy(kwargs)\n            if (response := recorder.query_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs)) is None:\n                response = self._get_chatcompletion_request_func(request_type)(**kwargs)\n            recorder.regist_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs,output_data = response)\n        except Exception as e:\n            traceback.print_exc()\n            logger.typewriter_log(f\"chatcompletion error: {e}\",Fore.RED)\n            recorder.decrease_query_id()\n            raise e\n\n        if schema_validation:\n            # refine the response\n            match request_type:\n                case 'openai':                \n                    response = self.function_call_refine(kwargs,response)\n                case 'xagent':\n                    pass\n                case _:\n                    raise NotImplementedError(f\"Request type {request_type} not implemented\")\n        \n        return response\n",
            "name_column": 8
        },
        "_get_chatcompletion_request_func": {
            "type": "FunctionDef",
            "name": "_get_chatcompletion_request_func",
            "md_content": "**_get_chatcompletion_request_func**\n\nrequest_typerequest_typechatcompletion_request_funcsimportlibchatcompletion_requestchatcompletion_request_funcs\n\n****\n- request_typeNotImplementedError\n- chatcompletion_request_funcs\n\n****request_type'openai'openai",
            "code_start_line": 80,
            "code_end_line": 93,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def _get_chatcompletion_request_func(self, request_type:str):\n        \"\"\"Retrieves and returns the chat completion function for a particular request type\n\n        Args:\n            request_type (str): Type of the service the request has been generated for.\n\n        Returns:\n            Function object to handle chat completion for the specified request type.\n        \"\"\"\n        \n        if request_type not in self.chatcompletion_request_funcs:\n            module = importlib.import_module(f'.{request_type}','XAgent.ai_functions.request')\n            self.chatcompletion_request_funcs[request_type] = getattr(module,'chatcompletion_request')\n        return self.chatcompletion_request_funcs[request_type]\n",
            "name_column": 8
        },
        "dynamic_json_fixes": {
            "type": "FunctionDef",
            "name": "dynamic_json_fixes",
            "md_content": "**dynamic_json_fixes**JSON\n\n\n- `broken_json`JSON\n- `function_schema`JSON\n- `messages`JSON\n- `error_message`JSON\n\nAI\n\n\"Your last function call result in error\"`chatcompletion``schema_validation`FalseAI\n\n****\n- JSON\n- \n- \n\n****AI",
            "code_start_line": 95,
            "code_end_line": 132,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def dynamic_json_fixes(self, broken_json, function_schema, messages: list = [], error_message: str = None):\n        \"\"\"Attempts to fix invalid json and validate it against the function schema\n\n        Args:\n            broken_json: The invalid input json data.\n            function_schema: Schema to validate the json data against.\n            messages (list, optional): Additional messages related to the json validation error.\n            error_message (str, optional): Error message related to the json validation error.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n        \"\"\"\n        \n        logger.typewriter_log(\n            f'Schema Validation for Function call {function_schema[\"name\"]} failed, trying to fix it...', Fore.YELLOW)\n        repair_req_kwargs = deepcopy(CONFIG.default_completion_kwargs)\n        if messages[-1][\"role\"] == 'system' and 'Your last function call result in error' in messages[-1][\"content\"]:\n            messages = messages[:-1]\n        repair_req_kwargs['messages'] = [*messages,\n                                  {\n                                      'role': 'system',\n                                      'content': '\\n'.join([\n                                          'Your last function call result in error',\n                                          '--- Error ---',\n                                          error_message,\n                                          'Your task is to fix all errors exist in the Broken Json String to make the json validate for the schema in the given function, and use new string to call the function again.',\n                                          '--- Notice ---',\n                                          '- You need to carefully check the json string and fix the errors or adding missing value in it.',\n                                          '- Do not give your own opinion or imaging new info or delete exisiting info!',\n                                          '- Make sure the new function call does not contains information about this fix task!',\n                                          '--- Broken Json String ---',\n                                          broken_json,\n                                          'Start!'\n                                      ])\n                                  }]\n        repair_req_kwargs['functions'] = [function_schema]\n        repair_req_kwargs['function_call'] = {'name': function_schema['name']}\n        return self.chatcompletion(schema_validation=False,**repair_req_kwargs)\n",
            "name_column": 8
        },
        "load_args_with_schema_validation": {
            "type": "FunctionDef",
            "name": "load_args_with_schema_validation",
            "md_content": "**load_args_with_schema_validation**\n\n\n- function_schemadict\n- argsstr\n- messageslist\n- return_responsebool\n- responsereturn_responseTrue\n\n\n- \n- return_responseTrue\n\n\n- Exception\n\n**load_args_with_schema_validation**\nargumentsvalidate()validate()argumentsjson5.loads()jsonschema.validate()instanceargumentsschemafunction_schema['parameters']\n\ntry-exceptargumentsjson5.dumps()self.dynamic_json_fixes()jsonargumentsvalidate()\n\nreturn_responseTrueargumentsresponsearguments\n\n****\n- function_schema\n- args\n- messages\n- return_response\n- response\n\n****argumentsresponse\n```\narguments = {...}\nresponse = {...}\n```",
            "code_start_line": 134,
            "code_end_line": 173,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def load_args_with_schema_validation(self,function_schema:dict,args:str,messages:list=[],*,return_response=False,response=None):\n        \"\"\"Validates arguments against the function schema.\n\n        Args:\n            function_schema (dict): Schema to validate the arguments against.\n            args (str): Arguments data to be validated.\n            messages (list, optional): Additional messages related to the arguments validation error.\n            return_response(bool, optional): Whether to return the response along with arguments.\n            response: response data to be returned if return_response is True.\n\n        Returns:\n            Arguments data after schema validation.\n            If return_response is set to True, response is also returned along with the arguments.\n\n        Raises:\n            Exception: Error occurred while validating the arguments.\n        \"\"\"\n        \n        # loading arguments\n        arguments = args\n        def validate():\n            nonlocal function_schema,arguments\n            if isinstance(arguments,str):\n                arguments = {} if arguments == '' else json5.loads(arguments)\n            jsonschema.validate(instance=arguments, schema=function_schema['parameters'])\n            \n        try:\n            validate()\n        except Exception as e:\n            if not isinstance(arguments,str):\n                arguments = json5.dumps(arguments)\n            # give one opportunity to fix the json string\n            response = self.dynamic_json_fixes(arguments,function_schema,messages,str(e))\n            arguments = response['choices'][0]['message']['function_call']['arguments']\n            validate()\n\n        if return_response:\n            return arguments,response\n        else:\n            return arguments\n",
            "name_column": 8
        },
        "function_call_refine": {
            "type": "FunctionDef",
            "name": "function_call_refine",
            "md_content": "**function_call_refine**\n\n\n- req_kwargs\n- response\n\n\n\nFunctionCallSchemaError\n\nFunctionCallSchemaError\n\nreq_kwargs['functions']function_schemafunction_schemaNone\n\nfunction_schemaNonereq_kwargs['messages']\n\nfunction_schemaNoneload_args_with_schema_validation\n\n\n\n****\n- \n- \n\n****\n\n\n- Markdown\n- ",
            "code_start_line": 175,
            "code_end_line": 222,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def function_call_refine(self,req_kwargs,response):\n        \"\"\"Validates and refines the function call response.\n\n        Args:\n            req_kwargs: Request data parameters.\n            response: The response received from the service call.\n\n        Returns:\n            Refined and validated response.\n\n        Raises:\n            FunctionCallSchemaError: Error occurred during the schema validation of the function call.\n        \"\"\"\n        \n        if 'function_call' not in response['choices'][0]['message']:\n            logger.typewriter_log(\"FunctionCallSchemaError: No function call found in the response\", Fore.RED)\n            raise FunctionCallSchemaError(f\"No function call found in the response: {response['choices'][0]['message']} \")\n\n        # verify the schema of the function call if exists\n        function_schema = list(filter(lambda x: x['name'] == response['choices'][0]['message']['function_call']['name'],req_kwargs['functions']))\n        function_schema = None if len(function_schema) == 0 else function_schema[0]\n        \n        if function_schema is None:\n            if '\"{}\"'.format(response['choices'][0]['message']['function_call']['name']) in req_kwargs['messages'][0]['content']:\n                # Temporal fix for tool call without reasoning\n                logger.typewriter_log(\"Warning: Detect tool call without reasoning\",Fore.YELLOW)\n                response['choices'][0]['message']['function_call']['arguments'] = orjson.dumps({\n                    'tool_call':{\n                        'tool_name':response['choices'][0]['message']['function_call']['name'],\n                        'tool_input':response['choices'][0]['message']['function_call']['arguments']\n                    }\n                })\n                return response\n\n            error_message = {\n                'role':'system',\n                'content': f\"Error: Your last function calling call function {response['choices'][0]['message']['function_call']['name']} that is not in the provided functions. Make sure function name in list: {list(map(lambda x:x['name'],req_kwargs['functions']))}\"\n            }\n            \n            if req_kwargs['messages'][-1]['role'] == 'system' and 'Your last function calling call function' in req_kwargs['messages'][-1]['content']:\n                req_kwargs['messages'] = req_kwargs['messages'][:-1]\n            req_kwargs['messages'].append(error_message)\n                \n            logger.typewriter_log(f\"FunctionCallSchemaError: Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions.\",Fore.RED)\n            raise FunctionCallSchemaError(f\"Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions: {list(map(lambda x:x['name'],req_kwargs['functions']))}\")\n            \n        arguments,response = self.load_args_with_schema_validation(function_schema,response['choices'][0]['message']['function_call']['arguments'],req_kwargs['messages'],return_response=True,response=response)\n        return response\n",
            "name_column": 8
        },
        "validate": {
            "type": "FunctionDef",
            "name": "validate",
            "md_content": "**validate**\n\nfunction_schemaargumentsfunction_schemaargumentsargumentsjsonschemaargumentsfunction_schema['parameters']\n\nvalidatenonlocalfunction_schemaargumentsvalidateargumentsjsonschemaargumentsfunction_schema['parameters']\n\nload_args_with_schema_validationargsargumentsvalidateargumentsself.dynamic_json_fixesargumentsargumentsvalidate\n\nreturn_responseTrueargumentsresponsearguments\n\n****\n- function_schema\n- args\n- \n- return_responseTrueresponse",
            "code_start_line": 154,
            "code_end_line": 158,
            "parent": "load_args_with_schema_validation",
            "have_return": false,
            "code_content": "        def validate():\n            nonlocal function_schema,arguments\n            if isinstance(arguments,str):\n                arguments = {} if arguments == '' else json5.loads(arguments)\n            jsonschema.validate(instance=arguments, schema=function_schema['parameters'])\n",
            "name_column": 12
        }
    },
    "XAgent/ai_functions/request/openai.py": {
        "chatcompletion_request": {
            "type": "FunctionDef",
            "name": "chatcompletion_request",
            "md_content": "**chatcompletion_request**OpenAI v1.x.x\n\nOpenAI v1.x.xJSON Web\n\n\n- **kwargsmodel:str\n\n\n- responseChat APIAPI\n\n\n- BadRequestError\n\n****\n- kwargsmodel_namemodelCONFIG.default_completion_kwargs[\"model\"]\n- get_model_name\n- get_apiconfig_by_modelchatcompletion_kwargs\n- kwargsrequest_timeout60\n- chatcompletion_kwargsapi_versionAPIclient\n- clientchat.completions.create\n- completionsmodel_dumpresponse\n- responsefinish_reason\"length\"BadRequestError\n- BadRequestError\"maximum context length\"\n- BadRequestError\n- response\n\n****\n- modelmodel\n- kwargsrequest_timeout\n\n****\n```python\n{\n    \"choices\": [\n        {\n            \"finish_reason\": \"stop\",\n            \"index\": 0,\n            \"message\": {\n                \"content\": \"Hello, World!\"\n            }\n        }\n    ]\n}\n```\n\n\n- tests/test_1106_model_openai.py\n- \n```python\ndef test_1106_model_openai():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n```\n\n- tests/test_model_alias.py\n- \n```python\ndef test_model_alias():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n```",
            "code_start_line": 114,
            "code_end_line": 211,
            "parent": null,
            "have_return": true,
            "code_content": "    def chatcompletion_request(**kwargs):\n        \"\"\"Handle operation of OpenAI v1.x.x chat completion.\n\n        This function operates OpenAI v1.x.x chat completion with provided\n        arguments. It gets the model name, applies a JSON web token, if the\n        response indicates the context length has been exceeded, it attempts\n        to get a higher-capacity language model if it exists in the configuration\n        and reattempts the operation. Otherwise, it will raise an error message.\n\n        Args:\n            **kwargs: Variable length argument list including (model:str, etc.).\n\n        Returns:\n            response (dict): A dictionary containing the response from the Chat API.\n            The structure of the dictionary is based on the API response format.\n\n        Raises:\n            BadRequestError: If any error occurs during chat completion operation or\n            context length limit exceeded and no fallback models available.\n        \"\"\"\n        model_name = get_model_name(\n            kwargs.pop(\"model\", CONFIG.default_completion_kwargs[\"model\"])\n        )\n        logger.debug(\"chatcompletion: using \" + model_name)\n        chatcompletion_kwargs = get_apiconfig_by_model(model_name)\n\n        request_timeout = kwargs.pop(\"request_timeout\", 60)\n        if \"api_version\" in chatcompletion_kwargs:\n            if \"base_url\" in chatcompletion_kwargs:\n                base_url = chatcompletion_kwargs.pop(\"base_url\", None)\n            else:\n                base_url = chatcompletion_kwargs.pop(\"api_base\", None)\n            azure_endpoint = chatcompletion_kwargs.pop(\"azure_endpoint\", base_url)\n            api_version = chatcompletion_kwargs.pop(\"api_version\", None)\n            api_key = chatcompletion_kwargs.pop(\"api_key\", None)\n            chatcompletion_kwargs.pop(\"api_type\", None)\n            if \"engine\" in chatcompletion_kwargs:\n                model = chatcompletion_kwargs.pop(\"engine\", None)\n            else:\n                model = chatcompletion_kwargs.pop(\"model\", None)\n            chatcompletion_kwargs.update({\"model\": model})\n            chatcompletion_kwargs.update(kwargs)\n            client = openai.AzureOpenAI(\n                api_key=api_key,\n                azure_endpoint=azure_endpoint,\n                api_version=api_version,\n                timeout=request_timeout,\n            )\n        else:\n            if \"base_url\" in chatcompletion_kwargs:\n                base_url = chatcompletion_kwargs.pop(\"base_url\", None)\n            else:\n                base_url = chatcompletion_kwargs.pop(\"api_base\", None)\n            api_key = chatcompletion_kwargs.pop(\"api_key\", None)\n            organization = chatcompletion_kwargs.pop(\"organization\", None)\n            chatcompletion_kwargs.update(kwargs)\n            client = openai.OpenAI(\n                api_key=api_key,\n                organization=organization,\n                base_url=base_url,\n                timeout=request_timeout\n            )\n        try:\n            completions = client.chat.completions.create(**chatcompletion_kwargs)\n            response = completions.model_dump()\n            if response[\"choices\"][0][\"finish_reason\"] == \"length\":\n                raise BadRequestError(\n                    message=\"maximum context length exceeded\", response=None, body=None\n                )\n\n        except BadRequestError as e:\n            if \"maximum context length\" in e.message:\n                if model_name == \"gpt-4\" and \"gpt-4-32k\" in CONFIG.api_keys:\n                    model_name = \"gpt-4-32k\"\n                elif model_name == \"gpt-4\" and \"gpt-4-1106-preview\" in CONFIG.api_keys:\n                    model_name = \"gpt-4-1106-preview\"\n                else:\n                    if \"gpt-3.5-turbo-1106\" in CONFIG.api_keys:\n                        model_name = \"gpt-3.5-turbo-1106\"\n                    else:\n                        model_name = \"gpt-3.5-turbo-16k\"\n\n                print(f\"max context length reached, retrying with {model_name}\")\n                chatcompletion_kwargs = get_apiconfig_by_model(model_name)\n                request_timeout = kwargs.pop(\"request_timeout\", 60)\n                if \"base_url\" in chatcompletion_kwargs:\n                    base_url = chatcompletion_kwargs.pop(\"base_url\", None)\n                else:\n                    base_url = chatcompletion_kwargs.pop(\"api_base\", None)\n                api_key = chatcompletion_kwargs.pop(\"api_key\", None)\n                chatcompletion_kwargs.update(kwargs)\n                chatcompletion_kwargs.pop(\"schema_error_retry\", None)\n                completions = client.chat.completions.create(**chatcompletion_kwargs)\n                response = completions.model_dump()\n            else:\n                raise e\n\n        return response\n",
            "name_column": 8
        }
    },
    "XAgent/ai_functions/request/utils.py": {},
    "XAgent/ai_functions/request/xagent.py": {
        "chatcompletion_request": {
            "type": "FunctionDef",
            "name": "chatcompletion_request",
            "md_content": "**chatcompletion_request**: \n\nkwargs\n1. model_namemodel\n2. APIchatcompletion_kwargs\n3. kwargschatcompletion_kwargs\n4. requestsAPIPOSTtop_ptoken\n5. JSON\n\n****: \n- requests\n- API\n- \n\n****\n\n```python\n{\n    \"id\": \"chatcompletion_id\",\n    \"object\": \"chatcompletion\",\n    \"created\": 1638471234,\n    \"model\": \"gpt3.5-turbo\",\n    \"choices\": [\n        {\n            \"message\": {\n                \"role\": \"system\",\n                \"content\": \"You are a helpful assistant.\"\n            },\n            \"finish_reason\": \"stop\",\n            \"index\": 0\n        }\n    ]\n}\n```",
            "code_start_line": 7,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def chatcompletion_request(**kwargs):\n    # logger.info(f\"xagent received {json.dumps(kwargs)}\")\n    model_name = get_model_name(kwargs.pop('model',CONFIG.default_completion_kwargs['model']))\n    logger.debug(\"chatcompletion: using \" + model_name)\n    chatcompletion_kwargs = get_apiconfig_by_model(model_name)\n    chatcompletion_kwargs.update(kwargs)\n\n    response = requests.post(\n        chatcompletion_kwargs.get(\"api_base\",\"http://127.0.0.1:8000/chat/completions\"),\n        headers={\"accept\": \"application/json\", \"Content-Type\": \"application/json\"},\n        json={\n            \"model\": model_name,\n            \"repetition_penalty\": chatcompletion_kwargs.get(\"repetition_penalty\", 1.2),\n            \"temperature\": chatcompletion_kwargs.get(\"temperature\", 0.8),\n            \"top_p\":chatcompletion_kwargs.get(\"top_p\", 1.0),\n            \"frequency_penalty\":chatcompletion_kwargs.get(\"frequency_penalty\",0.5),\n            \"presence_penalty\":chatcompletion_kwargs.get(\"presence_penalty\", 0.0),\n            \"max_tokens\":chatcompletion_kwargs.get(\"max_tokens\", 4096),\n            \"messages\": chatcompletion_kwargs.get(\"messages\", []),\n            \"arguments\": chatcompletion_kwargs.get(\"arguments\", {}),\n            \"functions\": chatcompletion_kwargs.get(\"functions\", []),\n            \"function_call\": chatcompletion_kwargs.get(\"function_call\", {}),\n        }\n    ).json()\n\n    return response\n",
            "name_column": 4
        }
    },
    "XAgent/agent/dispatcher.py": {
        "AgentDispatcher": {
            "type": "ClassDef",
            "name": "AgentDispatcher",
            "md_content": "**AgentDispatcher**: Agent\n\nAgentAgentAgent(agent_markets)\n\nAgentDispatcher(agent_markets)(logger)(RequiredAbilities)AgentDispatcher\n\nAgentDispatcherdispatchAgentDispatcherdispatch_roleregist_agent\n\nAgentDispatcherAutomaticAgentDispatcherXAgentDispatcherdispatchAutomaticAgentDispatcherXAgentDispatcherAgent\n\n****: AgentDispatcher:\n- AgentDispatcher\n- dispatch\n- regist_agent\n\n****:\n```\n# AgentDispatcher\ndispatcher = AgentDispatcher(logger)\n\n# \ndispatcher.regist_agent(agent1)\ndispatcher.regist_agent(agent2)\n\n# \nagent = dispatcher.dispatch(RequiredAbilities.plan_generation, target_task)\n```",
            "code_start_line": 12,
            "code_end_line": 67,
            "parent": null,
            "have_return": true,
            "code_content": "class AgentDispatcher(metaclass=abc.ABCMeta):\n    \"\"\"\n    Base abstract class for Agent Dispatcher.\n    \"\"\"\n    def __init__(self, logger=None):\n        \"\"\"\n        Initialize AgentDispatcher. Assign agent markets for each requirement in RequiredAbilities.\n        Agent markets are initially empty.\n        \"\"\"\n        self.agent_markets = {}\n        self.logger = logger\n        for requirement in RequiredAbilities:\n            self.agent_markets[requirement] = []\n        self.logger.typewriter_log(\n            f\"Constructing an AgentDispatcher:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n\n    @abc.abstractmethod\n    def dispatch(self, ability_type: RequiredAbilities, target_task) -> BaseAgent:\n        \"\"\"\n        Abstract dispatch method to be implemented by subclasses. Dispatches tasks based\n        on ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task: The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        pass\n\n    def dispatch_role(self, target_task: TaskSaveItem) -> AgentRole:\n        \"\"\"\n        Dispatch a role for the target task.\n\n        Args:\n            target_task (TaskSaveItem): The task for which a role needs to be dispatched.\n\n        Returns:\n            AgentRole: Returns a default AgentRole.\n        \"\"\"\n        return AgentRole()\n\n    def regist_agent(self, agent: BaseAgent):\n        \"\"\"\n        Register agent to the respective agent markets based on abilities.\n\n        Args:\n            agent (BaseAgent): The agent that needs to be registered.\n        \"\"\"\n        for requirement in RequiredAbilities:\n            if requirement in agent.abilities:\n                self.agent_markets[requirement].append(agent)\n",
            "name_column": 6
        },
        "AutomaticAgentDispatcher": {
            "type": "ClassDef",
            "name": "AutomaticAgentDispatcher",
            "md_content": "**AutomaticAgentDispatcher**: \n\nAutomaticAgentDispatcherAgentDispatcherdispatch\n\n**dispatch**:\nability_typetarget_taskability_typetarget_taskBaseAgent\n\n:\n- ability_type (RequiredAbilities): \n- target_task: \n\n:\n- BaseAgent: BaseAgent\n\n****:\n- AutomaticAgentDispatcherAgentDispatcherAgentDispatcher\n- dispatchagent_markets\n\n****:\nagent_marketsability_typeRequiredAbilities.ABILITY1dispatchagent_markets[ability_type][0]()",
            "code_start_line": 70,
            "code_end_line": 92,
            "parent": null,
            "have_return": true,
            "code_content": "class AutomaticAgentDispatcher(AgentDispatcher):\n    \"\"\"\n    AgentDispatcher that automatically dispatches tasks to agents.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize AutomaticAgentDispatcher.\n        \"\"\"\n        super().__init__()\n\n    def dispatch(self, ability_type: RequiredAbilities, target_task) -> BaseAgent:\n        \"\"\"\n        Dispatch task to the agent in the market corresponding to the task ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task: The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        return self.agent_markets[ability_type][0]()\n",
            "name_column": 6
        },
        "XAgentDispatcher": {
            "type": "ClassDef",
            "name": "XAgentDispatcher",
            "md_content": "**XAgentDispatcher**\n\nXAgentDispatcherAgentDispatcher\n\n****\n- `__init__(self, config, enable=True, logger=None)`XAgentDispatcher\n  - \n    - `config`\n    - `enable`True\n    - `logger`\n  - XAgentDispatcher\n\n****\n- `get_examples(self, ability_type: RequiredAbilities)`\n  - \n    - `ability_type`\n  - \n  - \n\n****\n- `build_agent(self, ability_type: RequiredAbilities, config, prompt_messages: List[Message], *args, **kwargs) -> BaseAgent`\n  - \n    - `ability_type`\n    - `config`\n    - `prompt_messages`\n    - `*args`\n    - `**kwargs`\n  - \n  - \n\n****\n- `dispatch(self, ability_type: RequiredAbilities, target_task: TaskSaveItem, *args, **kwargs) -> BaseAgent`\n  - \n    - `ability_type`\n    - `target_task`\n    - `*args`\n    - `**kwargs`\n  - \n  - \n\n****\n- \n- \n- \n\n****\n```python\ndispatcher = XAgentDispatcher(config, enable=True, logger=logger)\nexamples = dispatcher.get_examples(RequiredAbilities.plan_generation)\nagent = dispatcher.build_agent(RequiredAbilities.plan_generation, config, prompt_messages, *args, **kwargs)\nresult = dispatcher.dispatch(RequiredAbilities.plan_generation, target_task, *args, **kwargs)\n```",
            "code_start_line": 95,
            "code_end_line": 202,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentDispatcher(AgentDispatcher):\n    \"\"\"Generate the prompt and the agent for the given task.\"\"\"\n\n    def __init__(self, config, enable=True, logger=None):\n        \"\"\"\n        Initialize XAgentDispatcher.\n\n        Args:\n            config: Dispatcher configuration.\n            enable (bool, optional): Whether the dispatcher is active. Defaults to True.\n        \"\"\"\n        self.logger = logger\n        super().__init__(logger)\n        self.config = config\n        self.dispatcher = DispatcherAgent(config)\n        self.enable = enable\n\n    def get_examples(self, ability_type: RequiredAbilities):\n        \"\"\"\n        Get examples based on the ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type for which examples are needed.\n\n        Returns:\n            Returns examples for the dispatcher.\n        \"\"\"\n        if ability_type == RequiredAbilities.plan_generation:\n            from .plan_generate_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.plan_refinement:\n            from .plan_refine_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.tool_tree_search:\n            from .tool_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.reflection:\n            from .reflect_agent import get_examples_for_dispatcher\n        return get_examples_for_dispatcher()\n\n    def build_agent(\n        self,\n        ability_type: RequiredAbilities,\n        config,\n        prompt_messages: List[Message],\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Build agent based on the ability type. If failed, fallback to use default agent.\n\n        Args:\n            ability_type (RequiredAbilities): Type of ability required by the agent.\n            config: Configuration for the agent.\n            prompt_messages (List[Message]): List of prompt messages for the agent.\n\n        Returns:\n            BaseAgent: The built agent.\n        \"\"\"\n        try:\n            agent = self.agent_markets[ability_type][0](\n                config, prompt_messages, *args, **kwargs\n            )\n        except:\n            # TODO: remove when all the agents can be created with dispatcher.\n            self.logger.info(\"build agent error, use default agent\")\n            agent = self.agent_markets[ability_type][0](config, *args, **kwargs)\n        return agent\n\n    def dispatch(\n        self,\n        ability_type: RequiredAbilities,\n        target_task: TaskSaveItem,\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Dispatch task to the agent in the market corresponding to the task ability type.\n        Additionally refines the prompt for the task and builds the agent.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task (TaskSaveItem): The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        example_input, example_system_prompt, example_user_prompt = self.get_examples(\n            ability_type\n        )\n        if self.enable:\n            self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"Refine the prompt of a specific agent for {Fore.GREEN}RequiredAbilities.{ability_type.name}{Style.RESET_ALL}\")\n            _, prompt_messages, tokens = self.dispatcher.parse(\n                target_task, example_input, example_system_prompt, example_user_prompt\n            )\n            print(prompt_messages)\n            if prompt_messages[0].content == \"\" and prompt_messages[1].content == \"\":\n                self.logger.info(\"Dispatcher fail to follow the output format, we fallback to use the default prompt.\")\n                prompt_messages = [\n                    Message(role=\"system\", content=example_system_prompt),\n                    Message(role=\"user\", content=example_user_prompt),\n                ]\n            else:\n                self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"The prompt has been refined!\")\n        else:\n            prompt_messages = [\n                Message(role=\"system\", content=example_system_prompt),\n                Message(role=\"user\", content=example_user_prompt),\n            ]\n        agent = self.build_agent(ability_type, self.config, prompt_messages, *args, **kwargs)\n        return agent\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**XAgentDispatcher\n\n\n- configDispatcher\n- enableDispatcherTrue\n\nloggerself.logger__init__loggerconfigself.configDispatcherAgentconfigself.dispatcherenableself.enable\n\n****",
            "code_start_line": 98,
            "code_end_line": 110,
            "parent": "XAgentDispatcher",
            "have_return": false,
            "code_content": "    def __init__(self, config, enable=True, logger=None):\n        \"\"\"\n        Initialize XAgentDispatcher.\n\n        Args:\n            config: Dispatcher configuration.\n            enable (bool, optional): Whether the dispatcher is active. Defaults to True.\n        \"\"\"\n        self.logger = logger\n        super().__init__(logger)\n        self.config = config\n        self.dispatcher = DispatcherAgent(config)\n        self.enable = enable\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "FunctionDef",
            "name": "dispatch",
            "md_content": "**dispatch**\n\n\n- ability_type (RequiredAbilities)\n- target_task (TaskSaveItem)\n- *args\n- **kwargs\n\nBaseAgent\n\nget_examplesenableTruedispatcherparsebuild_agent\n\n****dispatchget_examples\n\n****\n```\nagent = agent_dispatcher.dispatch(RequiredAbilities.plan_generation, target_task=\"Generate a plan to accomplish the task: {self.query.task}\")\nprint(agent)\n```\n\n```\n<agent.dispatcher_agent.agent.Agent object at 0x7f8a0b1f5a90>\n```",
            "code_start_line": 161,
            "code_end_line": 202,
            "parent": "XAgentDispatcher",
            "have_return": true,
            "code_content": "    def dispatch(\n        self,\n        ability_type: RequiredAbilities,\n        target_task: TaskSaveItem,\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Dispatch task to the agent in the market corresponding to the task ability type.\n        Additionally refines the prompt for the task and builds the agent.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task (TaskSaveItem): The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        example_input, example_system_prompt, example_user_prompt = self.get_examples(\n            ability_type\n        )\n        if self.enable:\n            self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"Refine the prompt of a specific agent for {Fore.GREEN}RequiredAbilities.{ability_type.name}{Style.RESET_ALL}\")\n            _, prompt_messages, tokens = self.dispatcher.parse(\n                target_task, example_input, example_system_prompt, example_user_prompt\n            )\n            print(prompt_messages)\n            if prompt_messages[0].content == \"\" and prompt_messages[1].content == \"\":\n                self.logger.info(\"Dispatcher fail to follow the output format, we fallback to use the default prompt.\")\n                prompt_messages = [\n                    Message(role=\"system\", content=example_system_prompt),\n                    Message(role=\"user\", content=example_user_prompt),\n                ]\n            else:\n                self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"The prompt has been refined!\")\n        else:\n            prompt_messages = [\n                Message(role=\"system\", content=example_system_prompt),\n                Message(role=\"user\", content=example_user_prompt),\n            ]\n        agent = self.build_agent(ability_type, self.config, prompt_messages, *args, **kwargs)\n        return agent\n",
            "name_column": 8
        },
        "dispatch_role": {
            "type": "FunctionDef",
            "name": "dispatch_role",
            "md_content": "**dispatch_role**\n\n\ntarget_taskTaskSaveItemAgentRole\n\n****\n- AgentRole\n\n****\n```\nAgentRole()\n```",
            "code_start_line": 46,
            "code_end_line": 56,
            "parent": "AgentDispatcher",
            "have_return": true,
            "code_content": "    def dispatch_role(self, target_task: TaskSaveItem) -> AgentRole:\n        \"\"\"\n        Dispatch a role for the target task.\n\n        Args:\n            target_task (TaskSaveItem): The task for which a role needs to be dispatched.\n\n        Returns:\n            AgentRole: Returns a default AgentRole.\n        \"\"\"\n        return AgentRole()\n",
            "name_column": 8
        },
        "regist_agent": {
            "type": "FunctionDef",
            "name": "regist_agent",
            "md_content": "**regist_agent**\n\nagentRequiredAbilitiesabilityagentabilitiesagentability\n\n****\n- agentBaseAgent\n- agentabilitiesRequiredAbilitiesabilityagent",
            "code_start_line": 58,
            "code_end_line": 67,
            "parent": "AgentDispatcher",
            "have_return": false,
            "code_content": "    def regist_agent(self, agent: BaseAgent):\n        \"\"\"\n        Register agent to the respective agent markets based on abilities.\n\n        Args:\n            agent (BaseAgent): The agent that needs to be registered.\n        \"\"\"\n        for requirement in RequiredAbilities:\n            if requirement in agent.abilities:\n                self.agent_markets[requirement].append(agent)\n",
            "name_column": 8
        },
        "get_examples": {
            "type": "FunctionDef",
            "name": "get_examples",
            "md_content": "**get_examples**\n\nget_examples_for_dispatcher\n\n\n- ability_type (RequiredAbilities)\n\n\n- dispatcher\n\n\n\nXAgent/agent/dispatcher.py\n\n```python\nexample_input, example_system_prompt, example_user_prompt = self.get_examples(\n    ability_type\n)\n```\n\n\nability_typeability_typeget_examples_for_dispatcherability_typeplan_generate_agentplan_refine_agenttool_agentreflect_agentget_examples_for_dispatcherget_examples_for_dispatcher\n\n\n- get_examples_for_dispatcher\n\n\nability_typeRequiredAbilities.plan_generationability_typeplan_generate_agentget_examples_for_dispatcherget_examples_for_dispatcherexampleexample",
            "code_start_line": 112,
            "code_end_line": 130,
            "parent": "XAgentDispatcher",
            "have_return": true,
            "code_content": "    def get_examples(self, ability_type: RequiredAbilities):\n        \"\"\"\n        Get examples based on the ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type for which examples are needed.\n\n        Returns:\n            Returns examples for the dispatcher.\n        \"\"\"\n        if ability_type == RequiredAbilities.plan_generation:\n            from .plan_generate_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.plan_refinement:\n            from .plan_refine_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.tool_tree_search:\n            from .tool_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.reflection:\n            from .reflect_agent import get_examples_for_dispatcher\n        return get_examples_for_dispatcher()\n",
            "name_column": 8
        },
        "build_agent": {
            "type": "FunctionDef",
            "name": "build_agent",
            "md_content": "**build_agent**\n\n\n- ability_typeRequiredAbilities\n- config\n- prompt_messagesList[Message]\n\nBaseAgent\n\nability_typeagent_marketsconfigprompt_messages\n\n\nXAgent/agent/dispatcher.py\n\n```\nagent = self.build_agent(ability_type, self.config, prompt_messages, *args, **kwargs)\n```\n\n****\n\n****RequiredAbilities.Aconfig{\"param1\": \"value1\"}prompt_messages[Message(role=\"system\", content=\"System prompt\"), Message(role=\"user\", content=\"User prompt\")]BaseAgent",
            "code_start_line": 132,
            "code_end_line": 159,
            "parent": "XAgentDispatcher",
            "have_return": true,
            "code_content": "    def build_agent(\n        self,\n        ability_type: RequiredAbilities,\n        config,\n        prompt_messages: List[Message],\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Build agent based on the ability type. If failed, fallback to use default agent.\n\n        Args:\n            ability_type (RequiredAbilities): Type of ability required by the agent.\n            config: Configuration for the agent.\n            prompt_messages (List[Message]): List of prompt messages for the agent.\n\n        Returns:\n            BaseAgent: The built agent.\n        \"\"\"\n        try:\n            agent = self.agent_markets[ability_type][0](\n                config, prompt_messages, *args, **kwargs\n            )\n        except:\n            # TODO: remove when all the agents can be created with dispatcher.\n            self.logger.info(\"build agent error, use default agent\")\n            agent = self.agent_markets[ability_type][0](config, *args, **kwargs)\n        return agent\n",
            "name_column": 8
        }
    },
    "XAgent/agent/base_agent.py": {
        "BaseAgent": {
            "type": "ClassDef",
            "name": "BaseAgent",
            "md_content": "**BaseAgent**BaseAgentAbstract Base Class (abc)\n\n****\n- abilities (set)BaseAgentRequiredAbilitiesBaseAgent\n\n****\n- \\_\\_init\\_\\_(self, config, prompt_messages: List[Message] = None)\n  - \n    - config (obj)\n    - prompt_messages (List)\n- parse(self, **args) -> (LLMStatusCode, Message, dict)\n- fill_in_placeholders(self, placeholders: dict)\n  - \n    - placeholders (dict)\n  - \n    - filled_messages\n- generate(self, messages:list[dict]|list[Message], arguments:dict=None, functions:list[dict]=None, function_call:dict=None, stop:dict=None, *args,**kwargs)AI\n  - \n    - messages (list[dict]|list[Message])AI\n    - arguments (dict, optional)AI\n    - functions (list[dict], optional)AI\n    - function_call (dict, optional)AI\n    - stop (dict, optional)AI\n    - *args\n    - **kwargs\n  - \n    - message (dict)AI\n    - tokens (int)AI\n\n****`generate``messages``arguments``functions``function_call``stop`\n\n****\n```python\nconfig = ...\nagent = BaseAgent(config)\nplaceholders = {\n    \"system\": {\n        \"placeholder1\": \"value1\",\n        \"placeholder2\": \"value2\"\n    },\n    \"user\": {\n        \"placeholder3\": \"value3\",\n        \"placeholder4\": \"value4\"\n    }\n}\nfilled_messages = agent.fill_in_placeholders(placeholders)\nprint(filled_messages)\n# Output:\n# [Message(role='system', content='System message with value1 and value2'),\n#  Message(role='user', content='User message with value3 and value4')]\n\nmessages = [\n    Message(role='system', content='System message'),\n    Message(role='user', content='User message')\n]\narguments = {\n    'arg1': 'value1',\n    'arg2': 'value2'\n}\nfunctions = [\n    {\n        'name': 'function1',\n        'parameters': {\n            'param1': 'value1',\n            'param2': 'value2'\n        }\n    }\n]\nfunction_call = {\n    'name': 'function1',\n    'arguments': {\n        'arg1': 'value1',\n        'arg2': 'value2'\n    }\n}\nstop = {\n    'condition': 'stop_condition'\n}\nmessage, tokens = agent.generate(messages, arguments, functions, function_call, stop)\nprint(message)\nprint(tokens)\n# Output:\n# {'content': 'Generated message', 'function_call': {'name': 'function1', 'arguments': {'arg1': 'value1', 'arg2': 'value2'}}}\n# 100\n```",
            "code_start_line": 14,
            "code_end_line": 155,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseAgent(metaclass=abc.ABCMeta):\n    \"\"\"\n    The BaseAgent class abstracts the essential attributes and methods for classes,\n    which inherit it. It is a metaclass of the Abstract Base Class (abc module).\n\n    Attributes:\n        abilities (set): A set of RequiredAbilities, which are necessary skills for BaseAgent.\n    \"\"\"\n\n    abilities = set([\n        RequiredAbilities.plan_generation,\n        RequiredAbilities.plan_refinement,\n        RequiredAbilities.task_evaluator,\n        RequiredAbilities.tool_tree_search,\n        RequiredAbilities.reflection,\n        RequiredAbilities.summarization,\n    ])\n\n    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Constructs an agent object with set abilities, configuration settings,\n        and initial set of prompt messages.\n\n        Args:\n            config (obj): Configuration settings for agent.\n            prompt_messages (List): Initial set of messages user gives to interact with the agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"Constructing an Agent:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.config = config\n        self.prompt_messages = prompt_messages\n        self.usage = { }\n\n    @abc.abstractmethod\n    def parse(self,**args) -> (LLMStatusCode, Message, dict):\n        \"\"\"\n        Abstract method that needs to be implemented by the subclasses.\n        Required for parsing the given arguments.\n        \"\"\"\n        pass    \n\n    def fill_in_placeholders(self, placeholders: dict):\n        \"\"\"\n        Fills in placeholders defined in the input with the corresponding values.\n        \n        Args:\n            placeholders (dict): A dictionary containing keys as placeholders and values as their replacements.\n\n        Returns:\n            filled_messages: A copy of the initial prompt_messages with placeholders replaced with their corresponding values.\n        \"\"\"\n        filled_messages = deepcopy(self.prompt_messages)\n        for message in filled_messages:\n            role = message.role\n            if role in placeholders:\n                for key, value in placeholders[role].items():\n                    message.content = message.content.replace(\"{{\" + str(key) + \"}}\", str(value))\n        return filled_messages\n\n    def generate(self,\n                 messages:list[dict]|list[Message],\n                 arguments:dict=None,\n                 functions:list[dict]=None,\n                 function_call:dict=None,\n                 stop:dict=None,\n                 *args,**kwargs):\n        \"\"\"\n        Generates a response from the AI model, using the given messages, arguments, functions,\n        and a function call.\n\n        Args:\n            messages (list[dict]|list[Message]): A list of messages with which to interact with the AI model.\n            arguments (dict, optional): A dictionary containing arguments to use for AI model responses.\n            functions (list[dict], optional): A list of dictionaries representing functions to use for AI model responses.\n            function_call (dict, optional): A dictionary representing a function call to use for AI model responses.\n            stop (dict, optional): A dictionary that signifies when to stop the conversation with the AI model.\n            *args: Variable list of arguments. \n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            message (dict): A message generated by the AI model.\n            tokens (int): Number of tokens used in generating the AI model's response.\n        \"\"\"\n        if isinstance(messages[0],Message):\n            messages = [message.raw() for message in messages]\n        if functions is not None and len(functions) == 1 and function_call is None:\n            function_call = {'name':functions[0]['name']} # must call at least one function\n        match CONFIG.default_request_type:\n            case 'openai':\n                if arguments is not None:\n                    if functions is None or len(functions) == 0:\n                        functions = [{\n                            'name':'reasoning',\n                            'parameters':arguments\n                        }]\n                        function_call = {'name':'reasoning'}\n                    elif len(functions) == 1:\n                        for k,v in arguments['properties'].items():\n                            functions[0]['parameters']['properties'][k] = v\n                            if k in arguments['required']:\n                                functions[0]['parameters']['required'].append(k)\n                    else:\n                        raise NotImplementedError(\"Not implemented for multiple functions with arguments\")\n                    \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                \n                message = {}\n                function_call_args:dict = json5.loads(response[\"choices\"][0][\"message\"][\"function_call\"]['arguments'])\n                \n                if arguments is not None:\n                    message['arguments'] = {\n                        k: function_call_args.pop(k)\n                        for k in arguments['properties'].keys() if k in function_call_args\n                    }\n                if len(function_call_args) > 0:\n                    message['function_call'] = {\n                        'name': response['choices'][0]['message']['function_call']['name'],\n                        'arguments': function_call_args\n                    }\n\n            case 'xagent':\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                message = json5.loads(response[\"choices\"][0][\"message\"]['content'])\n            case _:\n                raise NotImplementedError(f\"Request type {CONFIG.default_request_type} not implemented\")\n            \n        tokens = response[\"usage\"]\n        return message, tokens\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Agent\n\n\n- configAgent\n- prompt_messagesAgentNone\n- logger.typewriter_logAgent\n- configself.configprompt_messagesself.prompt_messages\n- self.usage\n\n****",
            "code_start_line": 32,
            "code_end_line": 48,
            "parent": "BaseAgent",
            "have_return": false,
            "code_content": "    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Constructs an agent object with set abilities, configuration settings,\n        and initial set of prompt messages.\n\n        Args:\n            config (obj): Configuration settings for agent.\n            prompt_messages (List): Initial set of messages user gives to interact with the agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"Constructing an Agent:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.config = config\n        self.prompt_messages = prompt_messages\n        self.usage = { }\n",
            "name_column": 8
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse**\n\n****\nparseargsLLMStatusCodeMessagedict\n\n****parse",
            "code_start_line": 51,
            "code_end_line": 56,
            "parent": "BaseAgent",
            "have_return": false,
            "code_content": "    def parse(self,**args) -> (LLMStatusCode, Message, dict):\n        \"\"\"\n        Abstract method that needs to be implemented by the subclasses.\n        Required for parsing the given arguments.\n        \"\"\"\n        pass    \n",
            "name_column": 8
        },
        "fill_in_placeholders": {
            "type": "FunctionDef",
            "name": "fill_in_placeholders",
            "md_content": "**fill_in_placeholders**\n\n\n\nprompt_messages\n\n\n```python\ndef fill_in_placeholders(self, placeholders: dict):\n    filled_messages = deepcopy(self.prompt_messages)\n    for message in filled_messages:\n        role = message.role\n        if role in placeholders:\n            for key, value in placeholders[role].items():\n                message.content = message.content.replace(\"{{\" + str(key) + \"}}\", str(value))\n    return filled_messages\n```\n\n****\n- placeholders\n- prompt_messages\n\n****\n```python\n[\n    Message(role='user', content='Hello, {{name}}!'),\n    Message(role='assistant', content='Hi there, {{name}}! How can I assist you?')\n]\n```\n\n\n1. XAgent/agent/plan_generate_agent/agent.py\n   \n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments: dict = None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages = prompt_messages + additional_messages\n\n       return self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args, **kwargs\n       )\n   ```\n2. XAgent/agent/plan_refine_agent/agent.py\n   \n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments:dict = None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       additional_insert_index: int = -1,\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages =prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n       \n       return self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args,**kwargs\n       )\n   ```\n3. XAgent/agent/reflect_agent/agent.py\n   \n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments:dict = None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages = prompt_messages + additional_messages\n\n       return self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args,**kwargs\n       )\n   ```\n4. XAgent/agent/tool_agent/agent.py\n   \n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments:dict=None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       additional_insert_index: int = -1,\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages = prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n       messages = [message.raw() for message in messages]\n       \n       if self.config.default_request_type == 'openai':\n           arguments = None\n           functions = list(filter(lambda x: x['name'] not in ['subtask_submit','subtask_handle'],functions))\n           if CONFIG.enable_ask_human_for_help:\n               functions += [function_manager.get_function_schema('ask_human_for_help')]\n           messages[0]['content'] += '\\n--- Avaliable Tools ---\\nYou are allowed to use tools in the \"subtask_handle.tool_call\" function field.\\nRemember the \"subtask_handle.tool_call.tool_input\" field should always in JSON, as following described:\\n{}'.format(json.dumps(functions,indent=2))\n           \n           def change_tool_call_description(message:dict,reverse:bool=False):\n               des_pairs = [('Use tools to handle the subtask',\n                             'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                            ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                             '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                            ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                             'After decide the action, call functions to apply action.')]\n               \n               for pair in des_pairs:\n                   message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                   \n               return message\n           \n           messages[0] = change_tool_call_description(messages[0])\n           functions = [function_manager.get_function_schema('subtask_submit'),\n                        function_manager.get_function_schema('subtask_handle')]\n\n       message,tokens = self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args,**kwargs\n       )\n\n       function_call_args:dict = message['function_call']['arguments']\n\n       if self.config.default_request_type == 'openai' and 'tool_call' in function_call_args:\n           tool_schema = function_manager.get_function_schema(function_call_args['tool_call'][\"tool_name\"])\n           assert tool_schema is not None, f\"Function {function_call_args['tool_call']['tool_name']} not found! Poential Schema Validation Error!\"\n           \n           tool_call_args = function_call_args['tool_call']['tool_input'] if 'tool_input' in function_call_args['tool_call'] else ''\n           \n           def validate():\n               nonlocal tool_schema,tool_call_args\n               if isinstance(tool_call_args,str):\n                   tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n               jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n           \n           try:\n               validate()\n           except Exception as e:  \n               messages[0] = change_tool_call_description(messages[0],reverse=True)\n               tool_call_args = objgenerator.dynamic_json_fixes(\n                   broken_json=tool_call_args,\n                   function_schema=tool_schema,\n                   messages=messages,\n                   error_message=str(e))[\"choices\"][0][\"message\"][\"function_call\"][\"arguments\"]\n               validate()\n           \n           function_call_args['tool_call']['tool_input'] = tool_call_args\n           \n           message['function_call'] = function_call_args.pop('tool_call')\n           message['function_call']['name'] = message['function_call'].pop('tool_name')\n           message['function_call']['arguments'] = message['function_call'].pop('tool_input')\n           message['arguments'] = function_call_args\n               \n       return message,tokens\n   ```",
            "code_start_line": 58,
            "code_end_line": 74,
            "parent": "BaseAgent",
            "have_return": true,
            "code_content": "    def fill_in_placeholders(self, placeholders: dict):\n        \"\"\"\n        Fills in placeholders defined in the input with the corresponding values.\n        \n        Args:\n            placeholders (dict): A dictionary containing keys as placeholders and values as their replacements.\n\n        Returns:\n            filled_messages: A copy of the initial prompt_messages with placeholders replaced with their corresponding values.\n        \"\"\"\n        filled_messages = deepcopy(self.prompt_messages)\n        for message in filled_messages:\n            role = message.role\n            if role in placeholders:\n                for key, value in placeholders[role].items():\n                    message.content = message.content.replace(\"{{\" + str(key) + \"}}\", str(value))\n        return filled_messages\n",
            "name_column": 8
        },
        "generate": {
            "type": "FunctionDef",
            "name": "generate",
            "md_content": "**generate**AI\n\n\n- messages (list[dict]|list[Message])AI\n- arguments (dict, optional)AI\n- functions (list[dict], optional)AI\n- function_call (dict, optional)AI\n- stop (dict, optional)AI\n- *args\n- **kwargs\n\nAI\n\n****\n- messagesMessage\n- \n  - 'openai'\n    - argumentsNonearguments\n    - functionsNone0\n    - functionsfunction_callNone\n    - functionsargumentsNonearguments\n    - functionsNotImplementedError\n    - objgenerator.chatcompletionAI\n    - \n  - 'xagent'objgenerator.chatcompletionAI\n  - NotImplementedError\n- \n\n****\n- messages\n- argumentsAI\n- functions\n- function_call\n- stopAI\n- \n\n****\n```python\nmessage = {\n    'content': 'This is the generated response.',\n    'arguments': {\n        'argument1': 'value1',\n        'argument2': 'value2'\n    },\n    'function_call': {\n        'name': 'function_name',\n        'arguments': {\n            'arg1': 'value1',\n            'arg2': 'value2'\n        }\n    }\n}\ntokens = 100\n```",
            "code_start_line": 76,
            "code_end_line": 155,
            "parent": "BaseAgent",
            "have_return": true,
            "code_content": "    def generate(self,\n                 messages:list[dict]|list[Message],\n                 arguments:dict=None,\n                 functions:list[dict]=None,\n                 function_call:dict=None,\n                 stop:dict=None,\n                 *args,**kwargs):\n        \"\"\"\n        Generates a response from the AI model, using the given messages, arguments, functions,\n        and a function call.\n\n        Args:\n            messages (list[dict]|list[Message]): A list of messages with which to interact with the AI model.\n            arguments (dict, optional): A dictionary containing arguments to use for AI model responses.\n            functions (list[dict], optional): A list of dictionaries representing functions to use for AI model responses.\n            function_call (dict, optional): A dictionary representing a function call to use for AI model responses.\n            stop (dict, optional): A dictionary that signifies when to stop the conversation with the AI model.\n            *args: Variable list of arguments. \n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            message (dict): A message generated by the AI model.\n            tokens (int): Number of tokens used in generating the AI model's response.\n        \"\"\"\n        if isinstance(messages[0],Message):\n            messages = [message.raw() for message in messages]\n        if functions is not None and len(functions) == 1 and function_call is None:\n            function_call = {'name':functions[0]['name']} # must call at least one function\n        match CONFIG.default_request_type:\n            case 'openai':\n                if arguments is not None:\n                    if functions is None or len(functions) == 0:\n                        functions = [{\n                            'name':'reasoning',\n                            'parameters':arguments\n                        }]\n                        function_call = {'name':'reasoning'}\n                    elif len(functions) == 1:\n                        for k,v in arguments['properties'].items():\n                            functions[0]['parameters']['properties'][k] = v\n                            if k in arguments['required']:\n                                functions[0]['parameters']['required'].append(k)\n                    else:\n                        raise NotImplementedError(\"Not implemented for multiple functions with arguments\")\n                    \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                \n                message = {}\n                function_call_args:dict = json5.loads(response[\"choices\"][0][\"message\"][\"function_call\"]['arguments'])\n                \n                if arguments is not None:\n                    message['arguments'] = {\n                        k: function_call_args.pop(k)\n                        for k in arguments['properties'].keys() if k in function_call_args\n                    }\n                if len(function_call_args) > 0:\n                    message['function_call'] = {\n                        'name': response['choices'][0]['message']['function_call']['name'],\n                        'arguments': function_call_args\n                    }\n\n            case 'xagent':\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                message = json5.loads(response[\"choices\"][0][\"message\"]['content'])\n            case _:\n                raise NotImplementedError(f\"Request type {CONFIG.default_request_type} not implemented\")\n            \n        tokens = response[\"usage\"]\n        return message, tokens\n",
            "name_column": 8
        }
    },
    "XAgent/agent/__init__.py": {},
    "XAgent/agent/summarize.py": {
        "summarize_action": {
            "type": "FunctionDef",
            "name": "summarize_action",
            "md_content": "**summarize_action**\n\naction_processtask\n\naction_process1\"\"\n\ngenerate_func_argsargsblack_listargsargs\n\naction_processTOOL_CALL_SUCCESSraw_action\"FileSystem\"\"filepath\"TOOL_CALL_SUCCESSraw_action\"`Old Content has been wrapped, check latest filesystem calling`\"raw_actionraw_actions\n\nraw_actions\"summary\"function_manager\n\n\n\n****\n- action_process\n- task\n\n****action_process\n```\n[0] command1(args1)\n[0][summary] summary1\n[0][description] description1\n[0][status code] TOOL_CALL_SUCCESS\n[0][return] return_value1\n[1] command2(args2)\n[1][summary] summary2\n[1][description] description2\n[1][status code] TOOL_CALL_SUCCESS\n[1][return] return_value2\n[suggestion] suggestion1\n[suggestion] suggestion2\n```",
            "code_start_line": 11,
            "code_end_line": 163,
            "parent": null,
            "have_return": true,
            "code_content": "def summarize_action(action_process:list[dict], task:str,)->(list[str],str):\n    \"\"\"\n    Generate a summarized series of actions.\n\n    Args:\n        action_process (list[dict]): The list of actions to process.\n        task (str): The task name.\n\n    Returns:\n        str: The string contains a summary of the actions.\n    \"\"\"\n    if len(action_process) < 1:\n        return \"No steps found\"\n    \n    def generate_func_args(args:dict,black_list=[])->str:\n        \"\"\"\n        Generate function arguments in the form of strings.\n\n        Args:\n            args (dict): A dictionary of arguments.\n            black_list (list): A list of forbidden or restricted words or keys in the args dictionary.\n\n        Returns:\n            str: A string that summarizes the function arguments.\n        \"\"\"\n        ret = ''\n        args_len = 0\n        for k,v in args.items():\n            if k in black_list:\n                v = '`wrapped`'\n            v_str,v_len = clip_text(str(v),SINGLE_ACTION_MAX_LENGTH-args_len,clip_end=True)\n            if v_len < SINGLE_ACTION_MAX_LENGTH-args_len:\n                ret += f'{k}=\"{v_str}\",' if isinstance(v,str) else f'{k}={v_str},'\n                args_len += v_len\n            else:\n                ret += f'{k}=\"{v_str}...\",' if isinstance(v,str) else f'{k}={v_str}...,'\n                args_len += SINGLE_ACTION_MAX_LENGTH-args_len\n                \n        return ret[:-1] # remove last comma\n    \n    # wrap old content\n    raw_actions = {}\n    accessed_files = []\n    last_successful_action_index = None\n    last_failed_action_index = None\n    for index,action in zip(range(len(action_process)-1,-1,-1),action_process[::-1]):\n        if last_successful_action_index is None and action['tool_status_code'] == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            last_successful_action_index = index\n        if last_failed_action_index is None and action['tool_status_code'] == ToolCallStatusCode.TOOL_CALL_FAILED:\n            last_failed_action_index = index\n        \n        command = action[\"command\"][\"properties\"]\n        if command['name'] == '' or not isinstance(command['args'],dict):\n            continue\n        \n        raw_action = ['`placeholder`','`placeholder`']\n        \n        if \"FileSystem\" in command[\"name\"] and \"filepath\" in command[\"args\"] and action[\"tool_status_code\"] == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            raw_action[0] = command['name']+f\"({generate_func_args(command['args'],black_list=['content','new_content'])})\"\n            if command['args']['filepath'] in accessed_files:\n                raw_action[1] = \"`Old Content has been wrapped, check latest filesystem calling`\"\n            else:\n                raw_action[1] = str(action['tool_output'])\n                accessed_files.append(command[\"args\"][\"filepath\"])\n        else:\n            raw_action[0] = command['name']+f\"({generate_func_args(command['args'])})\"\n            raw_action[1] = str(action['tool_output'])\n            \n        raw_actions[index] = raw_action\n    valid_index = list(raw_actions.keys())\n    valid_index.sort()\n    \n    ret = {}\n    for index in valid_index:\n        action = action_process[index]\n        if 'summary' not in action:\n            raw_actions_des = '\\n'.join([\n                f'[{k}] {v}' for k,v in action['thoughts']['properties'].items()\n            ] + [\n                f\"[tool_status_code] {action['tool_status_code']}\",\n                f\"[tool calling] {raw_actions[index][0]}\",\n                f\"[return] \"\n            ])\n            raw_actions_des += clip_text(raw_actions[index][1],MAX_RETURN_LENGTH-get_token_nums(raw_actions_des))[0]\n            \n            summary,tokens = function_manager('summarize_action',\n                                              action=raw_actions_des,current_task=task,\n                                              return_generation_usage=True,)\n            action['summary'] = summary\n            logger.typewriter_log(f\"Action summarized in {tokens['completion_tokens']} tokens\",Fore.YELLOW)\n        else:\n            summary = action['summary']\n        \n        act_str = '\\n'.join([\n            f'[{index}] {raw_actions[index][0]}',\n            f\"[{index}][summary] {summary['summary']}\",\n            f\"[{index}][description] {summary['description']}\",\n            f\"[{index}][status code] {action['tool_status_code']}\"\n        ])\n        if 'failed_reason_and_reflection' in summary and summary['failed_reason_and_reflection'] != '':\n            act_str += f'\\n[{index}][failed reason] {summary[\"failed_reason_and_reflection\"]}'\n        \n        # directly adding short returns\n        if len(raw_actions[index][1]) < 1000 and get_token_nums(raw_actions[index][1]) < 150:\n            act_str += f'\\n[{index}][return] {raw_actions[index][1]}'\n            \n        ret[index] = act_str\n    \n    reflection = function_manager('actions_reflection',\n                                  actions=clip_text('\\n'.join([ret[i] for i in valid_index]),MAX_RETURN_LENGTH)[0],\n                                  current_task=task)\n    \n    ret_lenght = {k:get_token_nums(v) for k,v in ret.items()}\n    total_length = sum(ret_lenght.values())\n    \n    # adding more return to last successful action\n    for i in [last_successful_action_index,last_failed_action_index]:\n        if i is not None and '[return]' not in ret[i]:\n            s = f'\\n[{i}][return] {clip_text(raw_actions[i][1],(MAX_RETURN_LENGTH-total_length)//2)[0]}'\n            return_length = get_token_nums(s)\n            ret_lenght[i] += return_length\n            total_length += return_length\n            ret[i] += s\n\n    key_actions:list = reflection['key_actions']\n    key_actions.sort(reverse=True)\n    for i in key_actions:\n        if total_length >= MAX_RETURN_LENGTH:\n            break\n        if i in ret and action_process[i][\"tool_status_code\"] == ToolCallStatusCode.TOOL_CALL_SUCCESS and '[return]' not in ret[i]:\n            s = f'\\n[{i}][return] {clip_text(raw_actions[i][1],SINGLE_ACTION_MAX_LENGTH-ret_lenght[i])[0]}'\n            if (tokens := get_token_nums(s))> MAX_RETURN_LENGTH-total_length:\n                continue\n            total_length += tokens\n            ret[i] += s\n    \n    while len(valid_index) > 0:\n        i = valid_index.pop()\n        if total_length >= MAX_RETURN_LENGTH:\n            break\n        if action_process[i][\"tool_status_code\"] == ToolCallStatusCode.TOOL_CALL_SUCCESS and '[return]' not in ret[i]:\n            s = f'\\n[{i}][return] {clip_text(raw_actions[i][1],SINGLE_ACTION_MAX_LENGTH-ret_lenght[i])[0]}'\n            if (tokens := get_token_nums(s))> MAX_RETURN_LENGTH-total_length:\n                continue\n            total_length += tokens\n            ret[i] += s\n\n\n    valid_index = list(ret.keys())\n    valid_index.sort()\n    ordered_rets = [ret[i] for i in valid_index] + [f'[suggestion] {sugg}'for sugg in reflection[\"suggestions\"]]\n    \n    return '\\n'.join(ordered_rets)\n",
            "name_column": 4
        },
        "summarize_plan": {
            "type": "FunctionDef",
            "name": "summarize_plan",
            "md_content": "**summarize_plan**\n\nplans\n\nrecursive_summarysummary\n\nsummarytask_idsIDdetailed_infocurrent_task_idID\n\n\n\n****get_token_numsMAX_PLAN_LENGTH\n\n****\n```\n[Task ID] 1\n[Name] Task 1\n[Goal] Complete task 1\n[Status] DOING\n[Milestones]\n- Milestone 1\n- Milestone 2\n[Prior Plan Criticism] Plan criticism for task 1\n[Action Status] Success\n[Action Info]\n- [Conclusion] Action conclusion for task 1\n- [Summary] Action summary for task 1\n```\nID",
            "code_start_line": 165,
            "code_end_line": 243,
            "parent": null,
            "have_return": true,
            "code_content": "def summarize_plan(plans:dict)->str:\n    \"\"\"\n    Generate a summarized plan based on provided plans.\n\n    Args:\n        plans (dict): The plans to provide.\n\n    Returns:\n        str: The string contains a summary of the plan.\n    \"\"\"\n    summary:list[list] = []\n    task_ids = []\n    detailed_info:dict[str,list] = {}\n    current_task_id = None\n    def recursive_summary(plan:dict,):\n        \"\"\"\n        Generate a summarized plan in a recursive process.\n\n        Args:\n            plan (dict): A dictionary of plans.\n\n        Returns:\n            None\n        \"\"\"\n        nonlocal summary\n        nonlocal current_task_id\n        plan_des = [\n            f'[Task ID] {plan[\"task_id\"]}',\n            f'[Name] {plan[\"name\"]}',\n            f'[Goal] {plan[\"goal\"]}',\n            f'[Status] {plan[\"exceute_status\"]}',\n        ]\n        if current_task_id is None and plan['exceute_status'] == 'DOING':\n            current_task_id = plan['task_id']\n            \n        if 'milestones' in plan and len(plan['milestones']) > 0:\n            plan_des.extend(['[Milestones]']+['- '+milestone for milestone in plan[\"milestones\"]])\n\n        \n        if 'action_list_summary' not in plan and 'prior_plan_criticism' in plan:\n            plan_des.append(f'[Prior Plan Criticism] {plan[\"prior_plan_criticism\"]}')\n        \n        if 'submit_result' in plan and 'args' in plan['submit_result']:\n            submission = plan['submit_result']['args']\n            plan_des.append(f'[Action Status] {\"Success\" if submission[\"result\"][\"success\"] else \"Fail\"}')\n            \n            # possible too long part\n            action_des = [\n                '[Action Info]',\n                f\"- [Conclusion] {submission['result']['conclusion']}\"\n            ]\n            if 'action_list_summary' in plan:\n                action_des.append(f'- [Summary] {plan[\"action_list_summary\"]}')  \n            if submission['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']:\n                if submission['suggestions_for_latter_subtasks_plan']['reason'] != '':\n                    action_des.append(f\"- [Proposal] {submission['suggestions_for_latter_subtasks_plan']['reason']}\")\n            detailed_info[plan['task_id']] = action_des\n        \n        task_ids.append(plan['task_id'])\n        summary.append(plan_des)\n        if \"subtask\" in plan:\n            for subtask in plan[\"subtask\"]:\n                recursive_summary(subtask)\n    recursive_summary(plans)\n    total_tokens = sum([get_token_nums('\\n'.join(plan)) for plan in summary])\n    if current_task_id is None:\n        current_task_id = task_ids[-1]\n    for task_id,plan in zip(task_ids[::-1],summary[::-1]):\n        if task_id <= current_task_id and task_id in detailed_info:\n            if (tokens:=get_token_nums('\\n'.join(detailed_info[task_id]))) > MAX_PLAN_LENGTH-total_tokens:\n                continue\n            else:\n                total_tokens += tokens\n                plan.extend(detailed_info[task_id])\n    # logger.typewriter_log(f'Plan summarized {total_tokens}',Fore.YELLOW)\n    ret = []\n    for plan in summary:\n        ret.append('\\n'.join(plan))\n    return '\\n'.join(ret)",
            "name_column": 4
        },
        "generate_func_args": {
            "type": "FunctionDef",
            "name": "generate_func_args",
            "md_content": "**generate_func_args**\n\nargsblack_list\n\n\n- args\n- black_listargs\n\n\n- str\n\n\n1. retargs_len\n2. argskv\n3. kblack_listv\"`wrapped`\"\n4. clip_textvSINGLE_ACTION_MAX_LENGTH-args_lenclip_end\n5. vSINGLE_ACTION_MAX_LENGTH-args_lenkvretvv\n6. args_len\n7. vSINGLE_ACTION_MAX_LENGTH-args_lenkvretvv\n8. args_len\n9. ret\n\n****\n- args\n- black_list\n- \n\n****\n```\narg1=\"value1\", arg2=\"value2\", arg3=\"value3\"...\n```",
            "code_start_line": 25,
            "code_end_line": 49,
            "parent": "summarize_action",
            "have_return": true,
            "code_content": "    def generate_func_args(args:dict,black_list=[])->str:\n        \"\"\"\n        Generate function arguments in the form of strings.\n\n        Args:\n            args (dict): A dictionary of arguments.\n            black_list (list): A list of forbidden or restricted words or keys in the args dictionary.\n\n        Returns:\n            str: A string that summarizes the function arguments.\n        \"\"\"\n        ret = ''\n        args_len = 0\n        for k,v in args.items():\n            if k in black_list:\n                v = '`wrapped`'\n            v_str,v_len = clip_text(str(v),SINGLE_ACTION_MAX_LENGTH-args_len,clip_end=True)\n            if v_len < SINGLE_ACTION_MAX_LENGTH-args_len:\n                ret += f'{k}=\"{v_str}\",' if isinstance(v,str) else f'{k}={v_str},'\n                args_len += v_len\n            else:\n                ret += f'{k}=\"{v_str}...\",' if isinstance(v,str) else f'{k}={v_str}...,'\n                args_len += SINGLE_ACTION_MAX_LENGTH-args_len\n                \n        return ret[:-1] # remove last comma\n",
            "name_column": 8
        },
        "recursive_summary": {
            "type": "FunctionDef",
            "name": "recursive_summary",
            "md_content": "**recursive_summary**: \n\n\n\nsummarytask_idsdetailed_infoIDIDtask_idssummary\n\nID\n\n****: \n- \n- task_idnamegoalexceute_status\n- \"subtask\"\n- argsargsresultsuggestions_for_latter_subtasks_plan\n- ",
            "code_start_line": 179,
            "code_end_line": 227,
            "parent": "summarize_plan",
            "have_return": false,
            "code_content": "    def recursive_summary(plan:dict,):\n        \"\"\"\n        Generate a summarized plan in a recursive process.\n\n        Args:\n            plan (dict): A dictionary of plans.\n\n        Returns:\n            None\n        \"\"\"\n        nonlocal summary\n        nonlocal current_task_id\n        plan_des = [\n            f'[Task ID] {plan[\"task_id\"]}',\n            f'[Name] {plan[\"name\"]}',\n            f'[Goal] {plan[\"goal\"]}',\n            f'[Status] {plan[\"exceute_status\"]}',\n        ]\n        if current_task_id is None and plan['exceute_status'] == 'DOING':\n            current_task_id = plan['task_id']\n            \n        if 'milestones' in plan and len(plan['milestones']) > 0:\n            plan_des.extend(['[Milestones]']+['- '+milestone for milestone in plan[\"milestones\"]])\n\n        \n        if 'action_list_summary' not in plan and 'prior_plan_criticism' in plan:\n            plan_des.append(f'[Prior Plan Criticism] {plan[\"prior_plan_criticism\"]}')\n        \n        if 'submit_result' in plan and 'args' in plan['submit_result']:\n            submission = plan['submit_result']['args']\n            plan_des.append(f'[Action Status] {\"Success\" if submission[\"result\"][\"success\"] else \"Fail\"}')\n            \n            # possible too long part\n            action_des = [\n                '[Action Info]',\n                f\"- [Conclusion] {submission['result']['conclusion']}\"\n            ]\n            if 'action_list_summary' in plan:\n                action_des.append(f'- [Summary] {plan[\"action_list_summary\"]}')  \n            if submission['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']:\n                if submission['suggestions_for_latter_subtasks_plan']['reason'] != '':\n                    action_des.append(f\"- [Proposal] {submission['suggestions_for_latter_subtasks_plan']['reason']}\")\n            detailed_info[plan['task_id']] = action_des\n        \n        task_ids.append(plan['task_id'])\n        summary.append(plan_des)\n        if \"subtask\" in plan:\n            for subtask in plan[\"subtask\"]:\n                recursive_summary(subtask)\n",
            "name_column": 8
        }
    },
    "XAgent/agent/utils.py": {
        "get_command": {
            "type": "FunctionDef",
            "name": "get_command",
            "md_content": "**get_command**\n\n`json.decoder.JSONDecodeError`JSON\"Error:\"\n\n\n- response_json (Dict)AI\n\n\n- tuple\n  - JSON'command''command''command''name''Error:'\n  - 'Error:'\n\n\n- json.decoder.JSONDecodeErrorJSON\n- Exception\n\n'command''command''command''name'\n\n`json.decoder.JSONDecodeError`JSON\n\n****\n- JSON\n- 'command''command'\n- 'command''name'\n\n****\n```\ncommand_name = \"search\"\narguments = {\"query\": \"apple\", \"limit\": 10}\n```",
            "code_start_line": 4,
            "code_end_line": 49,
            "parent": null,
            "have_return": true,
            "code_content": "def get_command(response_json: Dict):\n    \"\"\"\n    Parses the response and returns the command name and arguments.\n\n    This function will raise the exception `json.decoder.JSONDecodeError` if the response is not valid JSON.\n    Any other error that occurs is also caught and the function returns an \"Error:\" message with the exception message.\n\n    Args:\n        response_json (Dict): The response from the AI in dictionary format.\n\n    Returns:\n        tuple: The command name and arguments, or some error indication.\n               If the response json dictionary does not contain the 'command' key, or the value of\n               'command' is not a dictionary, or the 'command' dictionary does not contain the 'name' key,\n               returns a tuple where the first element is 'Error:' and the second element is a string explaining the problem.\n               If some error occurs, returns a tuple where the first element is 'Error:' and the second element is the str of the exception.\n\n    Raises:\n        json.decoder.JSONDecodeError: If the response is not valid JSON.\n        Exception: If any other error occurs.\n    \"\"\"\n    try:\n        if \"command\" not in response_json:\n            return \"Error:\", \"Missing 'command' object in JSON\"\n\n        if not isinstance(response_json, dict):\n            return \"Error:\", f\"'response_json' object is not dictionary {response_json}\"\n\n        command = response_json[\"command\"]\n        if not isinstance(command, dict):\n            return \"Error:\", \"'command' object is not a dictionary\"\n\n        if \"name\" not in command:\n            return \"Error:\", \"Missing 'name' field in 'command' object\"\n\n        command_name = command[\"name\"]\n\n        # Use an empty dictionary if 'args' field is not present in 'command' object\n        arguments = command.get(\"args\", {})\n\n        return command_name, arguments\n    except json.decoder.JSONDecodeError:\n        return \"Error:\", \"Invalid JSON\"\n    # All other errors, return \"Error: + error message\"\n    except Exception as e:\n        return \"Error:\", str(e)",
            "name_column": 4
        }
    },
    "XAgent/agent/plan_refine_agent/__init__.py": {},
    "XAgent/agent/plan_refine_agent/agent.py": {
        "PlanRefineAgent": {
            "type": "ClassDef",
            "name": "PlanRefineAgent",
            "md_content": "**PlanRefineAgent**PlanRefineAgentPlanGenerateAgent\n\n\n\n****\n- abilitiesAgentPlanRefineAgent\n\n****\n- parse\n\n  PlanGenerateAgent'generate'\n\n  \n  - placeholders\n  - arguments\n  - functions\n  - function_call\n  - stop\n  - additional_messages\n  - additional_insert_index\n  - *args\n  - **kwargs\n\n  \n  - object\n\n****\n\n****",
            "code_start_line": 6,
            "code_end_line": 60,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanRefineAgent(PlanGenerateAgent):\n    \"\"\"PlanRefineAgent is a subclass of PlanGenerateAgent and is involved in refining the plan.\n\n    This class utilizes the required ability of plan refinement to parse information \n    and generate a refined plan. It includes placeholders as the desired expressions.\n\n    Attributes:\n        abilities: A set of required abilities for the Agent. For PlanRefineAgent, it includes plan refinement.\n    \"\"\"\n    abilities = set([RequiredAbilities.plan_refinement])\n\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\" Parses information in order to refine the existing plan.\n\n        This method fills in placeholders with corresponding expressions, then prompts and \n        additional messages are processed and converged into final messages. Finally, the \n        'generate' method of PlanGenerateAgent class is then invoked on the final messages.\n\n        Args:\n            placeholders (dict, optional): Desired expressions to fill in partially completed text snippets.\n            arguments (dict, optional): Arguments to the function.\n            functions (optional): Functions to be carried out.\n            function_call (optional): Functional request from the user.\n            stop (optional): Stop parsing at some particular point.\n            additional_messages (List[Message], optional): Additional messages to be included in final message.\n            additional_insert_index (int, optional): Index in prompt messages where additional messages should be inserted.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            object: A refined plan generated from provided placeholders, arguments, functions, and messages.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages =prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        \n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse**\n\nPlanGenerateAgent'generate'\n\n\n- placeholders\n- arguments\n- functions\n- function_call\n- stop\n- additional_messagesList[Message]\n- additional_insert_indexint\n- *args\n- **kwargs\n\n\n- object\n\n****\n\n****",
            "code_start_line": 17,
            "code_end_line": 60,
            "parent": "PlanRefineAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\" Parses information in order to refine the existing plan.\n\n        This method fills in placeholders with corresponding expressions, then prompts and \n        additional messages are processed and converged into final messages. Finally, the \n        'generate' method of PlanGenerateAgent class is then invoked on the final messages.\n\n        Args:\n            placeholders (dict, optional): Desired expressions to fill in partially completed text snippets.\n            arguments (dict, optional): Arguments to the function.\n            functions (optional): Functions to be carried out.\n            function_call (optional): Functional request from the user.\n            stop (optional): Stop parsing at some particular point.\n            additional_messages (List[Message], optional): Additional messages to be included in final message.\n            additional_insert_index (int, optional): Index in prompt messages where additional messages should be inserted.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            object: A refined plan generated from provided placeholders, arguments, functions, and messages.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages =prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        \n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 8
        }
    },
    "XAgent/agent/plan_refine_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher**\n\nexample_inputexample_system_promptexample_user_promptexample_inputexample_system_promptexample_user_prompt\n\n\n\n****\n\n****\n```\nRefine a plan for writing a Python-based calculator.\n\n\n```",
            "code_start_line": 72,
            "code_end_line": 83,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"Refine a plan for writing a Python-based calculator.\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt",
            "name_column": 4
        }
    },
    "XAgent/agent/tool_agent/__init__.py": {},
    "XAgent/agent/tool_agent/agent.py": {
        "ToolAgent": {
            "type": "ClassDef",
            "name": "ToolAgent",
            "md_content": "**ToolAgent**ToolAgentBaseAgent\n\n\n- abilitiesToolAgent`RequiredAbilities.tool_tree_search`\n\n\n\n**parse**`generate()`\n\n\n- placeholders\n- arguments\n- functions\n- function_call\n- stop\n- additional_messages\n- additional_insert_index\n- *args`generate()`\n- **kwargs`generate()`\n\n\n- tuple\n\n\n- AssertionError\n- Exception\n\n**message_to_tool_node**ToolNode\n\n\n- message\n\n\n- ToolNodeToolNode\n\n\n- `function_call`\n\n****\n\n****\n\n\n- Markdown\n- ",
            "code_start_line": 16,
            "code_end_line": 175,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolAgent(BaseAgent):\n    \"\"\"\n    This class is used to represent the ToolAgent object, which is inherited from the BaseAgent. It mainly focuses\n    on actions around the tool tree and its functions.\n\n    Attributes:\n        abilities (set): Set to store the abilities of the current ToolAgent. By default, it is set to \n        `RequiredAbilities.tool_tree_search`.\n    \"\"\"\n    abilities = set([RequiredAbilities.tool_tree_search])\n\n    @retry(stop=stop_after_attempt(CONFIG.max_retry_times),reraise=True)\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict=None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This function generates a message list and a token list based on the input parameters using the \n        `generate()` function, modifies it as per specific conditions, and returns it.\n        \n        Args:\n            placeholders (dict, optional): Dictionary object to store the placeholders and their mappings.\n            arguments (dict, optional): Dictionary object to store argument's details.\n            functions: List of permissible functions that can be inserted in the function fields for the `openai` type.\n            function_call: A dictionary representing the current function call being processed.\n            stop: The termination condition for the loop.\n            additional_messages (list, optional): List of additional messages to be appended to the existing message list.\n            additional_insert_index (int, optional): The index position to insert the additional messages.\n            *args: Variable length argument list for the parent class's `generate()` function.\n            **kwargs: Arbitrary keyword arguments for the parent class's `generate()` function.\n            \n        Returns:\n            tuple: A tuple containing a dictionary of the parsed message and a list of tokens.\n            \n        Raises:\n            AssertionError: If the specified function schema is not found in the list of possible functions.\n            Exception: If the validation of the tool's call arguments fails.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        messages = [message.raw() for message in messages]\n        \n        # Temporarily disable the arguments for openai\n        if self.config.default_request_type == 'openai':\n            arguments = None\n            functions = list(filter(lambda x: x['name'] not in ['subtask_submit','subtask_handle'],functions))\n            if CONFIG.enable_ask_human_for_help:\n                functions += [function_manager.get_function_schema('ask_human_for_help')]\n            messages[0]['content'] += '\\n--- Avaliable Tools ---\\nYou are allowed to use tools in the \"subtask_handle.tool_call\" function field.\\nRemember the \"subtask_handle.tool_call.tool_input\" field should always in JSON, as following described:\\n{}'.format(json.dumps(functions,indent=2))\n            \n            def change_tool_call_description(message:dict,reverse:bool=False):\n                des_pairs = [('Use tools to handle the subtask',\n                              'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                             ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                              '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                             ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                              'After decide the action, call functions to apply action.')]\n                \n                for pair in des_pairs:\n                    message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                    \n                return message\n            \n            messages[0] = change_tool_call_description(messages[0])\n            functions = [function_manager.get_function_schema('subtask_submit'),\n                         function_manager.get_function_schema('subtask_handle')]\n\n        message,tokens = self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )\n\n        function_call_args:dict = message['function_call']['arguments']\n\n        # for tool_call, we need to validate the tool_call arguments if exising\n        if self.config.default_request_type == 'openai' and 'tool_call' in function_call_args:\n            tool_schema = function_manager.get_function_schema(function_call_args['tool_call'][\"tool_name\"])\n            assert tool_schema is not None, f\"Function {function_call_args['tool_call']['tool_name']} not found! Poential Schema Validation Error!\"\n            \n            tool_call_args = function_call_args['tool_call']['tool_input'] if 'tool_input' in function_call_args['tool_call'] else ''\n            \n            def validate():\n                nonlocal tool_schema,tool_call_args\n                if isinstance(tool_call_args,str):\n                    tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n                jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n            \n            try:\n                validate()\n            except Exception as e:  \n                messages[0] = change_tool_call_description(messages[0],reverse=True)\n                tool_call_args = objgenerator.dynamic_json_fixes(\n                    broken_json=tool_call_args,\n                    function_schema=tool_schema,\n                    messages=messages,\n                    error_message=str(e))[\"choices\"][0][\"message\"][\"function_call\"][\"arguments\"]\n                validate()\n            \n            function_call_args['tool_call']['tool_input'] = tool_call_args\n            \n            message['function_call'] = function_call_args.pop('tool_call')\n            message['function_call']['name'] = message['function_call'].pop('tool_name')\n            message['function_call']['arguments'] = message['function_call'].pop('tool_input')\n            message['arguments'] = function_call_args\n                \n        return message,tokens\n    \n    def message_to_tool_node(self,message) -> ToolNode:\n        \"\"\"\n        This method converts a given message dictionary to a ToolNode object.\n        \n        Args:\n            message (dict): Dictionary of message data containing content, function call and arguments.\n\n        Returns:\n            ToolNode: A ToolNode object generated from the provided message.\n            \n        Warning:\n            If the `function_call` field is missing in the input message, a warning message will be logged. \n        \"\"\"\n        \n        # assume message format\n        # {\n        #   \"content\": \"The content is useless\",\n        #   \"function_call\": {\n        #       \"name\": \"xxx\",\n        #       \"arguments\": \"xxx\"\n        #  },\n        #  \"arguments\": {\n        #      \"xxx\": \"xxx\",\n        #      \"xxx\": \"xxx\"   \n        #  },\n        # }\n        \n        new_node = ToolNode()\n        if \"content\" in message.keys():\n            print(message[\"content\"])\n            new_node.data[\"content\"] = message[\"content\"]\n        if 'arguments' in message.keys():\n            new_node.data['thoughts']['properties'] = message[\"arguments\"]\n        if \"function_call\" in message.keys():\n            new_node.data[\"command\"][\"properties\"][\"name\"] = message[\"function_call\"][\"name\"]\n            new_node.data[\"command\"][\"properties\"][\"args\"] = message[\"function_call\"][\"arguments\"]\n        else:\n            logger.typewriter_log(\"message_to_tool_node warning: no function_call in message\",Fore.RED)\n\n        return new_node",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse**`generate()`\n\n\n- placeholders\n- arguments\n- functions`openai`\n- function_call\n- stop\n- additional_messages\n- additional_insert_index\n- *args`generate()`\n- **kwargs`generate()`\n\n\n\n`fill_in_placeholders()``openai`argumentsNone`generate()`\n\n`openai``tool_call`\n\n****\n- \n- `openai`\n\n****\n```\n{\n  \"message\": {\n    \"content\": \"\",\n    \"role\": \"system\",\n    \"type\": \"text\"\n  },\n  \"tokens\": [\n    \"\",\n    \"\",\n    \"\",\n    \"\"\n  ]\n}\n```",
            "code_start_line": 28,
            "code_end_line": 134,
            "parent": "ToolAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict=None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This function generates a message list and a token list based on the input parameters using the \n        `generate()` function, modifies it as per specific conditions, and returns it.\n        \n        Args:\n            placeholders (dict, optional): Dictionary object to store the placeholders and their mappings.\n            arguments (dict, optional): Dictionary object to store argument's details.\n            functions: List of permissible functions that can be inserted in the function fields for the `openai` type.\n            function_call: A dictionary representing the current function call being processed.\n            stop: The termination condition for the loop.\n            additional_messages (list, optional): List of additional messages to be appended to the existing message list.\n            additional_insert_index (int, optional): The index position to insert the additional messages.\n            *args: Variable length argument list for the parent class's `generate()` function.\n            **kwargs: Arbitrary keyword arguments for the parent class's `generate()` function.\n            \n        Returns:\n            tuple: A tuple containing a dictionary of the parsed message and a list of tokens.\n            \n        Raises:\n            AssertionError: If the specified function schema is not found in the list of possible functions.\n            Exception: If the validation of the tool's call arguments fails.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        messages = [message.raw() for message in messages]\n        \n        # Temporarily disable the arguments for openai\n        if self.config.default_request_type == 'openai':\n            arguments = None\n            functions = list(filter(lambda x: x['name'] not in ['subtask_submit','subtask_handle'],functions))\n            if CONFIG.enable_ask_human_for_help:\n                functions += [function_manager.get_function_schema('ask_human_for_help')]\n            messages[0]['content'] += '\\n--- Avaliable Tools ---\\nYou are allowed to use tools in the \"subtask_handle.tool_call\" function field.\\nRemember the \"subtask_handle.tool_call.tool_input\" field should always in JSON, as following described:\\n{}'.format(json.dumps(functions,indent=2))\n            \n            def change_tool_call_description(message:dict,reverse:bool=False):\n                des_pairs = [('Use tools to handle the subtask',\n                              'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                             ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                              '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                             ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                              'After decide the action, call functions to apply action.')]\n                \n                for pair in des_pairs:\n                    message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                    \n                return message\n            \n            messages[0] = change_tool_call_description(messages[0])\n            functions = [function_manager.get_function_schema('subtask_submit'),\n                         function_manager.get_function_schema('subtask_handle')]\n\n        message,tokens = self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )\n\n        function_call_args:dict = message['function_call']['arguments']\n\n        # for tool_call, we need to validate the tool_call arguments if exising\n        if self.config.default_request_type == 'openai' and 'tool_call' in function_call_args:\n            tool_schema = function_manager.get_function_schema(function_call_args['tool_call'][\"tool_name\"])\n            assert tool_schema is not None, f\"Function {function_call_args['tool_call']['tool_name']} not found! Poential Schema Validation Error!\"\n            \n            tool_call_args = function_call_args['tool_call']['tool_input'] if 'tool_input' in function_call_args['tool_call'] else ''\n            \n            def validate():\n                nonlocal tool_schema,tool_call_args\n                if isinstance(tool_call_args,str):\n                    tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n                jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n            \n            try:\n                validate()\n            except Exception as e:  \n                messages[0] = change_tool_call_description(messages[0],reverse=True)\n                tool_call_args = objgenerator.dynamic_json_fixes(\n                    broken_json=tool_call_args,\n                    function_schema=tool_schema,\n                    messages=messages,\n                    error_message=str(e))[\"choices\"][0][\"message\"][\"function_call\"][\"arguments\"]\n                validate()\n            \n            function_call_args['tool_call']['tool_input'] = tool_call_args\n            \n            message['function_call'] = function_call_args.pop('tool_call')\n            message['function_call']['name'] = message['function_call'].pop('tool_name')\n            message['function_call']['arguments'] = message['function_call'].pop('tool_input')\n            message['arguments'] = function_call_args\n                \n        return message,tokens\n",
            "name_column": 8
        },
        "message_to_tool_node": {
            "type": "FunctionDef",
            "name": "message_to_tool_node",
            "md_content": "**message_to_tool_node**ToolNode\n\nToolNodeToolNodenew_node\"content\"\"arguments\"\"function_call\"\"content\"new_nodedata[\"content\"]\"arguments\"new_nodedata['thoughts']['properties']\"function_call\"\"name\"new_nodedata[\"command\"][\"properties\"][\"name\"]\"arguments\"new_nodedata[\"command\"][\"properties\"][\"args\"]\"function_call\"\n\n****\n- \"content\"ToolNode\n- \"function_call\"\n\n****\n```\n{\n  \"content\": \"The content is useless\",\n  \"function_call\": {\n    \"name\": \"xxx\",\n    \"arguments\": \"xxx\"\n  },\n  \"arguments\": {\n    \"xxx\": \"xxx\",\n    \"xxx\": \"xxx\"\n  }\n}\n```\nToolNodedata\n```\n{\n  \"content\": \"The content is useless\",\n  \"thoughts\": {\n    \"properties\": {\n      \"xxx\": \"xxx\",\n      \"xxx\": \"xxx\"\n    }\n  },\n  \"command\": {\n    \"properties\": {\n      \"name\": \"xxx\",\n      \"args\": \"xxx\"\n    }\n  }\n}\n```",
            "code_start_line": 136,
            "code_end_line": 175,
            "parent": "ToolAgent",
            "have_return": true,
            "code_content": "    def message_to_tool_node(self,message) -> ToolNode:\n        \"\"\"\n        This method converts a given message dictionary to a ToolNode object.\n        \n        Args:\n            message (dict): Dictionary of message data containing content, function call and arguments.\n\n        Returns:\n            ToolNode: A ToolNode object generated from the provided message.\n            \n        Warning:\n            If the `function_call` field is missing in the input message, a warning message will be logged. \n        \"\"\"\n        \n        # assume message format\n        # {\n        #   \"content\": \"The content is useless\",\n        #   \"function_call\": {\n        #       \"name\": \"xxx\",\n        #       \"arguments\": \"xxx\"\n        #  },\n        #  \"arguments\": {\n        #      \"xxx\": \"xxx\",\n        #      \"xxx\": \"xxx\"   \n        #  },\n        # }\n        \n        new_node = ToolNode()\n        if \"content\" in message.keys():\n            print(message[\"content\"])\n            new_node.data[\"content\"] = message[\"content\"]\n        if 'arguments' in message.keys():\n            new_node.data['thoughts']['properties'] = message[\"arguments\"]\n        if \"function_call\" in message.keys():\n            new_node.data[\"command\"][\"properties\"][\"name\"] = message[\"function_call\"][\"name\"]\n            new_node.data[\"command\"][\"properties\"][\"args\"] = message[\"function_call\"][\"arguments\"]\n        else:\n            logger.typewriter_log(\"message_to_tool_node warning: no function_call in message\",Fore.RED)\n\n        return new_node",
            "name_column": 8
        },
        "change_tool_call_description": {
            "type": "FunctionDef",
            "name": "change_tool_call_description",
            "md_content": "**change_tool_call_description**\n\nmessagereversedes_pairsdes_pairsmessagereverseTruemessage\n\n****\n\n****message{'content': 'Use tools to handle the subtask'}reverseFalse{'content': 'Use \"subtask_handle\" to make a normal tool call to handle the subtask'}",
            "code_start_line": 75,
            "code_end_line": 86,
            "parent": null,
            "have_return": true,
            "code_content": "            def change_tool_call_description(message:dict,reverse:bool=False):\n                des_pairs = [('Use tools to handle the subtask',\n                              'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                             ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                              '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                             ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                              'After decide the action, call functions to apply action.')]\n                \n                for pair in des_pairs:\n                    message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                    \n                return message\n",
            "name_column": 16
        },
        "validate": {
            "type": "FunctionDef",
            "name": "validate",
            "md_content": "**validate**\n\ntool_schematool_call_argstool_call_argsjsonschematool_call_argstool_schema['parameters']\n\n\n\n****tool_schematool_call_args",
            "code_start_line": 110,
            "code_end_line": 114,
            "parent": null,
            "have_return": false,
            "code_content": "            def validate():\n                nonlocal tool_schema,tool_call_args\n                if isinstance(tool_call_args,str):\n                    tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n                jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n",
            "name_column": 16
        }
    },
    "XAgent/agent/tool_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher**\n\n\n\n\nexample_inputexample_system_promptexample_user_prompt\n\n\n\n\n\nexample_input = \"\"\"{\\n  \"name\": \"Finding Feasible Examples\",\\n  \"goal\": \"Find 10 examples that can reach the target number 24 in the 24-points game.\",\\n  \"handler\": \"subtask 1\",\\n  \"tool_budget\": 50,\\n  \"prior_plan_criticsim\": \"It may be difficult to come up with examples that are all feasible.\",\\n  \"milestones\": [\\n    \"Identifying appropriate combination of numbers\",\\n    \"Applying mathematical operations\",\\n    \"Verifying the result equals to target number\",\\n    \"Recording feasible examples\"\\n  ],\\n  \"expected_tools\": [\\n    {\\n      \"tool_name\": \"analyze_code\",\\n      \"reason\": \"To ensure all feasible examples meet the rules of the 24-points game\"\\n    }\\n  ],\\n  \"exceute_status\": \"TODO\"\\n}\"\"\"\nexample_system_prompt = SYSTEM_PROMPT\nexample_user_prompt = USER_PROMPT\n\nexample_inputexample_system_promptexample_user_prompt",
            "code_start_line": 85,
            "code_end_line": 96,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"\"\"{\\n  \"name\": \"Finding Feasible Examples\",\\n  \"goal\": \"Find 10 examples that can reach the target number 24 in the 24-points game.\",\\n  \"handler\": \"subtask 1\",\\n  \"tool_budget\": 50,\\n  \"prior_plan_criticsim\": \"It may be difficult to come up with examples that are all feasible.\",\\n  \"milestones\": [\\n    \"Identifying appropriate combination of numbers\",\\n    \"Applying mathematical operations\",\\n    \"Verifying the result equals to target number\",\\n    \"Recording feasible examples\"\\n  ],\\n  \"expected_tools\": [\\n    {\\n      \"tool_name\": \"analyze_code\",\\n      \"reason\": \"To ensure all feasible examples meet the rules of the 24-points game\"\\n    }\\n  ],\\n  \"exceute_status\": \"TODO\"\\n}\"\"\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt\n",
            "name_column": 4
        }
    },
    "XAgent/agent/reflect_agent/__init__.py": {},
    "XAgent/agent/reflect_agent/agent.py": {
        "ReflectAgent": {
            "type": "ClassDef",
            "name": "ReflectAgent",
            "md_content": "**ReflectAgent**generate\n\n****\n- placeholdersagent\n- argumentsagent\n- functionsagent\n- function_callFunctionTypeagent\n- stop\n- additional_messages\n\n****agent\n\n**ReflectAgent**BaseAgent\n\n****\n- abilities\n\n****parseplaceholdersagentargumentsagentfunctionsagentfunction_callagentstopTrueadditional_messages\n\n****parse",
            "code_start_line": 6,
            "code_end_line": 53,
            "parent": null,
            "have_return": true,
            "code_content": "class ReflectAgent(BaseAgent):\n    \"\"\"This ReflectAgent class extends the BaseAgent class. It primarily has the ability of reflection \n    which means it can reflect upon the chat or dialogue and generate responses based on the messages\n    received.\n\n    Attributes:\n        abilities (set): Required abilities for the agent, namely reflection in this case. \n    \"\"\"\n\n    abilities = set([RequiredAbilities.reflection])\n\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        The function is used to parse various arguments and call the generate function with these parsed arguments.\n\n        Args:\n            placeholders (dict, optional): Placeholders for the agent's responses. \n            arguments(dict, optional): Argument to influence the response of the agent.\n            functions (functions, optional): Functions to guide the agent's response.\n            function_call (FunctionType, optional): Function called to generate agent's response. \n            stop (bool, optional): Flag to stop the induction of the response. \n            additional_messages (list, optional): Additional messages to be included in the response. \n\n        Returns:\n            object: Response generated by the agent. \n\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse**generate\n\n\n- placeholdersagent\n- argumentsagent\n- functionsagent\n- function_callFunctionTypeagent\n- stop\n- additional_messages\n\nplaceholdersadditional_messagesmessages\n\ngeneratemessagesargumentsfunctionsfunction_callstop\n\n****\n- placeholdersagent\n- argumentsagent\n- functionsagent\n- function_callagent\n- stop\n- additional_messages\n\n****\n\n\n- Markdown\n- ",
            "code_start_line": 17,
            "code_end_line": 53,
            "parent": "ReflectAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        The function is used to parse various arguments and call the generate function with these parsed arguments.\n\n        Args:\n            placeholders (dict, optional): Placeholders for the agent's responses. \n            arguments(dict, optional): Argument to influence the response of the agent.\n            functions (functions, optional): Functions to guide the agent's response.\n            function_call (FunctionType, optional): Function called to generate agent's response. \n            stop (bool, optional): Flag to stop the induction of the response. \n            additional_messages (list, optional): Additional messages to be included in the response. \n\n        Returns:\n            object: Response generated by the agent. \n\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 8
        }
    },
    "XAgent/agent/reflect_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher**\n\nexample_inputexample_system_promptexample_user_promptexample_inputexample_system_promptexample_user_prompt\n\nability_typeget_examples_for_dispatcher\n\nXAgent/agent/dispatcher.pyability_typeplan_generate_agentplan_refine_agenttool_agentreflect_agentget_examples_for_dispatcher\n\nXAgent/agent/plan_generate_agent/prompt.pyget_examples_for_dispatcher\"Generate a plan for writing a Python-based calculator.\"SYSTEM_PROMPTUSER_PROMPT\n\nXAgent/agent/plan_refine_agent/prompt.pyget_examples_for_dispatcher\"Refine a plan for writing a Python-based calculator.\"SYSTEM_PROMPTUSER_PROMPT\n\nXAgent/agent/tool_agent/prompt.pyget_examples_for_dispatcherJSONSYSTEM_PROMPTUSER_PROMPT\n\n****\n\n****\nReflect on the previous actions and give the posterior knowledge\nSYSTEM_PROMPT\nUSER_PROMPT",
            "code_start_line": 32,
            "code_end_line": 43,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"Reflect on the previous actions and give the posterior knowledge\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt",
            "name_column": 4
        }
    },
    "XAgent/agent/dispatcher_agent/__init__.py": {},
    "XAgent/agent/dispatcher_agent/agent.py": {
        "DispatcherAgent": {
            "type": "ClassDef",
            "name": "DispatcherAgent",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 222,
            "parent": null,
            "have_return": true,
            "code_content": "class DispatcherAgent(BaseAgent):\n    \"\"\"\n    A subclass of BaseAgent whose primary function is to help dispatch tasks to \n    different agent handlers based on the task requirements.\n\n    Attributes:\n    ------------\n    config : object\n        The configuration settings for the agent.\n    prompt_messages : List[Message]\n        The list of prompt messages for the agent to dispatch.\n    \"\"\"\n    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Initialize a DispatcherAgent instance.\n\n        Args:\n        -------\n        config : object\n            The configuration settings for the agent.\n        prompt_messages : list, optional\n            The list of prompt messages for the agent to dispatch, defaults to None.\n            If not provided, default_prompt_messages is used instead.\n        \"\"\"\n        self.config = config\n        self.prompt_messages = (\n            self.default_prompt_messages if prompt_messages is None else prompt_messages\n        )\n\n    @property\n    def default_prompt_messages(self):\n        \"\"\"\n        Returns the default system prompt messages in the form of a list of Message objects.\n\n        Returns:\n        -----------\n        list[Message] : \n            A list containing the default prompt message.\n        \"\"\"\n        return [Message(role=\"system\", content=SYSTEM_PROMPT)]\n\n    def find_all_placeholders(self, prompt):\n        \"\"\"\n        Finds all placeholders within a prompt.\n\n        Args:\n        --------\n        prompt : str\n            The string within which placeholders are to be found.\n\n        Returns:\n        --------\n        list[str] : \n            A list of all placeholders found within the prompt.\n        \"\"\"\n        return re.findall(r\"{{(.*?)}}\", prompt)\n\n    def construct_input_messages(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        retrieved_procedure: str,\n    ):\n        \"\"\"\n        Constructs input messages by replacing placeholders in the prompt_messages \n        with provided data.\n\n        Args:\n        ---------\n        task : str\n            The task to be completed.\n        example_input : str\n            An example input for the task.\n        example_system_prompt : str\n            The example system prompt for the task.\n        example_user_prompt : str\n            The example user prompt for the task.\n        retrieved_procedure : str\n            The retrieved process for the task.\n\n        Returns:\n        ---------\n        list[Message] :\n            A list containing the constructed input messages with placeholders replaced with provided data.\n        \"\"\"\n        prompt_messages = copy.deepcopy(self.prompt_messages)\n        # TODO: Make it more robust. Here we assume only the first message is system prompt\n        #       and we only update the placeholders in the first message.\n        prompt_messages[0].content = (\n            prompt_messages[0]\n            .content.replace(\"{{example_system_prompt}}\", example_system_prompt)\n            .replace(\"{{example_user_prompt}}\", example_user_prompt)\n            .replace(\"{{retrieved_procedure}}\", retrieved_procedure)\n            .replace(\"{{task}}\", task)\n        )\n        return prompt_messages  # + [Message(role=\"user\", content=task)] \n\n    def extract_prompts_from_response(self, message):\n        \"\"\"\n        Extracts additional prompts from the dispatcher's response message.\n\n        Args:\n        --------\n        message : str \n           The response message from the dispatcher.\n\n        Returns:\n        ---------\n        str : \n            The additional prompt extracted from the message; if not found, \"\" is returned.\n\n        \"\"\"\n        try:\n            additional_prompt = re.findall(r\"ADDITIONAL USER PROMPT:?\\n```(.*)```\", message['content'], re.DOTALL)[0].strip()\n        except IndexError as e:\n            logger.error(\n                f\"Failed to extract prompts from the dispatcher's response:\\n{message['content']}\"\n            )\n            logger.error(\"Fallback to use the default prompts.\")\n            additional_prompt = \"\"\n        return additional_prompt\n\n    def retrieved_procedure(self, query: str) -> str:\n        # TODO: this function should be implemented thru tool server\n\n        \"\"\"\n        Retrieves a procedure relevant to the given query from an external site.\n\n        Args:\n        --------\n        query : str\n            The query to retrieve the relevant procedure.\n\n        Returns:\n        ---------\n        str : \n            The relevant procedure retrieved; if retrieval fails, the string 'None' is returned.\n        \"\"\"\n        \n        url = \"https://open-procedures.replit.app/search/\"\n        try:\n            import requests\n            import json\n\n            relevant_procedures = requests.get(url, params={'query': query}).json()[\n                \"procedures\"\n            ][0]\n        except:\n            # For someone, this failed for a super secure SSL reason.\n            # Since it's not strictly necessary, let's worry about that another day. Should probably log this somehow though.\n            relevant_procedures = \"None\"\n\n        return relevant_procedures\n\n    def parse(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        stop=None,\n        **args,\n    ) -> List[Message]:\n        # TODO: should we consider additional messages when generating prompt?\n        # currently the plan generation and refine agent are the same since we\n        # don't consider the additional messages when generating prompt.\n\n        \"\"\"\n        Parse the task and related data to generate prompt messages.\n\n        Args:\n        ---------\n        task : str\n            The task to be processed.\n        example_input : str\n            An example input related to the task.\n        example_system_prompt : str\n            An example system prompt related to the task.\n        example_user_prompt : str\n            An example user prompt related to the task.\n        stop : str, optional\n            The stopping criterion for message generation, defaults to None.\n\n        Returns:\n        ---------\n        Tuple[List[Message], List[str]] : \n            A tuple containing a list of prompt messages and tokens.\n        \"\"\"\n        message,tokens = self.generate(\n            messages=self.construct_input_messages(\n                task,\n                example_input,\n                example_system_prompt,\n                example_user_prompt,\n                \"\"  \n            ),\n            stop=stop,\n            **args,\n        )\n\n        additional_prompt = message['arguments']['additional_prompt']\n\n        prompt_messages = []\n        if additional_prompt != \"\":\n            example_user_prompt += \"\\n\\nADDITIONAL NOTES\\n\" + additional_prompt\n        prompt_messages.append(Message(role=\"system\", content=example_system_prompt))\n        prompt_messages.append(Message(role=\"user\", content=example_user_prompt))\n\n        return prompt_messages, tokens",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 39,
            "parent": "DispatcherAgent",
            "have_return": false,
            "code_content": "    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Initialize a DispatcherAgent instance.\n\n        Args:\n        -------\n        config : object\n            The configuration settings for the agent.\n        prompt_messages : list, optional\n            The list of prompt messages for the agent to dispatch, defaults to None.\n            If not provided, default_prompt_messages is used instead.\n        \"\"\"\n        self.config = config\n        self.prompt_messages = (\n            self.default_prompt_messages if prompt_messages is None else prompt_messages\n        )\n",
            "name_column": 8
        },
        "default_prompt_messages": {
            "type": "FunctionDef",
            "name": "default_prompt_messages",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 51,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def default_prompt_messages(self):\n        \"\"\"\n        Returns the default system prompt messages in the form of a list of Message objects.\n\n        Returns:\n        -----------\n        list[Message] : \n            A list containing the default prompt message.\n        \"\"\"\n        return [Message(role=\"system\", content=SYSTEM_PROMPT)]\n",
            "name_column": 8
        },
        "find_all_placeholders": {
            "type": "FunctionDef",
            "name": "find_all_placeholders",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 67,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def find_all_placeholders(self, prompt):\n        \"\"\"\n        Finds all placeholders within a prompt.\n\n        Args:\n        --------\n        prompt : str\n            The string within which placeholders are to be found.\n\n        Returns:\n        --------\n        list[str] : \n            A list of all placeholders found within the prompt.\n        \"\"\"\n        return re.findall(r\"{{(.*?)}}\", prompt)\n",
            "name_column": 8
        },
        "construct_input_messages": {
            "type": "FunctionDef",
            "name": "construct_input_messages",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 109,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def construct_input_messages(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        retrieved_procedure: str,\n    ):\n        \"\"\"\n        Constructs input messages by replacing placeholders in the prompt_messages \n        with provided data.\n\n        Args:\n        ---------\n        task : str\n            The task to be completed.\n        example_input : str\n            An example input for the task.\n        example_system_prompt : str\n            The example system prompt for the task.\n        example_user_prompt : str\n            The example user prompt for the task.\n        retrieved_procedure : str\n            The retrieved process for the task.\n\n        Returns:\n        ---------\n        list[Message] :\n            A list containing the constructed input messages with placeholders replaced with provided data.\n        \"\"\"\n        prompt_messages = copy.deepcopy(self.prompt_messages)\n        # TODO: Make it more robust. Here we assume only the first message is system prompt\n        #       and we only update the placeholders in the first message.\n        prompt_messages[0].content = (\n            prompt_messages[0]\n            .content.replace(\"{{example_system_prompt}}\", example_system_prompt)\n            .replace(\"{{example_user_prompt}}\", example_user_prompt)\n            .replace(\"{{retrieved_procedure}}\", retrieved_procedure)\n            .replace(\"{{task}}\", task)\n        )\n        return prompt_messages  # + [Message(role=\"user\", content=task)] \n",
            "name_column": 8
        },
        "extract_prompts_from_response": {
            "type": "FunctionDef",
            "name": "extract_prompts_from_response",
            "md_content": "",
            "code_start_line": 111,
            "code_end_line": 134,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def extract_prompts_from_response(self, message):\n        \"\"\"\n        Extracts additional prompts from the dispatcher's response message.\n\n        Args:\n        --------\n        message : str \n           The response message from the dispatcher.\n\n        Returns:\n        ---------\n        str : \n            The additional prompt extracted from the message; if not found, \"\" is returned.\n\n        \"\"\"\n        try:\n            additional_prompt = re.findall(r\"ADDITIONAL USER PROMPT:?\\n```(.*)```\", message['content'], re.DOTALL)[0].strip()\n        except IndexError as e:\n            logger.error(\n                f\"Failed to extract prompts from the dispatcher's response:\\n{message['content']}\"\n            )\n            logger.error(\"Fallback to use the default prompts.\")\n            additional_prompt = \"\"\n        return additional_prompt\n",
            "name_column": 8
        },
        "retrieved_procedure": {
            "type": "FunctionDef",
            "name": "retrieved_procedure",
            "md_content": "",
            "code_start_line": 136,
            "code_end_line": 166,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def retrieved_procedure(self, query: str) -> str:\n        # TODO: this function should be implemented thru tool server\n\n        \"\"\"\n        Retrieves a procedure relevant to the given query from an external site.\n\n        Args:\n        --------\n        query : str\n            The query to retrieve the relevant procedure.\n\n        Returns:\n        ---------\n        str : \n            The relevant procedure retrieved; if retrieval fails, the string 'None' is returned.\n        \"\"\"\n        \n        url = \"https://open-procedures.replit.app/search/\"\n        try:\n            import requests\n            import json\n\n            relevant_procedures = requests.get(url, params={'query': query}).json()[\n                \"procedures\"\n            ][0]\n        except:\n            # For someone, this failed for a super secure SSL reason.\n            # Since it's not strictly necessary, let's worry about that another day. Should probably log this somehow though.\n            relevant_procedures = \"None\"\n\n        return relevant_procedures\n",
            "name_column": 8
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "",
            "code_start_line": 168,
            "code_end_line": 222,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        stop=None,\n        **args,\n    ) -> List[Message]:\n        # TODO: should we consider additional messages when generating prompt?\n        # currently the plan generation and refine agent are the same since we\n        # don't consider the additional messages when generating prompt.\n\n        \"\"\"\n        Parse the task and related data to generate prompt messages.\n\n        Args:\n        ---------\n        task : str\n            The task to be processed.\n        example_input : str\n            An example input related to the task.\n        example_system_prompt : str\n            An example system prompt related to the task.\n        example_user_prompt : str\n            An example user prompt related to the task.\n        stop : str, optional\n            The stopping criterion for message generation, defaults to None.\n\n        Returns:\n        ---------\n        Tuple[List[Message], List[str]] : \n            A tuple containing a list of prompt messages and tokens.\n        \"\"\"\n        message,tokens = self.generate(\n            messages=self.construct_input_messages(\n                task,\n                example_input,\n                example_system_prompt,\n                example_user_prompt,\n                \"\"  \n            ),\n            stop=stop,\n            **args,\n        )\n\n        additional_prompt = message['arguments']['additional_prompt']\n\n        prompt_messages = []\n        if additional_prompt != \"\":\n            example_user_prompt += \"\\n\\nADDITIONAL NOTES\\n\" + additional_prompt\n        prompt_messages.append(Message(role=\"system\", content=example_system_prompt))\n        prompt_messages.append(Message(role=\"user\", content=example_user_prompt))\n\n        return prompt_messages, tokens",
            "name_column": 8
        }
    },
    "XAgent/agent/dispatcher_agent/prompt.py": {},
    "XAgent/agent/plan_generate_agent/__init__.py": {},
    "XAgent/agent/plan_generate_agent/agent.py": {
        "PlanGenerateAgent": {
            "type": "ClassDef",
            "name": "PlanGenerateAgent",
            "md_content": "**PlanGenerateAgent**: BaseAgent\n\n\n- abilities: Agent\n\n\n- parse: \n\n**parse**:\n\n\n:\n- placeholders (dict, optional): \n- arguments (dict, optional): \n- functions: \n- function_call: \n- stop: \n- additional_messages (List[Message], optional): \n- *args: \n- **kwargs: \n\n:\n\"generate\"\n\n****: \n- BaseAgentBaseAgent\n- abilitiesAgent\n- parse\n- parse\"generate\"\n\n****:\n```\n# PlanGenerateAgent\nagent = PlanGenerateAgent()\n\n# \nplan = agent.parse(\n    placeholders={\"placeholder1\": \"value1\", \"placeholder2\": \"value2\"},\n    arguments={\"arg1\": \"value1\", \"arg2\": \"value2\"},\n    functions=[function1, function2],\n    function_call=function_call,\n    stop=stop_condition,\n    additional_messages=[message1, message2]\n)\n\n# \nprint(plan)\n```\n\n****:\n- PlanGenerateAgentplaceholdersargumentsfunctionsfunction_callstopadditional_messages\n- parse",
            "code_start_line": 8,
            "code_end_line": 56,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanGenerateAgent(BaseAgent):\n    \"\"\"\n    This class is responsible for plan generation. It is a subclass of BaseAgent.\n\n    Attributes:\n        abilities: A set indicating the abilities required by this agent.\n    \"\"\"\n    abilities = set([RequiredAbilities.plan_generation])\n\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments: dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This method is used to parse placeholders, arguments, function calls, and additional messages \n        to generate a plan.\n\n        Args:\n            placeholders (dict, optional): A dictionary containing placeholders to fill in the messages.\n            arguments (dict, optional): A dictionary containing arguments to be used in the functions.\n            functions: The functions to be used during plan generation.\n            function_call: The object representing a function call.\n            stop: The condition to stop the plan generation process if specified.\n            additional_messages (List[Message], optional): A list of additional messages to be added to \n            the initial prompt messages.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            This method returns the result of the plan generated by the \"generate\" method.\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args, **kwargs\n        )",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse**\n\n\n- placeholders\n- arguments\n- functions\n- function_call\n- stop\n- additional_messages\n- *args\n- **kwargs\n\nfill_in_placeholdersgenerate\n\n****\n\n****",
            "code_start_line": 17,
            "code_end_line": 56,
            "parent": "PlanGenerateAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments: dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This method is used to parse placeholders, arguments, function calls, and additional messages \n        to generate a plan.\n\n        Args:\n            placeholders (dict, optional): A dictionary containing placeholders to fill in the messages.\n            arguments (dict, optional): A dictionary containing arguments to be used in the functions.\n            functions: The functions to be used during plan generation.\n            function_call: The object representing a function call.\n            stop: The condition to stop the plan generation process if specified.\n            additional_messages (List[Message], optional): A list of additional messages to be added to \n            the initial prompt messages.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            This method returns the result of the plan generated by the \"generate\" method.\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args, **kwargs\n        )",
            "name_column": 8
        }
    },
    "XAgent/agent/plan_generate_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher**\n\nexample_inputexample_system_promptexample_user_promptexample_inputexample_system_promptexample_user_prompt\n\n\n- XAgent/agent/dispatcher.py\n- XAgent/agent/plan_refine_agent/prompt.py\n- XAgent/agent/reflect_agent/prompt.py\n- XAgent/agent/tool_agent/prompt.py\n\nXAgent/agent/dispatcher.pyget_examples_for_dispatcherability_typeget_examples_for_dispatcher\n\nXAgent/agent/plan_refine_agent/prompt.pyget_examples_for_dispatcher\n\nXAgent/agent/reflect_agent/prompt.pyget_examples_for_dispatcher\n\nXAgent/agent/tool_agent/prompt.pyget_examples_for_dispatcher\n\n****\n- \n- \n\n****\n```\nexample_input = \"Generate a plan for writing a Python-based calculator.\"\nexample_system_prompt = SYSTEM_PROMPT\nexample_user_prompt = USER_PROMPT\n```",
            "code_start_line": 44,
            "code_end_line": 55,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"Generate a plan for writing a Python-based calculator.\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt",
            "name_column": 4
        }
    },
    "XAgent/workflow/working_memory.py": {
        "WorkingMemoryAgent": {
            "type": "ClassDef",
            "name": "WorkingMemoryAgent",
            "md_content": "**WorkingMemoryAgent**agent\n\nagentsubtask_handle_mappingexecute_process\n\n- subtask_handle_mappingid\n- execute_process\n\n****WorkingMemoryAgent\n\n\n- logger\n\n**get_working_memory_function**'chat_with_other_subtask'\n\n\n- 'chat_with_other_subtask'\n\n**register_task**subtask_handle_mappingid\n\n\n- terminal_plan\n\n**handle**'chat_with_other_subtask'\n\n\n- tool_name\n- tool_input\n\n\n- AssertionError'chat_with_other_subtask'\n\n****\n- WorkingMemoryAgentagent\n- register_task\n- handle'chat_with_other_subtask'\n\n****\n```\nWorking Memory: Register a new subtask=subtask_id Process length=finish_node.get_depth().\n```",
            "code_start_line": 6,
            "code_end_line": 78,
            "parent": null,
            "have_return": true,
            "code_content": "class WorkingMemoryAgent():\n    \"\"\"\n    A class used to represent an agent's working memory.\n\n    Attributes:\n        subtask_handle_mapping (dict): A dictionary to store the mapping of subtasks.\n        execute_process (list): A list to store the processes to be executed.\n\n    \"\"\"\n    def __init__(self, logger=None):\n        \"\"\"\n        The constructor for the WorkingMemoryAgent class.\n\n        Args:\n            logger (object): The logger object.\n        \"\"\"\n        self.logger = logger\n        self.subtask_handle_mapping = {}\n        self.execute_process: List[Dict] = []\n\n    @classmethod\n    def get_working_memory_function(cls):\n        \"\"\"\n        The method to get the 'chat_with_other_subtask' function schema from the function manager.\n\n        Returns:\n            list: A list that contains the function schema of 'chat_with_other_subtask'.\n\n        \"\"\"\n        chat_with_subtask_function = function_manager.get_function_schema('chat_with_other_subtask')\n        return [chat_with_subtask_function]\n\n    def register_task(self, terminal_plan):\n        \"\"\"\n        The method to register a task i.e., to add the terminal plan of the task to the execution process,\n        and to map the subtask id with the terminal plan in subtask_handle_mapping\n\n        Args:\n            terminal_plan (object): The terminal plan of the task.\n\n        \"\"\"\n        subtask_id = terminal_plan.get_subtask_id(to_str=True)\n        finish_node = terminal_plan.process_node\n\n        datapoint = {\n            \"plan\": terminal_plan,\n            \"task_id\": subtask_id,\n            \"qa_sequence\": [],\n        }\n\n        self.execute_process.append(datapoint)\n        self.subtask_handle_mapping[subtask_id] = datapoint\n\n        self.logger.typewriter_log(\n            \"Working Memory: \",\n            Fore.YELLOW,\n            f\"{Fore.YELLOW}Register a new subtask={Style.RESET_ALL}{subtask_id} {Fore.YELLOW}Process length={Style.RESET_ALL}{finish_node.get_depth()}.\"\n        )\n\n    def handle(self, tool_name, tool_input):\n        \"\"\"\n        The method to handle the tool named 'chat_with_other_subtask'\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (str): The input for the tool.\n\n        Raises:\n            AssertionError: If tool name is not 'chat_with_other_subtask'.\n\n        \"\"\"\n        assert tool_name == \"chat_with_other_subtask\"\n        self.logger.log(\"handle chat with other subtask\")",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**WorkingMemoryAgent\n\nloggerself.loggerself.subtask_handle_mappingself.execute_process\n\n****\n- WorkingMemoryAgent\n- loggerself.logger\n- self.subtask_handle_mapping\n- self.execute_process",
            "code_start_line": 15,
            "code_end_line": 24,
            "parent": "WorkingMemoryAgent",
            "have_return": false,
            "code_content": "    def __init__(self, logger=None):\n        \"\"\"\n        The constructor for the WorkingMemoryAgent class.\n\n        Args:\n            logger (object): The logger object.\n        \"\"\"\n        self.logger = logger\n        self.subtask_handle_mapping = {}\n        self.execute_process: List[Dict] = []\n",
            "name_column": 8
        },
        "get_working_memory_function": {
            "type": "FunctionDef",
            "name": "get_working_memory_function",
            "md_content": "**get_working_memory_function**'chat_with_other_subtask'\n\n'chat_with_other_subtask'\n\n****\nget_function_schema'chat_with_other_subtask''chat_with_other_subtask'\n\n****\n- 'chat_with_other_subtask'\n- 'chat_with_other_subtask'\n\n****'chat_with_other_subtask'\n```\n{\n    'name': 'chat_with_other_subtask',\n    'description': 'This function is used to chat with other subtasks.',\n    'parameters': [\n        {\n            'name': 'message',\n            'type': 'str',\n            'description': 'The message to be sent.'\n        }\n    ],\n    'return': {\n        'type': 'str',\n        'description': 'The response message.'\n    }\n}\n```\n\n```\n[{\n    'name': 'chat_with_other_subtask',\n    'description': 'This function is used to chat with other subtasks.',\n    'parameters': [\n        {\n            'name': 'message',\n            'type': 'str',\n            'description': 'The message to be sent.'\n        }\n    ],\n    'return': {\n        'type': 'str',\n        'description': 'The response message.'\n        }\n}]\n```",
            "code_start_line": 27,
            "code_end_line": 36,
            "parent": "WorkingMemoryAgent",
            "have_return": true,
            "code_content": "    def get_working_memory_function(cls):\n        \"\"\"\n        The method to get the 'chat_with_other_subtask' function schema from the function manager.\n\n        Returns:\n            list: A list that contains the function schema of 'chat_with_other_subtask'.\n\n        \"\"\"\n        chat_with_subtask_function = function_manager.get_function_schema('chat_with_other_subtask')\n        return [chat_with_subtask_function]\n",
            "name_column": 8
        },
        "register_task": {
            "type": "FunctionDef",
            "name": "register_task",
            "md_content": "**register_task**subtask_handle_mappingID\n\nterminal_plan\n\nIDfinish_node\n\ndatapoint\n- \"plan\"\n- \"task_id\"ID\n- \"qa_sequence\"\n\ndatapointexecute_processIDdatapointsubtask_handle_mapping\n\nlogger.typewriter_log\"Working Memory: Register a new subtask=xxx Process length=xxx.\"xxxIDfinish_node\n\n****\n- terminal_plan\n- execute_processsubtask_handle_mapping",
            "code_start_line": 38,
            "code_end_line": 63,
            "parent": "WorkingMemoryAgent",
            "have_return": false,
            "code_content": "    def register_task(self, terminal_plan):\n        \"\"\"\n        The method to register a task i.e., to add the terminal plan of the task to the execution process,\n        and to map the subtask id with the terminal plan in subtask_handle_mapping\n\n        Args:\n            terminal_plan (object): The terminal plan of the task.\n\n        \"\"\"\n        subtask_id = terminal_plan.get_subtask_id(to_str=True)\n        finish_node = terminal_plan.process_node\n\n        datapoint = {\n            \"plan\": terminal_plan,\n            \"task_id\": subtask_id,\n            \"qa_sequence\": [],\n        }\n\n        self.execute_process.append(datapoint)\n        self.subtask_handle_mapping[subtask_id] = datapoint\n\n        self.logger.typewriter_log(\n            \"Working Memory: \",\n            Fore.YELLOW,\n            f\"{Fore.YELLOW}Register a new subtask={Style.RESET_ALL}{subtask_id} {Fore.YELLOW}Process length={Style.RESET_ALL}{finish_node.get_depth()}.\"\n        )\n",
            "name_column": 8
        },
        "handle": {
            "type": "FunctionDef",
            "name": "handle",
            "md_content": "**handle**'chat_with_other_subtask'\n\ntool_nametool_inputtool_nametool_input\n\nasserttool_name\"chat_with_other_subtask\"AssertionError\n\nself.logger.log\"handle chat with other subtask\"\n\n****\n- handle\n- \"chat_with_other_subtask\"AssertionError",
            "code_start_line": 65,
            "code_end_line": 78,
            "parent": "WorkingMemoryAgent",
            "have_return": false,
            "code_content": "    def handle(self, tool_name, tool_input):\n        \"\"\"\n        The method to handle the tool named 'chat_with_other_subtask'\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (str): The input for the tool.\n\n        Raises:\n            AssertionError: If tool name is not 'chat_with_other_subtask'.\n\n        \"\"\"\n        assert tool_name == \"chat_with_other_subtask\"\n        self.logger.log(\"handle chat with other subtask\")",
            "name_column": 8
        }
    },
    "XAgent/workflow/reflection.py": {
        "get_posterior_knowledge": {
            "type": "FunctionDef",
            "name": "get_posterior_knowledge",
            "md_content": "**get_posterior_knowledge**\n\n\n- all_plan (Plan): \n- terminal_plan (Plan): \n- finish_node (ToolNode): \n- tool_functions_description_list (List[dict]): \n- config (object): \n- agent_dispatcher (AgentDispatcher): \n\n\n\nagent_dispatcherdispatchRequiredAbilities.reflection\"Reflect on the previous actions and give the posterior knowledge\"agent\n\nall_planterminal_planJSONconfig.enable_summaryTrueterminal_plansummarize_planfinish_node.processsummarize_actionall_plansummarize_planJSON\n\nagentparseplaceholdersfunction_manager.get_function_schema('generate_posterior_knowledge')['parameters']placeholdersagentnew_message\n\nnew_messageargumentsdata\n\n****\n- agent_dispatcherfunction_manager\n- \n\n****\n```python\n{\n    \"summary\": \"This is a summary of the action list.\",\n    \"reflection_of_plan\": \"This is a reflection of the plan.\",\n    \"reflection_of_tool\": \"This is a reflection of the tool.\"\n}\n```",
            "code_start_line": 12,
            "code_end_line": 62,
            "parent": null,
            "have_return": true,
            "code_content": "def get_posterior_knowledge(all_plan: Plan,\n                            terminal_plan: Plan,\n                            finish_node: ToolNode,\n                            tool_functions_description_list: List[dict],\n                            config,\n                            agent_dispatcher):\n    \"\"\"\n    Reflects on the previous actions and generates the posterior knowledge.\n\n    Args:\n        all_plan (Plan): The complete plan of actions.\n        terminal_plan (Plan): The plan of actions at the terminal.\n        finish_node (ToolNode): The node that represents the finishing tool.\n        tool_functions_description_list (List[dict]): A list of dictionaries that describe tool functions.\n        config (object): The configuration object with settings.\n        agent_dispatcher (AgentDispatcher): The agent dispatcher.\n\n    Returns:\n        dict: A dictionary with the generated posterior knowledge.\n\n    \"\"\"\n    agent = agent_dispatcher.dispatch(\n        RequiredAbilities.reflection,\n        \"Reflect on the previous actions and give the posterior knowledge\"\n    )\n    all_plan = all_plan.to_json()\n    terminal_plan = terminal_plan.to_json()\n    if config.enable_summary:\n        terminal_plan = summarize_plan(terminal_plan)\n        action_process = summarize_action(finish_node.process, terminal_plan)\n        all_plan = summarize_plan(all_plan)\n    else:\n        action_process = json.dumps(finish_node.process,indent=2,ensure_ascii=False)\n        all_plan = json.dumps(all_plan, indent=2, ensure_ascii=False)\n        terminal_plan = json.dumps(terminal_plan, indent=2, ensure_ascii=False)\n        \n    new_message,_ = agent.parse(\n        placeholders={\n            \"system\": {\n                \"all_plan\": all_plan,\n                \"terminal_plan\": terminal_plan,\n                \"tool_functions_description_list\": json.dumps(tool_functions_description_list, indent=2, ensure_ascii=False),\n                \"action_process\": action_process\n            }\n        },\n        arguments=function_manager.get_function_schema('generate_posterior_knowledge')['parameters']\n    )\n\n    data = json5.loads(new_message[\"arguments\"])\n\n    return data",
            "name_column": 4
        }
    },
    "XAgent/workflow/__init__.py": {},
    "XAgent/workflow/task_handler.py": {
        "TaskHandler": {
            "type": "ClassDef",
            "name": "TaskHandler",
            "md_content": "**TaskHandler**TaskHandlerXAgent\n\n\n- config\n- function_list\n- tool_functions_description_list\n- query\n- tool_call_count\n- plan_agentPlanAgent\n- interactionXAgentInteraction\n\n\n- \\_\\_init\\_\\_(self, xagent_core: XAgentCoreComponents, xagent_param: XAgentParam)TaskHandler\n- outer_loop(self)\n- inner_loop(self, plan: Plan)\n- posterior_process(self, terminal_plan: Plan)\n\n****XAgent\n\n****\n```\n# TaskHandler\ntask_handler = TaskHandler(xagent_core, xagent_param)\n\n# \ntask_handler.outer_loop()\n\n# \ntask_handler.inner_loop(plan)\n\n# \ntask_handler.posterior_process(terminal_plan)\n```",
            "code_start_line": 17,
            "code_end_line": 300,
            "parent": null,
            "have_return": true,
            "code_content": "class TaskHandler():\n    \"\"\"\n    Main class for handling tasks within the XAgent system.\n\n    Attributes:\n        config: The configuration settings for the task handler.\n        function_list: List of available functions for the current task.\n        tool_functions_description_list: List of available tool functions description for the current task.\n        query: The current task of this agent.\n        tool_call_count: Variable for tracking the count of tool calls.\n        plan_agent: Instance of PlanAgent class which is used for generating and handling plan for the current task.\n        interaction: Instance of XAgentInteraction class for interacting with outer world.\n    \"\"\"\n\n    def __init__(self,\n                 xagent_core: XAgentCoreComponents,\n                 xagent_param: XAgentParam):\n        \"\"\"\n        Initializes TaskHandler with the provided input parameters.\n\n        Args:\n            xaagent_core (XAgentCoreComponents): Instance of XAgentCoreComponents class.\n            xaagent_param (XAgentParam): Instance of XAgentParam class.\n        \"\"\"\n        self.xagent_core = xagent_core\n        self.xagent_param = xagent_param\n        self.config = xagent_param.config\n        self.function_list = self.xagent_core.function_list\n        self.tool_functions_description_list = self.xagent_core.tool_functions_description_list\n        self.query = self.xagent_param.query\n        self.tool_call_count = 0\n        self.plan_agent = PlanAgent(\n            config=self.config,\n            query=self.query,\n            avaliable_tools_description_list=self.tool_functions_description_list,\n        )\n        self.logger = self.xagent_core.logger\n        # self.avaliable_tools_description_list = tool_functions_description_list\n\n        self.interaction = self.xagent_core.interaction\n        self.recorder = self.xagent_core.recorder\n        self.agent_dispatcher = self.xagent_core.agent_dispatcher\n        self.function_list = self.xagent_core.function_list\n        self.function_handler = self.xagent_core.function_handler\n        self.toolserver_interface = self.xagent_core.toolserver_interface\n        self.working_memory_agent = self.xagent_core.working_memory_agent\n        self.now_dealing_task = None\n\n    def outer_loop(self):\n        \"\"\"\n        Executes the main sequence of tasks in the outer loop.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger.typewriter_log(\n                        \"goal: \",\n                        Fore.YELLOW,\n                        f\"{new_intput}\",\n                    )\n                    self.now_dealing_task.data.goal = new_intput\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n\n            search_method = self.inner_loop(self.now_dealing_task)\n\n            self.now_dealing_task.process_node = search_method.get_finish_node()\n\n            self.posterior_process(self.now_dealing_task)\n\n            self.working_memory_agent.register_task(self.now_dealing_task)\n\n            self.xagent_core.print_task_save_items(self.now_dealing_task.data)\n\n            refinement_result = {\n                \"name\": self.now_dealing_task.data.name,\n                \"goal\": self.now_dealing_task.data.goal,\n                \"prior_plan_criticism\": self.now_dealing_task.data.prior_plan_criticism,\n                \"posterior_plan_reflection\": self.now_dealing_task.data.posterior_plan_reflection,\n                \"milestones\": self.now_dealing_task.data.milestones,\n                # \"expected_tools\": self.now_dealing_task.data.expected_tools,\n                \"tool_reflection\": self.now_dealing_task.data.tool_reflection,\n                \"action_list_summary\": self.now_dealing_task.data.action_list_summary,\n                \"task_id\": task_id,\n            }\n\n            self.interaction.insert_data(\n                data=refinement_result, status=StatusEnum.REFINEMENT, current=task_id)\n            if search_method.need_for_plan_refine:\n                self.plan_agent.plan_refine_mode(\n                    self.now_dealing_task, self.toolserver_interface, self.agent_dispatcher)\n            else:\n                self.logger.typewriter_log(\n                    \"subtask submitted as no need to refine the plan, continue\",\n                    Fore.BLUE,\n                )\n\n            self.now_dealing_task = Plan.pop_next_subtask(\n                self.now_dealing_task)\n\n            if self.now_dealing_task is None:\n                self.interaction.insert_data(\n                    data=[], status=StatusEnum.FINISHED, current=\"\")\n            else:\n                current_task_id = self.now_dealing_task.get_subtask_id(\n                    to_str=True)\n                remaining_subtask = Plan.get_remaining_subtask(\n                    self.now_dealing_task)\n                subtask_list = []\n                for todo_plan in remaining_subtask:\n                    raw_data = json.loads(todo_plan.data.raw)\n                    raw_data[\"task_id\"] = todo_plan.get_subtask_id(to_str=True)\n                    raw_data[\"inner\"] = []\n                    raw_data[\"node_id\"] = uuid.uuid4().hex\n                    subtask_list.append(raw_data)\n\n                self.interaction.insert_data(\n                    data=subtask_list, status=StatusEnum.SUBTASK, current=current_task_id)\n\n        self.logger.typewriter_log(\"ALL Tasks Done\", Fore.GREEN)\n        return\n\n    def inner_loop(self, plan: Plan, ):\n        \"\"\"\n        Generates search plan and process it for the current task.\n\n        Args:\n            plan (Plan): The plan to be processed.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            ReACTChainSearch: Instance of the search plan.\n        \"\"\"\n        task_ids_str = plan.get_subtask_id(to_str=True)\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Performing Task {task_ids_str} ({plan.data.name}): Begin -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n        self.xagent_core.print_task_save_items(plan.data)\n\n        agent = self.agent_dispatcher.dispatch(\n            RequiredAbilities.tool_tree_search,\n            json.dumps(plan.data.to_json(), indent=2, ensure_ascii=False),\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        plan.data.status = TaskStatusCode.DOING\n\n        if self.config.rapidapi_retrieve_tool_count > 0:\n            retrieve_string = summarize_plan(plan.to_json())\n            rapidapi_tool_names, rapidapi_tool_jsons = self.toolserver_interface.retrieve_rapidapi_tools(\n                retrieve_string, top_k=self.config.rapidapi_retrieve_tool_count)\n            if rapidapi_tool_names is not None:\n                self.function_handler.change_subtask_handle_function_enum(\n                    self.function_handler.tool_names + rapidapi_tool_names)\n                self.function_handler.avaliable_tools_description_list += rapidapi_tool_jsons\n            else:\n                print(\"bug: no rapidapi tool retrieved, need to fix here\")\n\n        search_method = ReACTChainSearch(\n            xagent_core_components=self.xagent_core,)\n\n        arguments = function_manager.get_function_schema('action_reasoning')[\n            'parameters']\n        search_method.run(config=self.config,\n                          agent=agent,\n                          arguments=arguments,\n                          functions=self.function_handler.intrinsic_tools(\n                              self.config.enable_ask_human_for_help),\n                          task_id=task_ids_str,\n                          now_dealing_task=self.now_dealing_task,\n                          plan_agent=self.plan_agent)\n\n        if search_method.status == SearchMethodStatusCode.SUCCESS:\n            plan.data.status = TaskStatusCode.SUCCESS\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Solved -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n        elif search_method.status == SearchMethodStatusCode.FAIL:\n            plan.data.status = TaskStatusCode.FAIL\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Failed -=-=-=-=-=-=-=\",\n                Fore.RED,\n                \"\",\n            )\n        else:\n            assert False, f\"{plan.data.name}\"\n        return search_method\n\n    def posterior_process(self, terminal_plan: Plan):\n        \"\"\"\n        Performs the post-processing steps on the terminal plan including extraction of posterior knowledge\n        and updating the plan data.\n\n        Args:\n            terminal_plan (Plan): The terminal plan after completion of all inner loop tasks.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.logger.typewriter_log(\n            \"-=-=-=-=-=-=-= POSTERIOR_PROCESS, working memory, summary, and reflection -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        posterior_data = get_posterior_knowledge(\n            all_plan=self.plan_agent.latest_plan,\n            terminal_plan=terminal_plan,\n            finish_node=terminal_plan.process_node,\n            tool_functions_description_list=self.tool_functions_description_list,\n            config=self.config,\n            agent_dispatcher=self.agent_dispatcher,\n        )\n\n        summary = posterior_data[\"summary\"]\n        terminal_plan.data.action_list_summary = summary\n\n        if \"reflection_of_plan\" in posterior_data.keys():\n            terminal_plan.data.posterior_plan_reflection = posterior_data[\"reflection_of_plan\"]\n\n        if \"reflection_of_tool\" in posterior_data.keys():\n            terminal_plan.data.tool_reflection = posterior_data[\"reflection_of_tool\"]\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**TaskHandler\n\nxagent_corexagent_paramxagent_coreXAgentCoreComponentsxagent_paramXAgentParam\n\nTaskHandler\n- self.xagent_core = xagent_corexagent_coreself.xagent_core\n- self.xagent_param = xagent_paramxagent_paramself.xagent_param\n- self.config = xagent_param.configxagent_paramconfigself.config\n- self.function_list = self.xagent_core.function_listxagent_corefunction_listself.function_list\n- self.tool_functions_description_list = self.xagent_core.tool_functions_description_listxagent_coretool_functions_description_listself.tool_functions_description_list\n- self.query = self.xagent_param.queryxagent_paramqueryself.query\n- self.tool_call_count = 00\n- self.plan_agent = PlanAgent(...)PlanAgentconfigquerytool_functions_description_list\n- self.logger = self.xagent_core.loggerxagent_coreloggerself.logger\n- self.interaction = self.xagent_core.interactionxagent_coreinteractionself.interaction\n- self.recorder = self.xagent_core.recorderxagent_corerecorderself.recorder\n- self.agent_dispatcher = self.xagent_core.agent_dispatcherxagent_coreagent_dispatcherself.agent_dispatcher\n- self.function_handler = self.xagent_core.function_handlerxagent_corefunction_handlerself.function_handler\n- self.toolserver_interface = self.xagent_core.toolserver_interfacexagent_coretoolserver_interfaceself.toolserver_interface\n- self.working_memory_agent = self.xagent_core.working_memory_agentxagent_coreworking_memory_agentself.working_memory_agent\n- self.now_dealing_task = NoneNone\n\n****\n- xagent_corexagent_param\n- xagent_coreXAgentCoreComponents\n- xagent_paramXAgentParam\n- ",
            "code_start_line": 31,
            "code_end_line": 63,
            "parent": "TaskHandler",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 xagent_core: XAgentCoreComponents,\n                 xagent_param: XAgentParam):\n        \"\"\"\n        Initializes TaskHandler with the provided input parameters.\n\n        Args:\n            xaagent_core (XAgentCoreComponents): Instance of XAgentCoreComponents class.\n            xaagent_param (XAgentParam): Instance of XAgentParam class.\n        \"\"\"\n        self.xagent_core = xagent_core\n        self.xagent_param = xagent_param\n        self.config = xagent_param.config\n        self.function_list = self.xagent_core.function_list\n        self.tool_functions_description_list = self.xagent_core.tool_functions_description_list\n        self.query = self.xagent_param.query\n        self.tool_call_count = 0\n        self.plan_agent = PlanAgent(\n            config=self.config,\n            query=self.query,\n            avaliable_tools_description_list=self.tool_functions_description_list,\n        )\n        self.logger = self.xagent_core.logger\n        # self.avaliable_tools_description_list = tool_functions_description_list\n\n        self.interaction = self.xagent_core.interaction\n        self.recorder = self.xagent_core.recorder\n        self.agent_dispatcher = self.xagent_core.agent_dispatcher\n        self.function_list = self.xagent_core.function_list\n        self.function_handler = self.xagent_core.function_handler\n        self.toolserver_interface = self.xagent_core.toolserver_interface\n        self.working_memory_agent = self.xagent_core.working_memory_agent\n        self.now_dealing_task = None\n",
            "name_column": 8
        },
        "outer_loop": {
            "type": "FunctionDef",
            "name": "outer_loop",
            "md_content": "**outer_loop**\n\nplan_agentinitial_plan_generationagent_dispatcher\n\nJSONinteractioninsert_data\n\nplan_agentplan_iterate_based_on_memory_system\n\nrewrite_input_func\n\nwhileinteractioninterruptTrueinner_loop\n\nposterior_processworking_memory_agent\n\n\n\ninteractioninsert_data\n\nplan_agentplan_refine_mode\n\nPlanpop_next_subtask\n\nNone\n\n****\n- \n- \n- \n\n****\n```\n-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\n\n\n\n\n\n\n\n...\nALL Tasks Done\n```",
            "code_start_line": 65,
            "code_end_line": 194,
            "parent": "TaskHandler",
            "have_return": true,
            "code_content": "    def outer_loop(self):\n        \"\"\"\n        Executes the main sequence of tasks in the outer loop.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger.typewriter_log(\n                        \"goal: \",\n                        Fore.YELLOW,\n                        f\"{new_intput}\",\n                    )\n                    self.now_dealing_task.data.goal = new_intput\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n\n            search_method = self.inner_loop(self.now_dealing_task)\n\n            self.now_dealing_task.process_node = search_method.get_finish_node()\n\n            self.posterior_process(self.now_dealing_task)\n\n            self.working_memory_agent.register_task(self.now_dealing_task)\n\n            self.xagent_core.print_task_save_items(self.now_dealing_task.data)\n\n            refinement_result = {\n                \"name\": self.now_dealing_task.data.name,\n                \"goal\": self.now_dealing_task.data.goal,\n                \"prior_plan_criticism\": self.now_dealing_task.data.prior_plan_criticism,\n                \"posterior_plan_reflection\": self.now_dealing_task.data.posterior_plan_reflection,\n                \"milestones\": self.now_dealing_task.data.milestones,\n                # \"expected_tools\": self.now_dealing_task.data.expected_tools,\n                \"tool_reflection\": self.now_dealing_task.data.tool_reflection,\n                \"action_list_summary\": self.now_dealing_task.data.action_list_summary,\n                \"task_id\": task_id,\n            }\n\n            self.interaction.insert_data(\n                data=refinement_result, status=StatusEnum.REFINEMENT, current=task_id)\n            if search_method.need_for_plan_refine:\n                self.plan_agent.plan_refine_mode(\n                    self.now_dealing_task, self.toolserver_interface, self.agent_dispatcher)\n            else:\n                self.logger.typewriter_log(\n                    \"subtask submitted as no need to refine the plan, continue\",\n                    Fore.BLUE,\n                )\n\n            self.now_dealing_task = Plan.pop_next_subtask(\n                self.now_dealing_task)\n\n            if self.now_dealing_task is None:\n                self.interaction.insert_data(\n                    data=[], status=StatusEnum.FINISHED, current=\"\")\n            else:\n                current_task_id = self.now_dealing_task.get_subtask_id(\n                    to_str=True)\n                remaining_subtask = Plan.get_remaining_subtask(\n                    self.now_dealing_task)\n                subtask_list = []\n                for todo_plan in remaining_subtask:\n                    raw_data = json.loads(todo_plan.data.raw)\n                    raw_data[\"task_id\"] = todo_plan.get_subtask_id(to_str=True)\n                    raw_data[\"inner\"] = []\n                    raw_data[\"node_id\"] = uuid.uuid4().hex\n                    subtask_list.append(raw_data)\n\n                self.interaction.insert_data(\n                    data=subtask_list, status=StatusEnum.SUBTASK, current=current_task_id)\n\n        self.logger.typewriter_log(\"ALL Tasks Done\", Fore.GREEN)\n        return\n",
            "name_column": 8
        },
        "inner_loop": {
            "type": "FunctionDef",
            "name": "inner_loop",
            "md_content": "**inner_loop**\n\nplan\n\nIDxagent_coreprint_task_save_items\n\nagent_dispatcherdispatchplanJSON\n\nDOING\n\nrapidapi_retrieve_tool_count0toolserver_interfaceretrieve_rapidapi_toolsrapidapifunction_handleravaliable_tools_description_listsubtask_handle_function_enum\n\nReACTChainSearchrunID\n\n\n\nsearch_method\n\n****\n\n****",
            "code_start_line": 196,
            "code_end_line": 266,
            "parent": "TaskHandler",
            "have_return": true,
            "code_content": "    def inner_loop(self, plan: Plan, ):\n        \"\"\"\n        Generates search plan and process it for the current task.\n\n        Args:\n            plan (Plan): The plan to be processed.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            ReACTChainSearch: Instance of the search plan.\n        \"\"\"\n        task_ids_str = plan.get_subtask_id(to_str=True)\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Performing Task {task_ids_str} ({plan.data.name}): Begin -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n        self.xagent_core.print_task_save_items(plan.data)\n\n        agent = self.agent_dispatcher.dispatch(\n            RequiredAbilities.tool_tree_search,\n            json.dumps(plan.data.to_json(), indent=2, ensure_ascii=False),\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        plan.data.status = TaskStatusCode.DOING\n\n        if self.config.rapidapi_retrieve_tool_count > 0:\n            retrieve_string = summarize_plan(plan.to_json())\n            rapidapi_tool_names, rapidapi_tool_jsons = self.toolserver_interface.retrieve_rapidapi_tools(\n                retrieve_string, top_k=self.config.rapidapi_retrieve_tool_count)\n            if rapidapi_tool_names is not None:\n                self.function_handler.change_subtask_handle_function_enum(\n                    self.function_handler.tool_names + rapidapi_tool_names)\n                self.function_handler.avaliable_tools_description_list += rapidapi_tool_jsons\n            else:\n                print(\"bug: no rapidapi tool retrieved, need to fix here\")\n\n        search_method = ReACTChainSearch(\n            xagent_core_components=self.xagent_core,)\n\n        arguments = function_manager.get_function_schema('action_reasoning')[\n            'parameters']\n        search_method.run(config=self.config,\n                          agent=agent,\n                          arguments=arguments,\n                          functions=self.function_handler.intrinsic_tools(\n                              self.config.enable_ask_human_for_help),\n                          task_id=task_ids_str,\n                          now_dealing_task=self.now_dealing_task,\n                          plan_agent=self.plan_agent)\n\n        if search_method.status == SearchMethodStatusCode.SUCCESS:\n            plan.data.status = TaskStatusCode.SUCCESS\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Solved -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n        elif search_method.status == SearchMethodStatusCode.FAIL:\n            plan.data.status = TaskStatusCode.FAIL\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Failed -=-=-=-=-=-=-=\",\n                Fore.RED,\n                \"\",\n            )\n        else:\n            assert False, f\"{plan.data.name}\"\n        return search_method\n",
            "name_column": 8
        },
        "posterior_process": {
            "type": "FunctionDef",
            "name": "posterior_process",
            "md_content": "**posterior_process**\n\nterminal_plan\n\nget_posterior_knowledgeposterior_data\n\nposterior_datasummaryterminal_plan.data.action_list_summary\n\nposterior_datareflection_of_planreflection_of_toolterminal_plan.data.posterior_plan_reflectionterminal_plan.data.tool_reflection\n\nNone\n\n****\n- Planterminal_plan\n- get_posterior_knowledge\n- ",
            "code_start_line": 268,
            "code_end_line": 300,
            "parent": "TaskHandler",
            "have_return": false,
            "code_content": "    def posterior_process(self, terminal_plan: Plan):\n        \"\"\"\n        Performs the post-processing steps on the terminal plan including extraction of posterior knowledge\n        and updating the plan data.\n\n        Args:\n            terminal_plan (Plan): The terminal plan after completion of all inner loop tasks.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.logger.typewriter_log(\n            \"-=-=-=-=-=-=-= POSTERIOR_PROCESS, working memory, summary, and reflection -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        posterior_data = get_posterior_knowledge(\n            all_plan=self.plan_agent.latest_plan,\n            terminal_plan=terminal_plan,\n            finish_node=terminal_plan.process_node,\n            tool_functions_description_list=self.tool_functions_description_list,\n            config=self.config,\n            agent_dispatcher=self.agent_dispatcher,\n        )\n\n        summary = posterior_data[\"summary\"]\n        terminal_plan.data.action_list_summary = summary\n\n        if \"reflection_of_plan\" in posterior_data.keys():\n            terminal_plan.data.posterior_plan_reflection = posterior_data[\"reflection_of_plan\"]\n\n        if \"reflection_of_tool\" in posterior_data.keys():\n            terminal_plan.data.tool_reflection = posterior_data[\"reflection_of_tool\"]\n",
            "name_column": 8
        },
        "rewrite_input_func": {
            "type": "FunctionDef",
            "name": "rewrite_input_func",
            "md_content": "**rewrite_input_func**\n\noldnewnewNoneoldFalsenew\"goal\"oldoldTrue\n\n\n\n****\n- oldnewoldnew\n- new\"goal\"\n\n****\n\"old_input\"{\"goal\": \"new_goal\"}(\"new_goal\", True)",
            "code_start_line": 99,
            "code_end_line": 106,
            "parent": "outer_loop",
            "have_return": true,
            "code_content": "        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n",
            "name_column": 12
        }
    },
    "XAgent/workflow/plan_exec.py": {
        "plan_function_output_parser": {
            "type": "FunctionDef",
            "name": "plan_function_output_parser",
            "md_content": "**plan_function_output_parser**Plan\n\nPlan\n\n\n- function_output_item (dict): \n\n\n- Plan: Plan\n\n\nXAgent/workflow/plan_exec.py\n\n    def initial_plan_generation(self, agent_dispatcher):\n        \"\"\"\n\n        \n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-=  -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n\n        split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_generation,\n            target_task=f\"{self.query.task}\",\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        # TODO: \n        new_message , _ = agent.parse(\n            placeholders={\n                \"system\": {\n                    # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                    \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                },\n                \"user\": {\n                    \"query\": self.plan.data.raw\n                }\n            },\n            arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n            functions=[split_functions], \n        )\n        \n        subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n        for subtask_item in subtasks[\"subtasks\"]:\n            subplan = plan_function_output_parser(subtask_item)\n            Plan.make_relation(self.plan, subplan)\n\n[]\n\n    def deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"\n\n        \n\n        \n        - function_input (dict): \n        - now_dealing_task (Plan): \n\n        \n        - str: \n        - PlanOperationStatusCode: \n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\" '>= {now_dealing_task.get_subtask_id(to_str=True)}'\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # if not subtask.data.status == TaskStatusCode.FAIL:\n                #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status",
            "code_start_line": 18,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "def plan_function_output_parser(function_output_item: dict) -> Plan:\n    \"\"\"Parses the function output item into a Plan object.\n\n    Args:\n        function_output_item (dict): The dictionary representing the function output item.\n\n    Returns:\n        Plan: The parsed Plan object.\n    \"\"\"\n    subtask_node = TaskSaveItem()\n    subtask_node.load_from_json(function_output_item=function_output_item)\n    subplan = Plan(subtask_node)\n    return subplan\n",
            "name_column": 4
        },
        "PlanRefineChain": {
            "type": "ClassDef",
            "name": "PlanRefineChain",
            "md_content": "**PlanRefineChain**\n\n\n\n****\n- plansList[Plan]\n- functionsList[dict]\n\n**__init__**\n- PlanRefineChain\n- \n  - init_plan\n\n**register**\n- \n- \n  - function_namestr\n  - function_inputdict\n  - function_outputstr\n  - new_planPlan\n\n**parse_to_message_list**\n- \n- \n  - flag_changed\n- \n\n****\n- PlanAgentPlanRefineChainrefine_chains\n- plan_refine_moderefine_chains\n\n****\n```\nPlanRefineChainplans[Plan1, Plan2, ...]\nPlanRefineChainfunctions[{\"name\": \"1\", \"input\": {...}, \"output\": \"1\"}, {\"name\": \"2\", \"input\": {...}, \"output\": \"2\"}, ...]\n```",
            "code_start_line": 32,
            "code_end_line": 107,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanRefineChain():\n    \"\"\"Represents a chain of plan refinements.\n\n    This class keeps track of the refined plans and the associated refine functions.\n\n    Attributes:\n        plans (List[Plan]): The list of refined plans.\n        functions (List[dict]): The list of refine functions.\n    \"\"\"\n\n    def __init__(self, init_plan):\n        \"\"\"Initializes a PlanRefineChain object.\n\n        Args:\n            init_plan: The initial plan.\n        \"\"\"\n        self.plans = [deepcopy(init_plan)]\n        self.functions = []\n\n    def register(self, function_name, function_input, function_output, new_plan: Plan):\n        \"\"\"Registers a plan refinement.\n\n        This method adds the function name, input, and output, as well as the new plan to the refine chain.\n\n        Args:\n            function_name (str): The name of the refine function.\n            function_input (dict): The input of the refine function.\n            function_output (str): The output of the refine function.\n            new_plan (Plan): The new plan after refinement.\n        \"\"\"\n        self.functions.append({\n            \"name\": function_name,\n            \"input\": function_input,\n            \"output\": function_output,\n        })\n        self.plans.append(deepcopy(new_plan))\n\n        XAgentCoreComponents.global_recorder.regist_plan_modify(\n            refine_function_name = function_name,\n            refine_function_input = function_input,\n            refine_function_output = function_output,\n            plan_after = new_plan.to_json(posterior=True),\n        )\n\n    def parse_to_message_list(self, flag_changed) -> List[Message]:\n        \"\"\"Parses the refine chain to a list of messages.\n\n        This method generates a list of messages describing each refinement step in the refine chain.\n\n        Args:\n            flag_changed: A flag indicating whether the plan has changed.\n\n        Returns:\n            List[Message]: A list of messages.\n        \"\"\"\n        assert len(self.plans) == len(self.functions) + 1\n\n        if CONFIG.enable_summary:\n            init_message = summarize_plan(self.plans[0].to_json())\n        else:\n            init_message = json.dumps(self.plans[0].to_json(), indent=2, ensure_ascii=False)\n        init_message =  Message(\"user\", f\"\"\"The initial plan and the execution status is:\\n'''\\n{init_message}\\n'''\\n\\n\"\"\")\n        output_list = [init_message]\n        for k, (function, output_plan) in enumerate(zip(self.functions, self.plans[1:])):\n            operation_message = Message(\"user\", f\"\"\"For the {k+1}\\'th step, You made the following operation:\\nfunction_name: {function[\"name\"]}\\n'''\\n{json.dumps(function[\"input\"],indent=2,ensure_ascii=False)}\\n'''\\nThen get the operation result:\\n{function[\"output\"]}\\n\"\"\")\n            output_list.append(operation_message)\n        if len(self.plans) > 1:\n            if flag_changed:\n                if CONFIG.enable_summary:\n                    new_message = summarize_plan(self.plans[-1].to_json())\n                else:\n                    new_message = json.dumps(self.plans[-1].to_json(), indent=2, ensure_ascii=False)\n                output_list.append(Message(\"user\", f\"\"\"The total plan changed to follows:\\n'''\\n{new_message}\\n'''\\n\\n\"\"\"))\n            else:\n                output_list.append(Message(\"user\", f\"The total plan stay unchanged\"))\n        return output_list\n",
            "name_column": 6
        },
        "PlanAgent": {
            "type": "ClassDef",
            "name": "PlanAgent",
            "md_content": "**PlanAgent**: \n\n\n\n- config: \n- query (BaseQuery): \n- avaliable_tools_description_list (List[dict]): \n- plan (Plan): \n- refine_chains (List[PlanRefineChain]): \n\n\n\n- `__init__(self, config, query: BaseQuery, avaliable_tools_description_list: List[dict])`: PlanAgent\n- `initial_plan_generation(self, agent_dispatcher)`: \n- `plan_iterate_based_on_memory_system(self)`: \n- `latest_plan(self)`: \n- `plan_refine_mode(self, now_dealing_task: Plan, toolserver_interface, agent_dispatcher)`: \n- `deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: \n- `deal_subtask_delete(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: \n- `deal_subtask_modify(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: \n- `deal_subtask_add(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: \n\n**Note**: \n- \n- `__init__`PlanAgent\n- `initial_plan_generation`\n- `plan_iterate_based_on_memory_system`\n- `latest_plan`\n- `plan_refine_mode`\n- `deal_subtask_split`\n- `deal_subtask_delete`\n- `deal_subtask_modify`\n- `deal_subtask_add`\n\n**Output Example**:\n```python\nplan_agent = PlanAgent(config, query, avaliable_tools_description_list)\nplan_agent.initial_plan_generation(agent_dispatcher)\nlatest_plan = plan_agent.latest_plan()\nplan_agent.plan_refine_mode(now_dealing_task, toolserver_interface, agent_dispatcher)\n```",
            "code_start_line": 109,
            "code_end_line": 495,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanAgent():\n    \"\"\"Represents a plan agent.\n\n    This class is responsible for generating and refining plans.\n\n    Attributes:\n        config: The configuration for the plan agent.\n        query (BaseQuery): The base query for generating plans.\n        avaliable_tools_description_list (List[dict]): The list of available tool descriptions.\n        plan (Plan): The plan.\n        refine_chains (List[PlanRefineChain]): The list of refine chains.\n    \"\"\"\n    def __init__(self, config, query: BaseQuery, avaliable_tools_description_list: List[dict]):\n        \"\"\"Initializes a PlanAgent object.\n\n        Args:\n            config: The configuration for the plan agent.\n            query (BaseQuery): The base query for generating plans.\n            avaliable_tools_description_list (List[dict]): The list of available tool descriptions.\n        \"\"\"\n        self.config = config\n        self.query = query\n        self.avaliable_tools_description_list = avaliable_tools_description_list\n\n        self.plan = Plan(\n            data = TaskSaveItem(\n                name=f\"act as {query.role_name}\",\n                goal=query.task,\n                milestones=query.plan,\n                # tool_budget=100,\n            )\n        )\n\n        self.refine_chains: List[PlanRefineChain] = []\n\n    def initial_plan_generation(self, agent_dispatcher):\n        \"\"\"Generates the initial plan.\n\n        This method generates the initial plan by calling the plan generation agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= GENERATE INITIAL_PLAN -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n\n        split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_generation,\n            target_task=f\"Generate a plan to accomplish the task: {self.query.task}\",\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        # TODO: not robust. dispatcher generated prompt may not contain these specified placeholders?\n        new_message , _ = agent.parse(\n            placeholders={\n                \"system\": {\n                    # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                    \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                },\n                \"user\": {\n                    \"query\": self.plan.data.raw\n                }\n            },\n            arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n            functions=[split_functions], \n        )\n        \n        subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n        for subtask_item in subtasks[\"subtasks\"]:\n            subplan = plan_function_output_parser(subtask_item)\n            Plan.make_relation(self.plan, subplan)\n\n    def plan_iterate_based_on_memory_system(self):\n        \"\"\"Iteratively refines the plan based on the memory system.\n\n        This method iteratively refines the plan based on the memory system.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON MEMORY SYSTEM -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        print(\"Not Implemented, skip\")\n        # TODO\n\n    @property\n    def latest_plan(self):\n        \"\"\"Gets the latest plan.\n\n        Returns:\n            The latest plan.\n        \"\"\"\n        return self.plan\n\n    def plan_refine_mode(self, now_dealing_task: Plan, toolserver_interface, agent_dispatcher):\n        \"\"\"Enters the plan refine mode.\n\n        This method enters the plan refine mode and performs plan refinements based on user suggestions.\n\n        Args:\n            now_dealing_task (Plan): The task that is currently being dealt with.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON TASK AGENT SUGGESTIONS -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n\n        self.refine_chains.append(PlanRefineChain(self.plan)) \n\n        modify_steps = 0\n        max_step = self.config.max_plan_refine_chain_length\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_refinement, \n            target_task=\"Refine the given plan.\", \n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n        try:\n            refine_node_message = now_dealing_task.process_node.data[\"command\"][\"properties\"][\"args\"]\n            refine_node_message = refine_node_message[\"suggestions_for_latter_subtasks_plan\"][\"reason\"]\n        except:\n            refine_node_message = \"\"\n        workspace_files = str(toolserver_interface.execute_command_client(\"FileSystemEnv_print_filesys_struture\", {\"return_root\":True}))\n        workspace_files,length = clip_text(workspace_files,1000,clip_end=True)\n                \n        while modify_steps < max_step:\n\n            logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Continually refining planning (still in the loop)-=-=-=-=-=-=-=\",\n                Fore.GREEN,\n            )\n\n            subtask_id = now_dealing_task.get_subtask_id(to_str=True)\n            flag_changed = False\n            \n            additional_message_list = self.refine_chains[-1].parse_to_message_list(flag_changed)\n\n            functions=[deepcopy(function_manager.get_function_schema('subtask_operations'))]\n            \n            new_message , _ = agent.parse(\n                placeholders={\n                    \"system\": {\n                        # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                        \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                        \"max_plan_tree_width\": self.config.max_plan_tree_width,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                    },\n                    \"user\": {\n                        \"subtask_id\": subtask_id,\n                        \"max_step\": max_step,\n                        \"modify_steps\": modify_steps,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                        \"workspace_files\": workspace_files,\n                        \"refine_node_message\":refine_node_message,\n                    }\n                }, \n                arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n                functions=functions, \n                additional_messages=additional_message_list,\n                additional_insert_index=-1,\n            )\n            function_name = new_message[\"function_call\"][\"name\"]\n            function_input = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n            if function_input['operation'] == 'split':\n                # modify function_input here\n                function_output, output_status_code = self.deal_subtask_split(function_input, now_dealing_task)\n            elif function_input['operation'] == 'add':\n                function_output, output_status_code = self.deal_subtask_add(function_input, now_dealing_task)\n            elif function_input['operation'] == 'delete':\n                function_output, output_status_code = self.deal_subtask_delete(function_input, now_dealing_task)\n            elif function_input['operation'] == 'exit':\n                output_status_code = PlanOperationStatusCode.PLAN_REFINE_EXIT\n                function_output = json.dumps({\n                    \"content\": \"exit PLAN_REFINE_MODE successfully\",\n                })\n            else:\n                logger.typewriter_log(\"Error: \", Fore.RED, f\"Operation {function_input['operation']} not found. Nothing happens\")\n                output_status_code = PlanOperationStatusCode.PLAN_OPERATION_NOT_FOUND\n                function_output = json.dumps({\n                    \"error\": f\"Operation {function_input['operation']} not found. Nothing happens\"\n                })\n            \n            if \"error\" not in function_output:\n                flag_changed = True\n\n            self.refine_chains[-1].register(function_name=function_name,\n                                            function_input=function_input,\n                                            function_output=function_output,\n                                            new_plan=self.plan)\n\n            if output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                color = Fore.GREEN\n            elif output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT:\n                color = Fore.YELLOW\n            else:\n                color = Fore.RED\n            logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, function_output)\n            logger.typewriter_log(\n                \"PLAN MODIFY STATUS CODE: \", Fore.YELLOW, f\"{color}{output_status_code.name}{Style.RESET_ALL}\"\n            )\n\n            if output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT or output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                return\n\n            modify_steps += 1\n\n    def deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask splitting.\n\n        This method handles subtask splitting.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only split the TODO subtask plans together with the now_dealing_subtask, e.g. '>= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # if not subtask.data.status == TaskStatusCode.FAIL:\n                #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status.name}' Task. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                if subtask.get_depth() >= self.config.max_plan_tree_depth:\n                    return json.dumps({\"error\": f\"The plan tree has a max depth of {self.config.max_plan_tree_depth}. '{subtask.data.name}' already has a depth of {subtask.get_depth()}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                for new_subtask in function_input[\"subtasks\"]:\n                    new_subplan = plan_function_output_parser(new_subtask)\n                    Plan.make_relation(subtask,new_subplan)\n                subtask.data.status = TaskStatusCode.SPLIT\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been split\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n\n\n    def deal_subtask_delete(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask deletion.\n\n        This method handles subtask deletion.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                \n                if subtask.data.status != TaskStatusCode.TODO :\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # try to delete the subtask\n                subtask.father.children.remove(subtask)\n                subtask.father = None\n                \n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been deleted\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n\n\n    def deal_subtask_modify(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask modification.\n\n        This method handles subtask modification.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only modify the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are modifying {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                assert subtask.data.status == TaskStatusCode.TODO\n                subtask.data.load_from_json(function_input[\"new_data\"])\n\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been modified\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n\n    def deal_subtask_add(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask addition.\n\n        This method handles subtask addition.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        former_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        # check whether the former_subtask_id is valid\n\n        former_subtask = None\n        for subtask in inorder_subtask_stack:\n            if subtask.get_subtask_id(to_str=True) == former_subtask_id:\n                former_subtask = subtask\n                break\n        if former_subtask is None:\n            return json.dumps({\"error\": f\"former_subtask_id '{former_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        former_subtask_id_list = former_subtask.get_subtask_id_list()\n        now_dealing_task_id_list = now_dealing_task.get_subtask_id_list()\n        \n        if former_subtask.get_depth() <= 1:\n            return json.dumps({\"error\": f\"You are not allowed to add a subtask at root level. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        if len(former_subtask.father.children) + len(function_input[\"subtasks\"]) > self.config.max_plan_tree_width: # fixs bugs here: the length calculation is incorrect\n            return json.dumps({\"error\": f\"The plan tree has a max width of {self.config.max_plan_tree_width}. '{former_subtask.data.name}' already has a width of {len(former_subtask.children)}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n            \n        for i in range(min(len(former_subtask_id_list), len(now_dealing_task_id_list))):\n            if former_subtask_id_list[i]<now_dealing_task_id_list[i]:\n                return json.dumps({\"error\": f\"You can only add the subtask plans after than now_dealing task, e.g. 'former_subtask_id >= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # pass check\n        new_subplans = [plan_function_output_parser(new_subtask) for new_subtask in function_input[\"subtasks\"]]\n\n        subtask = former_subtask\n        if subtask.father is None:\n            return json.dumps({\"error\":f\"Currently not support adding a subtask at root level!\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # assert subtask.father != None\n        index = subtask.father.children.index(subtask)\n\n        for new_subplan in new_subplans:\n            new_subplan.father = subtask.father\n        subtask.father.children[index+1:index+1] = new_subplans\n        \n        return json.dumps({\"success\": f\"A new subtask has been added after '{former_subtask_id}'\",}), PlanOperationStatusCode.MODIFY_SUCCESS",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**PlanAgent\n\n\n- config\n- query\n- avaliable_tools_description_list\n\n\n- configself.config\n- queryself.query\n- avaliable_tools_description_listself.avaliable_tools_description_list\n\nPlanself.planPlanTaskSaveItemTaskSaveItem\n\nself.refine_chains\n\n****\n- configqueryavaliable_tools_description_list\n- PlanTaskSaveItem",
            "code_start_line": 121,
            "code_end_line": 142,
            "parent": "PlanAgent",
            "have_return": false,
            "code_content": "    def __init__(self, config, query: BaseQuery, avaliable_tools_description_list: List[dict]):\n        \"\"\"Initializes a PlanAgent object.\n\n        Args:\n            config: The configuration for the plan agent.\n            query (BaseQuery): The base query for generating plans.\n            avaliable_tools_description_list (List[dict]): The list of available tool descriptions.\n        \"\"\"\n        self.config = config\n        self.query = query\n        self.avaliable_tools_description_list = avaliable_tools_description_list\n\n        self.plan = Plan(\n            data = TaskSaveItem(\n                name=f\"act as {query.role_name}\",\n                goal=query.task,\n                milestones=query.plan,\n                # tool_budget=100,\n            )\n        )\n\n        self.refine_chains: List[PlanRefineChain] = []\n",
            "name_column": 8
        },
        "register": {
            "type": "FunctionDef",
            "name": "register",
            "md_content": "**register**\n\n\n\n\n- function_name (str)\n- function_input (dict)\n- function_output (str)\n- new_plan (Plan)\n\nfunctionsplans\n\nXAgentCoreComponents.global_recorder.regist_plan_modify\n\n****\n- \n- new_planPlan\n- XAgentCoreComponents.global_recorder",
            "code_start_line": 51,
            "code_end_line": 74,
            "parent": "PlanRefineChain",
            "have_return": false,
            "code_content": "    def register(self, function_name, function_input, function_output, new_plan: Plan):\n        \"\"\"Registers a plan refinement.\n\n        This method adds the function name, input, and output, as well as the new plan to the refine chain.\n\n        Args:\n            function_name (str): The name of the refine function.\n            function_input (dict): The input of the refine function.\n            function_output (str): The output of the refine function.\n            new_plan (Plan): The new plan after refinement.\n        \"\"\"\n        self.functions.append({\n            \"name\": function_name,\n            \"input\": function_input,\n            \"output\": function_output,\n        })\n        self.plans.append(deepcopy(new_plan))\n\n        XAgentCoreComponents.global_recorder.regist_plan_modify(\n            refine_function_name = function_name,\n            refine_function_input = function_input,\n            refine_function_output = function_output,\n            plan_after = new_plan.to_json(posterior=True),\n        )\n",
            "name_column": 8
        },
        "parse_to_message_list": {
            "type": "FunctionDef",
            "name": "parse_to_message_list",
            "md_content": "**parse_to_message_list**\n\n\n\n\n- flag_changed\n\n\n- List[Message]\n\nself.plansself.functions1\n\nCONFIG.enable_summaryTrueself.plans[0]JSONsummarize_planinit_messageself.plans[0]JSONASCII\n\ninit_messageMessageoutput_list\n\nenumerateself.functionsself.plans[1:]operation_messagek+1output_list\n\nself.plans1flag_changedCONFIG.enable_summarynew_messageoutput_list\n\noutput_list\n\n****summarize_planMessage\n\n****output_list\n```\n[\n    Message(\"user\", \"The initial plan and the execution status is:\\n'''\\n{init_message}\\n'''\\n\\n\"),\n    Message(\"user\", \"For the 1'th step, You made the following operation:\\nfunction_name: {function_name}\\n'''\\n{function_input}\\n'''\\nThen get the operation result:\\n{function_output}\\n\"),\n    Message(\"user\", \"The total plan changed to follows:\\n'''\\n{new_message}\\n'''\\n\\n\")\n]\n```",
            "code_start_line": 76,
            "code_end_line": 107,
            "parent": "PlanRefineChain",
            "have_return": true,
            "code_content": "    def parse_to_message_list(self, flag_changed) -> List[Message]:\n        \"\"\"Parses the refine chain to a list of messages.\n\n        This method generates a list of messages describing each refinement step in the refine chain.\n\n        Args:\n            flag_changed: A flag indicating whether the plan has changed.\n\n        Returns:\n            List[Message]: A list of messages.\n        \"\"\"\n        assert len(self.plans) == len(self.functions) + 1\n\n        if CONFIG.enable_summary:\n            init_message = summarize_plan(self.plans[0].to_json())\n        else:\n            init_message = json.dumps(self.plans[0].to_json(), indent=2, ensure_ascii=False)\n        init_message =  Message(\"user\", f\"\"\"The initial plan and the execution status is:\\n'''\\n{init_message}\\n'''\\n\\n\"\"\")\n        output_list = [init_message]\n        for k, (function, output_plan) in enumerate(zip(self.functions, self.plans[1:])):\n            operation_message = Message(\"user\", f\"\"\"For the {k+1}\\'th step, You made the following operation:\\nfunction_name: {function[\"name\"]}\\n'''\\n{json.dumps(function[\"input\"],indent=2,ensure_ascii=False)}\\n'''\\nThen get the operation result:\\n{function[\"output\"]}\\n\"\"\")\n            output_list.append(operation_message)\n        if len(self.plans) > 1:\n            if flag_changed:\n                if CONFIG.enable_summary:\n                    new_message = summarize_plan(self.plans[-1].to_json())\n                else:\n                    new_message = json.dumps(self.plans[-1].to_json(), indent=2, ensure_ascii=False)\n                output_list.append(Message(\"user\", f\"\"\"The total plan changed to follows:\\n'''\\n{new_message}\\n'''\\n\\n\"\"\"))\n            else:\n                output_list.append(Message(\"user\", f\"The total plan stay unchanged\"))\n        return output_list\n",
            "name_column": 8
        },
        "initial_plan_generation": {
            "type": "FunctionDef",
            "name": "initial_plan_generation",
            "md_content": "**initial_plan_generation**\n\nagent_dispatcher\n\n\n\nfunction_manager.get_function_schema('subtask_split_operation')'subtask_split_operation'\n\nagent_dispatcherdispatchRequiredAbilities.plan_generationagent\n\nagentparseplaceholdersargumentsnew_message\n\nnew_messagesubtasks\n\nplan_function_output_parserPlan.make_relation\n\n****TODOdispatcher\n\n\nXAgent/workflow/task_handler.py\n\n```\nself.plan_agent.initial_plan_generation(\n    agent_dispatcher=self.agent_dispatcher)\n```\nagent_dispatcher\n\nJSONinteraction\n\nplan_iterate_based_on_memory_system\n\nouter_loopinitial_plan_generation\n\nplan generation agentagent_dispatcherdispatchagentagentparsenew_message\n\n****TODOagent",
            "code_start_line": 144,
            "code_end_line": 182,
            "parent": "PlanAgent",
            "have_return": false,
            "code_content": "    def initial_plan_generation(self, agent_dispatcher):\n        \"\"\"Generates the initial plan.\n\n        This method generates the initial plan by calling the plan generation agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= GENERATE INITIAL_PLAN -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n\n        split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_generation,\n            target_task=f\"Generate a plan to accomplish the task: {self.query.task}\",\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        # TODO: not robust. dispatcher generated prompt may not contain these specified placeholders?\n        new_message , _ = agent.parse(\n            placeholders={\n                \"system\": {\n                    # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                    \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                },\n                \"user\": {\n                    \"query\": self.plan.data.raw\n                }\n            },\n            arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n            functions=[split_functions], \n        )\n        \n        subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n        for subtask_item in subtasks[\"subtasks\"]:\n            subplan = plan_function_output_parser(subtask_item)\n            Plan.make_relation(self.plan, subplan)\n",
            "name_column": 8
        },
        "plan_iterate_based_on_memory_system": {
            "type": "FunctionDef",
            "name": "plan_iterate_based_on_memory_system",
            "md_content": "**plan_iterate_based_on_memory_system**\n\n\n\n\n- logger.typewriter_log\n- \"Not Implemented, skip\"\n\n\n- \n\n\nXAgent/workflow/task_handler.py\n\n```\nself.plan_agent.plan_iterate_based_on_memory_system()\n```\ntask_handler.pyouter_loop\n\n[]\n[XAgent/workflow/task_handler.py]",
            "code_start_line": 184,
            "code_end_line": 193,
            "parent": "PlanAgent",
            "have_return": false,
            "code_content": "    def plan_iterate_based_on_memory_system(self):\n        \"\"\"Iteratively refines the plan based on the memory system.\n\n        This method iteratively refines the plan based on the memory system.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON MEMORY SYSTEM -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        print(\"Not Implemented, skip\")\n",
            "name_column": 8
        },
        "latest_plan": {
            "type": "FunctionDef",
            "name": "latest_plan",
            "md_content": "**latest_plan**\n\n\n\n\nXAgent/workflow/task_handler.py\n\n    def outer_loop(self):\n        \"\"\"\n        \n\n        Raises:\n            AssertionError: \n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger.typewriter_log(\n                        \"goal: \",\n                        Fore.YELLOW,\n                        f\"{new_intput}\",\n                    )\n                    self.now_dealing_task.data.goal = new_intput\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n\n            search_method = self.inner_loop(self.now_dealing_task)\n\n            self.now_dealing_task.process_node = search_method.get_finish_node()\n\n            self.posterior_process(self.now_dealing_task)\n\n            self.working_memory_agent.register_task(self.now_dealing_task)\n\n            self.xagent_core.print_task_save_items(self.now_dealing_task.data)\n\n            refinement_result = {\n                \"name\": self.now_dealing_task.data.name,\n                \"goal\": self.now_dealing_task.data.goal,\n                \"prior_plan_criticism\": self.now_dealing_task.data.prior_plan_criticism,\n                \"posterior_plan_reflection\": self.now_dealing_task.data.posterior_plan_reflection,\n                \"milestones\": self.now_dealing_task.data.milestones,\n                # \"expected_tools\": self.now_dealing_task.data.expected_tools,\n                \"tool_reflection\": self.now_dealing_task.data.tool_reflection,\n                \"action_list_summary\": self.now_dealing_task.data.action_list_summary,\n                \"task_id\": task_id,\n            }\n\n            self.interaction.insert_data(\n                data=refinement_result, status=StatusEnum.REFINEMENT, current=task_id)\n            if search_method.need_for_plan_refine:\n                self.plan_agent.plan_refine_mode(\n                    self.now_dealing_task, self.toolserver_interface, self.agent_dispatcher)\n            else:\n                self.logger.typewriter_log(\n                    \"subtask submitted as no need to refine the plan, continue\",\n                    Fore.BLUE,\n                )\n\n            self.now_dealing_task = Plan.pop_next_subtask(\n                self.now_dealing_task)\n\n            if self.now_dealing_task is None:\n                self.interaction.insert_data(\n                    data=[], status=StatusEnum.FINISHED, current=\"\")\n            else:\n                current_task_id = self.now_dealing_task.get_subtask_id(\n                    to_str=True)\n                remaining_subtask = Plan.get_remaining_subtask(\n                    self.now_dealing_task)\n                subtask_list = []\n                for todo_plan in remaining_subtask:\n                    raw_data = json.loads(todo_plan.data.raw)\n                    raw_data[\"task_id\"] = todo_plan.get_subtask_id(to_str=True)\n                    raw_data[\"inner\"] = []\n                    raw_data[\"node_id\"] = uuid.uuid4().hex\n                    subtask_list.append(raw_data)\n\n                self.interaction.insert_data(\n                    data=subtask_list, status=StatusEnum.SUBTASK, current=current_task_id)\n\n        self.logger.typewriter_log(\"ALL Tasks Done\", Fore.GREEN)\n        return\n\n[]\n[End of XAgent/workflow/task_handler.py]\n\n\n- Markdown\n- \n\n**latest_plan**\n\n\n\nXAgent/workflow/task_handler.pyouter_loopouter_loopouter_loop\n\n****\n- \n- \n\n****{\"task_id\": \"123\", \"name\": \"1\", \"goal\": \"\"}{\"task_id\": \"123\", \"name\": \"1\", \"goal\": \"\"}",
            "code_start_line": 197,
            "code_end_line": 203,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def latest_plan(self):\n        \"\"\"Gets the latest plan.\n\n        Returns:\n            The latest plan.\n        \"\"\"\n        return self.plan\n",
            "name_column": 8
        },
        "plan_refine_mode": {
            "type": "FunctionDef",
            "name": "plan_refine_mode",
            "md_content": "**plan_refine_mode**\n\n\n- now_dealing_task (Plan): \n\n\n1. \n2. \n3. \n4. \n5. \n6. \n7. \n8. IDflag_changedFalse\n9. \n10. \n11. \n12. \n13. \n14. \n15. PLAN_REFINE_EXITMODIFY_SUCCESS\n16. \n17. \n\n****\n- now_dealing_taskPlan\n- \n\n****\n```python\n{\n    \"content\": \"exit PLAN_REFINE_MODE successfully\"\n}\n```",
            "code_start_line": 205,
            "code_end_line": 316,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def plan_refine_mode(self, now_dealing_task: Plan, toolserver_interface, agent_dispatcher):\n        \"\"\"Enters the plan refine mode.\n\n        This method enters the plan refine mode and performs plan refinements based on user suggestions.\n\n        Args:\n            now_dealing_task (Plan): The task that is currently being dealt with.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON TASK AGENT SUGGESTIONS -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n\n        self.refine_chains.append(PlanRefineChain(self.plan)) \n\n        modify_steps = 0\n        max_step = self.config.max_plan_refine_chain_length\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_refinement, \n            target_task=\"Refine the given plan.\", \n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n        try:\n            refine_node_message = now_dealing_task.process_node.data[\"command\"][\"properties\"][\"args\"]\n            refine_node_message = refine_node_message[\"suggestions_for_latter_subtasks_plan\"][\"reason\"]\n        except:\n            refine_node_message = \"\"\n        workspace_files = str(toolserver_interface.execute_command_client(\"FileSystemEnv_print_filesys_struture\", {\"return_root\":True}))\n        workspace_files,length = clip_text(workspace_files,1000,clip_end=True)\n                \n        while modify_steps < max_step:\n\n            logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Continually refining planning (still in the loop)-=-=-=-=-=-=-=\",\n                Fore.GREEN,\n            )\n\n            subtask_id = now_dealing_task.get_subtask_id(to_str=True)\n            flag_changed = False\n            \n            additional_message_list = self.refine_chains[-1].parse_to_message_list(flag_changed)\n\n            functions=[deepcopy(function_manager.get_function_schema('subtask_operations'))]\n            \n            new_message , _ = agent.parse(\n                placeholders={\n                    \"system\": {\n                        # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                        \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                        \"max_plan_tree_width\": self.config.max_plan_tree_width,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                    },\n                    \"user\": {\n                        \"subtask_id\": subtask_id,\n                        \"max_step\": max_step,\n                        \"modify_steps\": modify_steps,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                        \"workspace_files\": workspace_files,\n                        \"refine_node_message\":refine_node_message,\n                    }\n                }, \n                arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n                functions=functions, \n                additional_messages=additional_message_list,\n                additional_insert_index=-1,\n            )\n            function_name = new_message[\"function_call\"][\"name\"]\n            function_input = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n            if function_input['operation'] == 'split':\n                # modify function_input here\n                function_output, output_status_code = self.deal_subtask_split(function_input, now_dealing_task)\n            elif function_input['operation'] == 'add':\n                function_output, output_status_code = self.deal_subtask_add(function_input, now_dealing_task)\n            elif function_input['operation'] == 'delete':\n                function_output, output_status_code = self.deal_subtask_delete(function_input, now_dealing_task)\n            elif function_input['operation'] == 'exit':\n                output_status_code = PlanOperationStatusCode.PLAN_REFINE_EXIT\n                function_output = json.dumps({\n                    \"content\": \"exit PLAN_REFINE_MODE successfully\",\n                })\n            else:\n                logger.typewriter_log(\"Error: \", Fore.RED, f\"Operation {function_input['operation']} not found. Nothing happens\")\n                output_status_code = PlanOperationStatusCode.PLAN_OPERATION_NOT_FOUND\n                function_output = json.dumps({\n                    \"error\": f\"Operation {function_input['operation']} not found. Nothing happens\"\n                })\n            \n            if \"error\" not in function_output:\n                flag_changed = True\n\n            self.refine_chains[-1].register(function_name=function_name,\n                                            function_input=function_input,\n                                            function_output=function_output,\n                                            new_plan=self.plan)\n\n            if output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                color = Fore.GREEN\n            elif output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT:\n                color = Fore.YELLOW\n            else:\n                color = Fore.RED\n            logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, function_output)\n            logger.typewriter_log(\n                \"PLAN MODIFY STATUS CODE: \", Fore.YELLOW, f\"{color}{output_status_code.name}{Style.RESET_ALL}\"\n            )\n\n            if output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT or output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                return\n\n            modify_steps += 1\n",
            "name_column": 8
        },
        "deal_subtask_split": {
            "type": "FunctionDef",
            "name": "deal_subtask_split",
            "md_content": "**deal_subtask_split**: \n\n\n\n:\n- function_input (dict): \n- now_dealing_task (Plan): \n\n:\n- str: \n- PlanOperationStatusCode: \n\nfunction_inputinorder_subtask_stackfunction_inputIDSPLIT\n\n\n\n****: :\n- function_inputtarget_subtask_idsubtasks\n- target_subtask_idID\n- subtasks\n\n****:\n```\n{\n    \"success\": \" 'target_subtask_id' \"\n}\n```",
            "code_start_line": 318,
            "code_end_line": 359,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask splitting.\n\n        This method handles subtask splitting.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only split the TODO subtask plans together with the now_dealing_subtask, e.g. '>= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # if not subtask.data.status == TaskStatusCode.FAIL:\n                #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status.name}' Task. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                if subtask.get_depth() >= self.config.max_plan_tree_depth:\n                    return json.dumps({\"error\": f\"The plan tree has a max depth of {self.config.max_plan_tree_depth}. '{subtask.data.name}' already has a depth of {subtask.get_depth()}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                for new_subtask in function_input[\"subtasks\"]:\n                    new_subplan = plan_function_output_parser(new_subtask)\n                    Plan.make_relation(subtask,new_subplan)\n                subtask.data.status = TaskStatusCode.SPLIT\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been split\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n",
            "name_column": 8
        },
        "deal_subtask_delete": {
            "type": "FunctionDef",
            "name": "deal_subtask_delete",
            "md_content": "**deal_subtask_delete**\n\n\n\n\n- function_inputdict\n- now_dealing_taskPlan\n\n\n- str\n- PlanOperationStatusCode\n\n\nfunction_inputIDIDall_subtask_ids\n\ninorder_subtask_stackID\n- \n- \"TODO\"\n- \n\ninorder_subtask_stack\n\n\n- function_input\"target_subtask_id\"ID\n- \n\n\n```\n{\n  \"success\": \"Subtask 'target_subtask_id' has been deleted\"\n}\n```",
            "code_start_line": 362,
            "code_end_line": 401,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_delete(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask deletion.\n\n        This method handles subtask deletion.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                \n                if subtask.data.status != TaskStatusCode.TODO :\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # try to delete the subtask\n                subtask.father.children.remove(subtask)\n                subtask.father = None\n                \n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been deleted\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n",
            "name_column": 8
        },
        "deal_subtask_modify": {
            "type": "FunctionDef",
            "name": "deal_subtask_modify",
            "md_content": "**deal_subtask_modify**\n\n\n\n\n- function_input (dict)\n- now_dealing_task (Plan)\n\n\n- str\n- PlanOperationStatusCode\n\n\njsonIDID\n\ncan_editFalseIDID\n- can_editFalseTODOID'now_dealing_task.get_subtask_id(to_str=True)''subtask.get_subtask_id(to_str=True)'MODIFY_FORMER_PLAN\n- TODO\n\nMODIFY_SUCCESS\n\nIDIDcan_editTrue\n\nIDID' target_subtask_id '' all_subtask_ids 'TARGET_SUBTASK_NOT_FOUND\n\n\n- function_input\n- \n\n\n```\n{\n  \"success\": \"Subtask 'target_subtask_id' has been modified\"\n}\n```",
            "code_start_line": 404,
            "code_end_line": 438,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_modify(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask modification.\n\n        This method handles subtask modification.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only modify the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are modifying {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                assert subtask.data.status == TaskStatusCode.TODO\n                subtask.data.load_from_json(function_input[\"new_data\"])\n\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been modified\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n",
            "name_column": 8
        },
        "deal_subtask_add": {
            "type": "FunctionDef",
            "name": "deal_subtask_add",
            "md_content": "**deal_subtask_add**\n\n\n\n\n- function_inputdict\n- now_dealing_taskPlan\n\n\n- str\n- PlanOperationStatusCode\n\n\n- function_input\n- \n- ID\n- ID\n- former_subtask_idformer_subtask_idformer_subtaskTARGET_SUBTASK_NOT_FOUND\n- former_subtasknow_dealing_taskID\n- former_subtask1TARGET_SUBTASK_NOT_FOUND\n- former_subtaskOTHER_ERROR\n- former_subtask_id_listnow_dealing_task_id_listformer_subtask_id_listnow_dealing_task_id_listMODIFY_FORMER_PLAN\n- function_inputsubtasksPlannew_subplans\n- subtaskMODIFY_FORMER_PLAN\n- subtaskchildren\n- new_subplanssubtaskchildrenindex+1\n- MODIFY_SUCCESS\n\nPlanOperationStatusCode\n\n\n```\n{\n  \"success\": \"A new subtask has been added after 'former_subtask_id'\"\n}\n```",
            "code_start_line": 440,
            "code_end_line": 495,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_add(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask addition.\n\n        This method handles subtask addition.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        former_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        # check whether the former_subtask_id is valid\n\n        former_subtask = None\n        for subtask in inorder_subtask_stack:\n            if subtask.get_subtask_id(to_str=True) == former_subtask_id:\n                former_subtask = subtask\n                break\n        if former_subtask is None:\n            return json.dumps({\"error\": f\"former_subtask_id '{former_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        former_subtask_id_list = former_subtask.get_subtask_id_list()\n        now_dealing_task_id_list = now_dealing_task.get_subtask_id_list()\n        \n        if former_subtask.get_depth() <= 1:\n            return json.dumps({\"error\": f\"You are not allowed to add a subtask at root level. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        if len(former_subtask.father.children) + len(function_input[\"subtasks\"]) > self.config.max_plan_tree_width: # fixs bugs here: the length calculation is incorrect\n            return json.dumps({\"error\": f\"The plan tree has a max width of {self.config.max_plan_tree_width}. '{former_subtask.data.name}' already has a width of {len(former_subtask.children)}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n            \n        for i in range(min(len(former_subtask_id_list), len(now_dealing_task_id_list))):\n            if former_subtask_id_list[i]<now_dealing_task_id_list[i]:\n                return json.dumps({\"error\": f\"You can only add the subtask plans after than now_dealing task, e.g. 'former_subtask_id >= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # pass check\n        new_subplans = [plan_function_output_parser(new_subtask) for new_subtask in function_input[\"subtasks\"]]\n\n        subtask = former_subtask\n        if subtask.father is None:\n            return json.dumps({\"error\":f\"Currently not support adding a subtask at root level!\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # assert subtask.father != None\n        index = subtask.father.children.index(subtask)\n\n        for new_subplan in new_subplans:\n            new_subplan.father = subtask.father\n        subtask.father.children[index+1:index+1] = new_subplans\n        \n        return json.dumps({\"success\": f\"A new subtask has been added after '{former_subtask_id}'\",}), PlanOperationStatusCode.MODIFY_SUCCESS",
            "name_column": 8
        }
    },
    "XAgent/workflow/base_query.py": {
        "BaseQuery": {
            "type": "ClassDef",
            "name": "BaseQuery",
            "md_content": "**BaseQuery**: XAgent\n\n\n- role_name (str): \n- task (str): \n- plan (list): \n\n\n- `__init__(self, role_name=\"\", task=\"\", plan=[])`: BaseQuery\n- `log_self(self)`: BaseQuery\n- `to_json(self)`: BaseQueryJSON\n- `from_json(cls, json_data)`: JSONBaseQuery\n\n****: \n- BaseQuery\n- `log_self`\n\n****:\n```python\nquery = BaseQuery(role_name=\"user\", task=\"search\", plan=[\"step1\", \"step2\"])\nprint(query.to_json())\n# : {'task': 'search', 'role_name': 'user', 'plan': ['step1', 'step2']}\n\njson_data = {'task': 'search', 'role_name': 'user', 'plan': ['step1', 'step2']}\nquery = BaseQuery.from_json(json_data)\nprint(query.role_name)\n# : 'user'\n```",
            "code_start_line": 6,
            "code_end_line": 61,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseQuery(metaclass = abc.ABCMeta):\n    \"\"\"\n    Base class for Query object. This class should be inherited by any other query class that will be used in the XAgent.\n\n    Attributes:\n        role_name (str): Name of the role involved in the query.\n        task (str): Task that is being queried.\n        plan (list): List of the plan details for the query.\n    \"\"\"\n\n    def __init__(self, role_name=\"\", task=\"\", plan=[]):\n        \"\"\"\n        Constructs all the necessary attributes for the BaseQuery object.\n\n        Args:\n            role_name (str, optional): Name of the role involved in the query.\n            task (str, optional): Task that is being queried.\n            plan (list, optional): List of the plan details for the query.\n        \"\"\"\n        self.role_name = role_name\n        self.task = task\n        self.plan = plan\n\n    @abc.abstractmethod\n    def log_self(self):\n        \"\"\"\n        Abstract method to log Query details. \n        This method should be implemented by all classes that inherit from BaseQuery.\n        \"\"\"\n        pass\n\n    def to_json(self):\n        \"\"\"\n        Serializes the BaseQuery object into a JSON object.\n\n        Returns:\n            dict: A dictionary version of the BaseQuery object.\n        \"\"\"\n        return {\n            \"task\": self.task,\n            \"role_name\": self.role_name,\n            \"plan\": self.plan,\n        }\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"\n        Construct a new BaseQuery object from a JSON object.\n\n        Args:\n            json_data (dict): The JSON object that will be used to construct the BaseQuery.\n\n        Returns:\n            BaseQuery: A new BaseQuery object constructed from the values in `json_data`.\n        \"\"\"\n        return cls(**json_data)\n",
            "name_column": 6
        },
        "AutoGPTQuery": {
            "type": "ClassDef",
            "name": "AutoGPTQuery",
            "md_content": "**AutoGPTQuery**GPTBaseQuery\n\n`__init__(self, **args)`BaseQueryAutoGPTQuery\n\n\n- `**args`\n\nlog_selfloggerAutoGPTQuery\n\n\"Role\"\"Task\"role_nametask\n\"Plan\"\n\nloggerAutoGPTQuery\n\n****\n- AutoGPTQueryGPT\n- `__init__`BaseQueryAutoGPTQuery\n- log_selfloggerAutoGPTQuery\"Role\"\"Task\"",
            "code_start_line": 64,
            "code_end_line": 91,
            "parent": null,
            "have_return": false,
            "code_content": "class AutoGPTQuery(BaseQuery):\n    \"\"\"\n    A specific type of query that inherits from the BaseQuery class.\n    Used for specific GPT model actions.\n    \"\"\"\n\n    def __init__(self,**args):\n        \"\"\"\n        Constructs all the necessary attributes for the AutoGPTQuery object by inheriting from BaseQuery class.\n\n        Args:\n            **args: Variable length argument list which is a dictionary of attribute key-value pairs.\n        \"\"\"\n        super().__init__(**args)\n\n    def log_self(self):\n        \"\"\"\n        Logs AutoGPTQuery details using logger.\n\n        This method logs \"Role\", \"Task\" with role_name and task respectively.\n        If there is any detail in the plan, it also logs \"Plan\" with each detail in the plan.\n        \"\"\"\n        logger.typewriter_log(\"Role\", Fore.YELLOW, self.role_name)\n        logger.typewriter_log(\"Task\", Fore.YELLOW, self.task)\n        if self.plan != []:\n            logger.typewriter_log(\"Plan\", Fore.YELLOW)\n            for k, plan in enumerate(self.plan):\n                logger.typewriter_log(f\"    {k+1}.{plan}\", Style.RESET_ALL)",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**BaseQueryAutoGPTQuery\n\n**args\n\n__init__\n\n****\n- \n- **args\n- __init__",
            "code_start_line": 70,
            "code_end_line": 77,
            "parent": "AutoGPTQuery",
            "have_return": false,
            "code_content": "    def __init__(self,**args):\n        \"\"\"\n        Constructs all the necessary attributes for the AutoGPTQuery object by inheriting from BaseQuery class.\n\n        Args:\n            **args: Variable length argument list which is a dictionary of attribute key-value pairs.\n        \"\"\"\n        super().__init__(**args)\n",
            "name_column": 8
        },
        "log_self": {
            "type": "FunctionDef",
            "name": "log_self",
            "md_content": "**log_self**: loggerAutoGPTQuery\n\nlogger\"Role\"\"Task\"role_nametask\"Plan\"\n\n\nXAgent/workflow/base_query.py\n\n```python\nclass BaseQuery(metaclass = abc.ABCMeta):\n    \"\"\"\n    Base class for Query object. This class should be inherited by any other query class that will be used in the XAgent.\n\n    Attributes:\n        role_name (str): Name of the role involved in the query.\n        task (str): Task that is being queried.\n        plan (list): List of the plan details for the query.\n    \"\"\"\n\n    def __init__(self, role_name=\"\", task=\"\", plan=[]):\n        \"\"\"\n        Constructs all the necessary attributes for the BaseQuery object.\n\n        Args:\n            role_name (str, optional): Name of the role involved in the query.\n            task (str, optional): Task that is being queried.\n            plan (list, optional): List of the plan details for the query.\n        \"\"\"\n        self.role_name = role_name\n        self.task = task\n        self.plan = plan\n\n    @abc.abstractmethod\n    def log_self(self):\n        \"\"\"\n        Abstract method to log Query details. \n        This method should be implemented by all classes that inherit from BaseQuery.\n        \"\"\"\n        pass\n\n    def to_json(self):\n        \"\"\"\n        Serializes the BaseQuery object into a JSON object.\n\n        Returns:\n            dict: A dictionary version of the BaseQuery object.\n        \"\"\"\n        return {\n            \"task\": self.task,\n            \"role_name\": self.role_name,\n            \"plan\": self.plan,\n        }\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"\n        Construct a new BaseQuery object from a JSON object.\n\n        Args:\n            json_data (dict): The JSON object that will be used to construct the BaseQuery.\n\n        Returns:\n            BaseQuery: A new BaseQuery object constructed from the values in `json_data`.\n        \"\"\"\n        return cls(**json_data)\n```\n[]\n[ XAgent/workflow/base_query.py]\nXAgent/workflow/task_handler.py\n\n```python\n    def outer_loop(self):\n        \"\"\"\n        Executes the main sequence of tasks in the outer loop.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger",
            "code_start_line": 79,
            "code_end_line": 91,
            "parent": "AutoGPTQuery",
            "have_return": false,
            "code_content": "    def log_self(self):\n        \"\"\"\n        Logs AutoGPTQuery details using logger.\n\n        This method logs \"Role\", \"Task\" with role_name and task respectively.\n        If there is any detail in the plan, it also logs \"Plan\" with each detail in the plan.\n        \"\"\"\n        logger.typewriter_log(\"Role\", Fore.YELLOW, self.role_name)\n        logger.typewriter_log(\"Task\", Fore.YELLOW, self.task)\n        if self.plan != []:\n            logger.typewriter_log(\"Plan\", Fore.YELLOW)\n            for k, plan in enumerate(self.plan):\n                logger.typewriter_log(f\"    {k+1}.{plan}\", Style.RESET_ALL)",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**BaseQueryJSON\n\nBaseQuery\n\n****\n\n****\n```\n{\n    \"task\": \"task_name\",\n    \"role_name\": \"role_name\",\n    \"plan\": \"plan_name\"\n}\n```\n\n\n\nXAgent/recorder.py\n\n\n```python\ndef regist_query(self, query):\n    \"\"\"query\n    \"\"\"\n    record = self.generate_record(\n        current=self.now_subtask_id,\n        node_id=0,\n        node_type=RecorderTypeEnum.QUERY,\n        data=query.to_json(),\n    )\n    with get_db() as db:\n        RunningRecordCRUD.insert_record(db=db, record=record)\n```\n\nregist_queryqueryJSON",
            "code_start_line": 37,
            "code_end_line": 48,
            "parent": "BaseQuery",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"\n        Serializes the BaseQuery object into a JSON object.\n\n        Returns:\n            dict: A dictionary version of the BaseQuery object.\n        \"\"\"\n        return {\n            \"task\": self.task,\n            \"role_name\": self.role_name,\n            \"plan\": self.plan,\n        }\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "**from_json**JSONBaseQuery\n\n\n- json_datadictBaseQueryJSON\n\nBaseQuery`json_data`\n\n\nXAgent/recorder.py\n\n```python\ndef get_query(self):\n    \"\"\"\"\"\"\n    with get_db() as db:\n        records = RunningRecordCRUD.get_record_by_type(\n            db=db,\n            record_id=self.record_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.QUERY,\n        )\n\n    self.query = AutoGPTQuery.from_json(records[0].data)\n    return self.query\n```\n[]\n\n```python\ndef load_from_db(self, record_id):\n    \"\"\"record\n    \"\"\"\n\n    self.newly_start = False\n\n    with get_db() as db:\n        records = RunningRecordCRUD.get_record_by_type(\n            db=db,\n            record_id=record_id\n        )\n\n    for record in records:\n        if record.node_type == RecorderTypeEnum.QUERY:\n            self.query = AutoGPTQuery.from_json(record.data)\n        elif record.node_type == RecorderTypeEnum.CONFIG:\n            self.config = XAgentConfig()\n            self.config.merge_from_dict(record.data)\n        elif record.node_type == RecorderTypeEnum.LLM_INPUT_PAIR:\n            self.llm_server_cache.append(record.data)\n        elif record.node_type == RecorderTypeEnum.TOOL_SERVER_PAIR:\n            self.tool_server_cache.append(record.data)\n        elif record.node_type == RecorderTypeEnum.PLAN_REFINE:\n            self.plan_refine_cache.append(record.data)\n        elif record.node_type == RecorderTypeEnum.TOOL_CALL:\n            self.tool_call_cache.append(record.data)\n        else:\n            raise NotImplementedError\n```\n[]\n[]\nXAgent/running_recorder.py\n\n```python\ndef load_from_disk(self, record_dir):\n    \"\"\"\n    record\n\n    \n        - record_dirstrrecord\n\n    \"\"\"\n    logger.typewriter_log(\n        \"record\",\n        Fore.BLUE,\n        record_dir,\n    )\n    self.regist_father_info(record_dir)\n    self.newly_start = False\n\n    for dir_name in os.listdir(record_dir):\n        if dir_name == \"query.json\":\n            with open(os.path.join(record_dir, dir_name), \"r\",encoding=\"utf-8\") as reader:\n                self.query_json = json.load(reader)\n                self.query = AutoGPTQuery.from_json(self.query_json)\n        elif dir_name == \"config.yml\":\n            CONFIG.reload(os.path.join(record_dir, dir_name))\n        elif dir_name == \"LLM_inout_pair\":\n            inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n            self.llm_server_cache = [None]*inout_count\n            for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                inout_id = int(file_name.split(\".\")[0])\n                with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                    llm_pair = json.load(reader)\n                    self.llm_server_cache[inout_id] = llm_pair\n            logger.typewriter_log(\n                f\"{inout_count}LLM\",\n                Fore.BLUE,\n            )\n        elif dir_name == \"tool_server_pair\":\n            inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n            self.tool_server_cache = [None]*inout_count\n            for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                inout_id = int(file_name.split(\".\")[0])\n                with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                    tool_pair = json.load(reader)\n                    self.tool_server_cache[inout_id] = tool_pair\n            logger.typewriter_log(\n                f\"{len(os.listdir(os.path.join(record_dir, dir_name)))}\",\n                Fore.BLUE,\n            )\n        elif os.path.isdir(os.path.join(record_dir, dir_name)):\n            for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                if file_name.startswith(\"plan_refine\"):\n                    with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                        plan_refine = json.load(reader)\n                        self.plan_refine_cache.append(plan_refine)\n                elif file_name.startswith(\"tool\"):\n                    with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                        tool_call = json.load(reader)\n                        self.tool_call_cache.append(tool_call)\n                else:\n                    raise NotImplementedError\n```\n[]\n[]\n\n****\n- `json_data`JSON\n- `json_data``BaseQuery`\n\n****\n```python\n{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n    ...\n}\n```",
            "code_start_line": 51,
            "code_end_line": 61,
            "parent": "BaseQuery",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        \"\"\"\n        Construct a new BaseQuery object from a JSON object.\n\n        Args:\n            json_data (dict): The JSON object that will be used to construct the BaseQuery.\n\n        Returns:\n            BaseQuery: A new BaseQuery object constructed from the values in `json_data`.\n        \"\"\"\n        return cls(**json_data)\n",
            "name_column": 8
        }
    },
    "XAgent/inner_loop_search_algorithms/ReACT.py": {
        "make_message": {
            "type": "FunctionDef",
            "name": "make_message",
            "md_content": "**make_message**\n\n\n- now_nodeToolNode\n- max_length\n- config\n- now_dealing_task\n\n\n\n\n1. enable_summaryTruesummarize_planterminal_task_info\n2. JSONjson.dumps2ASCIIterminal_task_info\n3. \n4. now_subtask_promptterminal_task_infoMessage\n5. processaction_process\n6. enable_summaryTruesummarize_actionaction_processaction_process\n7. user_promptaction_processMessage\n8. \n\n****\n- now_nodemax_lengthconfignow_dealing_task\n- enable_summaryTrue\n- \n\n****\n```\n[\n    Message(\"user\", \"Now you will perform the following subtask:\\n\"\"\"\\n{terminal_task_info}\\n\"\"\"\\n\"),\n    Message(\"user\", \"The following steps have been performed (you have already done the following and the current file contents are shown below):\\n\\n{action_process}\")\n]\n```",
            "code_start_line": 18,
            "code_end_line": 53,
            "parent": null,
            "have_return": true,
            "code_content": "def make_message(now_node: ToolNode, max_length, config, now_dealing_task):\n    \"\"\"\n    Function to generate messages for each node.\n\n    Args:\n        now_node: The current ToolNode instance.\n        task_handler: Handler of the tasks.\n        max_length: Maximum length of the subtask chain.\n        config: The configuration settings.\n\n    Returns:\n        The sequence of messages for the current node.\n\n    \"\"\"\n\n    if CONFIG.enable_summary:\n        terminal_task_info = summarize_plan(\n            now_dealing_task.to_json())\n    else:\n        terminal_task_info = json.dumps(\n            now_dealing_task.to_json(), indent=2, ensure_ascii=False)\n\n    message_sequence = []\n\n    now_subtask_prompt = f'''Now you will perform the following subtask:\\n\"\"\"\\n{terminal_task_info}\\n\"\"\"\\n'''\n    message_sequence.append(Message(\"user\", now_subtask_prompt))\n    action_process = now_node.process\n\n    if config.enable_summary:\n        action_process = summarize_action(\n            action_process, terminal_task_info)\n    user_prompt = f\"\"\"The following steps have been performed (you have already done the following and the current file contents are shown below):\\n\n    {action_process}\n    \"\"\"\n    message_sequence.append(Message(\"user\", user_prompt))\n    return message_sequence\n",
            "name_column": 4
        },
        "ReACTChainSearch": {
            "type": "ClassDef",
            "name": "ReACTChainSearch",
            "md_content": "**ReACTChainSearch**: ReACT\n\nBaseSearchMethodReACT\n\n**__init__**:\n- xagent_core_components: XAgentCoreComponentsReACTChainSearch\n\n**run**:\n- config: \n- agent: \n- arguments: \n- functions: \n- task_id: ID\n- max_try: \n- max_answer: \n\n**get_finish_node**:\n- \n\n**get_origin_data**:\n- data: \n- \n\n**rewrite_input_func**:\n- old: \n- new: \n- \n\n**generate_chain**:\n- config: \n- agent: \n- arguments: \n- functions: \n- task_id: ID\n- now_dealing_task: \n- plan_agent: \n- \n\n**to_json**:\n- ReACTChainSearchJSON\n\n**is_include_pictures**:\n- \n\n****: \n- ReACTChainSearch\n- \n- run\n- get_finish_node\n- get_origin_data\n- rewrite_input_func\n- generate_chain\n- to_jsonJSON\n- is_include_pictures\n\n****:\n```python\nsearch_method = ReACTChainSearch(xagent_core_components=core_components)\nsearch_method.run(config, agent, arguments, functions, task_id, now_dealing_task, plan_agent)\nfinish_node = search_method.get_finish_node()\norigin_data = search_method.get_origin_data(data)\nupdated_input, rewrite_status = search_method.rewrite_input_func(old, new)\nsearch_method.generate_chain(config, agent, arguments, functions, task_id, now_dealing_task, plan_agent)\nsearch_method.to_json()\ninclude_pictures = search_method.is_include_pictures(using_tools)\n```",
            "code_start_line": 56,
            "code_end_line": 338,
            "parent": null,
            "have_return": true,
            "code_content": "class ReACTChainSearch(BaseSearchMethod):\n    \"\"\"\n    Class for ReACT chain search. It performs chain based searches for tasks.\n    \"\"\"\n\n    def __init__(self, xagent_core_components: XAgentCoreComponents):\n        \"\"\"\n        xagent_core_components: XAgentCoreComponents object, used to initialize ReACTChainSearch object\n        Initializes ReACTChainSearch object. It maintains a list of trees to represent \n        the processed tasks.\n        \"\"\"\n        super().__init__()\n\n        self.tree_list = []\n\n        self.finish_node = None\n\n        self.xagent_core_components = xagent_core_components\n\n    def run(self,\n            config,\n            agent: BaseAgent,\n            arguments,\n            functions,\n            task_id,\n            now_dealing_task,\n            plan_agent,\n            max_try=1,\n            max_answer=1):\n        \"\"\"\n        Runs the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n            max_try: Maximum number of attempts.\n            max_answer: Maximum number of answers to be received\n\n        Returns:\n            None\n        Raises:\n            None\n        \"\"\"\n\n        for _attempt_id in range(max_try):\n            self.generate_chain(config, agent, arguments,\n                                functions, task_id, now_dealing_task, plan_agent)\n\n        if self.status == SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER:\n            self.status = SearchMethodStatusCode.SUCCESS\n        else:\n            self.status = SearchMethodStatusCode.FAIL\n\n    def get_finish_node(self):\n        \"\"\"\n        Function to retrieve the finished node in the task tree.\n\n        Returns:\n            The finished node.  \n        \"\"\"\n        return self.finish_node\n\n    def get_origin_data(self, data):\n        \"\"\"\n        Retrieves the initially entered data.\n\n        Args:\n            data: The initially entered data list.\n\n        Returns:\n            The initially entered data as a dictionary.:\n        \"\"\"\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = data.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n\n        return {\"args\": {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism\n        }}\n\n    def rewrite_input_func(self, old, new):\n        \"\"\"\n        Checks whether the new inputs are valid and if so updates the old input\n        with the new one.\n\n        Args:\n            old: The old input entry.\n            new: The new input entry to replace the old one.\n\n        Returns:\n            The updated input list and the rewrite status.\n        \"\"\"\n        if not isinstance(new, dict):\n            pass\n        if new is None:\n            return old, False\n        else:\n            args = new.get(\"args\", {})\n            assistant_thoughts_reasoning = None\n            assistant_thoughts_plan = None\n            assistant_thoughts_speak = None\n            assistant_thoughts_criticism = None\n\n            assistant_thoughts = old.get(\"thoughts\", {})\n            assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n            assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n            if assistant_thoughts:\n                assistant_thoughts_reasoning = assistant_thoughts.get(\n                    \"reasoning\")\n                assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n                assistant_thoughts_criticism = assistant_thoughts.get(\n                    \"criticism\")\n\n                if \"thoughts\" in args.keys() and \"thought\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"thought\"] = args.get(\n                        \"thoughts\", assistant_thoughts_text)\n                if \"reasoning\" in args.keys() and \"reasoning\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"reasoning\"] = args.get(\n                        \"reasoning\", assistant_thoughts_reasoning)\n                if \"plan\" in args.keys() and \"plan\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"plan\"] = args.get(\n                        \"plan\", assistant_thoughts_plan)\n                if \"criticism\" in args.keys() and \"criticism\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"criticism\"] = args.get(\n                        \"criticism\", assistant_thoughts_criticism)\n\n            return old, True\n\n    def generate_chain(self, config, agent: BaseAgent, arguments, functions, task_id, now_dealing_task, plan_agent):\n        \"\"\"\n        Run the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n\n        Returns:\n            None.\n        Raises:\n            None.\n        \"\"\"\n\n        self.tree_list.append(TaskSearchTree())\n        now_attempt_tree = self.tree_list[-1]\n        now_node = now_attempt_tree.root\n\n        while now_node.get_depth() < config.max_subtask_chain_length:\n            self.xagent_core_components.logger.typewriter_log(\n                \"-=-=-=-=-=-=-= THOUGHTS, REASONING, PLAN AND CRITICISM WILL NOW BE VERIFIED BY AGENT -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n            if now_node.father != None:\n                if self.xagent_core_components.interaction.interrupt:\n                    can_modify = self.get_origin_data(now_node.data)\n                    receive_data = self.xagent_core_components.interaction.receive(\n                        can_modify)\n                    data, rewrite_flag = self.rewrite_input_func(\n                        now_node.data, receive_data)\n                    now_node.data = data\n                    if rewrite_flag:\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n                        self.xagent_core_components.print_assistant_thoughts(now_node.data, False)\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n\n            message_sequence = make_message(now_node=now_node,\n                                            max_length=config.max_subtask_chain_length,\n                                            config=config,\n                                            now_dealing_task=now_dealing_task)\n\n            function_call = None\n            if now_node.get_depth() == config.max_subtask_chain_length - 1:\n                function_call = {\"name\": \"subtask_submit\"}\n\n            file_archi, _, = self.xagent_core_components.toolserver_interface.execute_command_client(\n                \"FileSystemEnv_print_filesys_struture\", {\"return_root\": True})\n            file_archi, length = clip_text(file_archi, 1000, clip_end=True)\n\n            human_prompt = \"\"\n            if config.enable_ask_human_for_help:\n                human_prompt = \"- Use 'ask_human_for_help' when you need help, remember to be specific to your requirement to help user to understand your problem.\"\n            else:\n                human_prompt = \"- Human is not available for help. You are not allowed to ask human for help in any form or channel. Solve the problem by yourself. If information is not enough, try your best to use default value.\"\n\n            all_plan = plan_agent.latest_plan.to_json()\n            if config.enable_summary:\n                all_plan = summarize_plan(all_plan)\n            else:\n                all_plan = json.dumps(all_plan, indent=2, ensure_ascii=False)\n\n            new_message, tokens = agent.parse(\n                placeholders={\n                    \"system\": {\n                        \"all_plan\": all_plan\n                    },\n                    \"user\": {\n                        \"workspace_files\": file_archi,\n                        \"subtask_id\": now_dealing_task.get_subtask_id(to_str=True),\n                        \"max_length\": config.max_subtask_chain_length,\n                        \"step_num\": str(now_node.get_depth()+1),\n                        \"human_help_prompt\": human_prompt,\n                    }\n                },\n                arguments=arguments,\n                functions=functions,\n                function_call=function_call,\n                additional_messages=message_sequence,\n                additional_insert_index=-1\n            )\n\n            new_tree_node = agent.message_to_tool_node(new_message)\n\n            print_data = self.xagent_core_components.print_assistant_thoughts(\n                new_tree_node.data, False\n            )\n\n            tool_output, tool_output_status_code, need_for_plan_refine, using_tools = self.xagent_core_components.function_handler.handle_tool_call(\n                new_tree_node)\n            self.need_for_plan_refine = need_for_plan_refine\n            now_attempt_tree.make_father_relation(now_node, new_tree_node)\n            self.xagent_core_components.interaction.insert_data(\n                data={**print_data, \"using_tools\": using_tools}, status=\"inner\", current=task_id, is_include_pictures=self.is_include_pictures(using_tools))\n\n            now_node = new_tree_node\n\n            if tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n\n                self.status = SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER\n                break\n            elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n                break\n\n        self.finish_node = now_node\n\n    def to_json(self):\n        \"\"\"\n        Placeholder function to convert ReACTChainSearch object to JSON.\n\n        Currently not implemented.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def is_include_pictures(self, using_tools):\n        \"\"\"png\n        \"\"\"\n        tool_name = using_tools.get(\"tool_name\", \"\") if isinstance(\n            using_tools, dict) else \"\"\n        tool_output = using_tools.get(\n            \"tool_output\", {}) if isinstance(using_tools, dict) else \"\"\n        if tool_name == \"PythonNotebook_execute_cell\":\n            for output in tool_output:\n                if isinstance(output, dict) and 'file_name' in output:\n                    return True\n        return False\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**ReACTChainSearch\n\n`super().__init__()`\n\n- `tree_list`\n- `finish_node`\n- `xagent_core_components`XAgentCoreComponentsReACTChainSearch\n\n\n\n****\n- XAgentCoreComponents\n- ReACTChainSearch`tree_list`\n- `finish_node`",
            "code_start_line": 61,
            "code_end_line": 73,
            "parent": "ReACTChainSearch",
            "have_return": false,
            "code_content": "    def __init__(self, xagent_core_components: XAgentCoreComponents):\n        \"\"\"\n        xagent_core_components: XAgentCoreComponents object, used to initialize ReACTChainSearch object\n        Initializes ReACTChainSearch object. It maintains a list of trees to represent \n        the processed tasks.\n        \"\"\"\n        super().__init__()\n\n        self.tree_list = []\n\n        self.finish_node = None\n\n        self.xagent_core_components = xagent_core_components\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "**run**\n\n\n- config\n- agent\n- arguments\n- functions\n- task_idID\n- max_try1\n- max_answer1\n\ngenerate_chain\n\nHAVE_AT_LEAST_ONE_ANSWERSUCCESSFAIL\n\n****\n- \n- arguments'action_reasoning'\n- functions\n- task_idID\n- max_trymax_answer",
            "code_start_line": 75,
            "code_end_line": 110,
            "parent": "ReACTChainSearch",
            "have_return": false,
            "code_content": "    def run(self,\n            config,\n            agent: BaseAgent,\n            arguments,\n            functions,\n            task_id,\n            now_dealing_task,\n            plan_agent,\n            max_try=1,\n            max_answer=1):\n        \"\"\"\n        Runs the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n            max_try: Maximum number of attempts.\n            max_answer: Maximum number of answers to be received\n\n        Returns:\n            None\n        Raises:\n            None\n        \"\"\"\n\n        for _attempt_id in range(max_try):\n            self.generate_chain(config, agent, arguments,\n                                functions, task_id, now_dealing_task, plan_agent)\n\n        if self.status == SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER:\n            self.status = SearchMethodStatusCode.SUCCESS\n        else:\n            self.status = SearchMethodStatusCode.FAIL\n",
            "name_column": 8
        },
        "get_finish_node": {
            "type": "FunctionDef",
            "name": "get_finish_node",
            "md_content": "**get_finish_node**\n\n\n\n\n- \n\n\n\n****\n\n****node1node1",
            "code_start_line": 112,
            "code_end_line": 119,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def get_finish_node(self):\n        \"\"\"\n        Function to retrieve the finished node in the task tree.\n\n        Returns:\n            The finished node.  \n        \"\"\"\n        return self.finish_node\n",
            "name_column": 8
        },
        "get_origin_data": {
            "type": "FunctionDef",
            "name": "get_origin_data",
            "md_content": "**get_origin_data**\n\n\n\nassistant_thoughts_reasoningassistant_thoughts_planassistant_thoughts_speakassistant_thoughts_criticism\n\n\"thoughts\"\"reasoning\"\"plan\"\"criticism\"\n\n\n\n****data\n\n****\n```\n{\n    \"args\": {\n        \"thoughts\": \"XXX\",\n        \"reasoning\": \"XXX\",\n        \"plan\": \"XXX\",\n        \"criticism\": \"XXX\"\n    }\n}\n```",
            "code_start_line": 121,
            "code_end_line": 149,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def get_origin_data(self, data):\n        \"\"\"\n        Retrieves the initially entered data.\n\n        Args:\n            data: The initially entered data list.\n\n        Returns:\n            The initially entered data as a dictionary.:\n        \"\"\"\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = data.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n\n        return {\"args\": {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism\n        }}\n",
            "name_column": 8
        },
        "rewrite_input_func": {
            "type": "FunctionDef",
            "name": "rewrite_input_func",
            "md_content": "**rewrite_input_func**\n\n\n- old\n- new\n\n\n\n\n1. \n2. NoneFalse\n3. argsassistant_thoughts_reasoningassistant_thoughts_planassistant_thoughts_speakassistant_thoughts_criticism\n4. thoughtsassistant_thoughts\n5. assistant_thoughtspropertiesassistant_thoughts_text\n6. assistant_thoughtsargs\"thoughts\"\"thought\"thoughts\n7. args\"reasoning\"\"reasoning\"thoughts\n8. args\"plan\"\"plan\"thoughts\n9. args\"criticism\"\"criticism\"thoughts\n10. True\n\n****\n****\n\n\n- Markdown\n- ",
            "code_start_line": 151,
            "code_end_line": 197,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def rewrite_input_func(self, old, new):\n        \"\"\"\n        Checks whether the new inputs are valid and if so updates the old input\n        with the new one.\n\n        Args:\n            old: The old input entry.\n            new: The new input entry to replace the old one.\n\n        Returns:\n            The updated input list and the rewrite status.\n        \"\"\"\n        if not isinstance(new, dict):\n            pass\n        if new is None:\n            return old, False\n        else:\n            args = new.get(\"args\", {})\n            assistant_thoughts_reasoning = None\n            assistant_thoughts_plan = None\n            assistant_thoughts_speak = None\n            assistant_thoughts_criticism = None\n\n            assistant_thoughts = old.get(\"thoughts\", {})\n            assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n            assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n            if assistant_thoughts:\n                assistant_thoughts_reasoning = assistant_thoughts.get(\n                    \"reasoning\")\n                assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n                assistant_thoughts_criticism = assistant_thoughts.get(\n                    \"criticism\")\n\n                if \"thoughts\" in args.keys() and \"thought\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"thought\"] = args.get(\n                        \"thoughts\", assistant_thoughts_text)\n                if \"reasoning\" in args.keys() and \"reasoning\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"reasoning\"] = args.get(\n                        \"reasoning\", assistant_thoughts_reasoning)\n                if \"plan\" in args.keys() and \"plan\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"plan\"] = args.get(\n                        \"plan\", assistant_thoughts_plan)\n                if \"criticism\" in args.keys() and \"criticism\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"criticism\"] = args.get(\n                        \"criticism\", assistant_thoughts_criticism)\n\n            return old, True\n",
            "name_column": 8
        },
        "generate_chain": {
            "type": "FunctionDef",
            "name": "generate_chain",
            "md_content": "**generate_chain**\n\n\n- config\n- agent\n- arguments\n- functions\n- task_idID\n\n\n\nparse\n\n****enable_ask_human_for_helpenable_summary\n\n****",
            "code_start_line": 199,
            "code_end_line": 314,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def generate_chain(self, config, agent: BaseAgent, arguments, functions, task_id, now_dealing_task, plan_agent):\n        \"\"\"\n        Run the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n\n        Returns:\n            None.\n        Raises:\n            None.\n        \"\"\"\n\n        self.tree_list.append(TaskSearchTree())\n        now_attempt_tree = self.tree_list[-1]\n        now_node = now_attempt_tree.root\n\n        while now_node.get_depth() < config.max_subtask_chain_length:\n            self.xagent_core_components.logger.typewriter_log(\n                \"-=-=-=-=-=-=-= THOUGHTS, REASONING, PLAN AND CRITICISM WILL NOW BE VERIFIED BY AGENT -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n            if now_node.father != None:\n                if self.xagent_core_components.interaction.interrupt:\n                    can_modify = self.get_origin_data(now_node.data)\n                    receive_data = self.xagent_core_components.interaction.receive(\n                        can_modify)\n                    data, rewrite_flag = self.rewrite_input_func(\n                        now_node.data, receive_data)\n                    now_node.data = data\n                    if rewrite_flag:\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n                        self.xagent_core_components.print_assistant_thoughts(now_node.data, False)\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n\n            message_sequence = make_message(now_node=now_node,\n                                            max_length=config.max_subtask_chain_length,\n                                            config=config,\n                                            now_dealing_task=now_dealing_task)\n\n            function_call = None\n            if now_node.get_depth() == config.max_subtask_chain_length - 1:\n                function_call = {\"name\": \"subtask_submit\"}\n\n            file_archi, _, = self.xagent_core_components.toolserver_interface.execute_command_client(\n                \"FileSystemEnv_print_filesys_struture\", {\"return_root\": True})\n            file_archi, length = clip_text(file_archi, 1000, clip_end=True)\n\n            human_prompt = \"\"\n            if config.enable_ask_human_for_help:\n                human_prompt = \"- Use 'ask_human_for_help' when you need help, remember to be specific to your requirement to help user to understand your problem.\"\n            else:\n                human_prompt = \"- Human is not available for help. You are not allowed to ask human for help in any form or channel. Solve the problem by yourself. If information is not enough, try your best to use default value.\"\n\n            all_plan = plan_agent.latest_plan.to_json()\n            if config.enable_summary:\n                all_plan = summarize_plan(all_plan)\n            else:\n                all_plan = json.dumps(all_plan, indent=2, ensure_ascii=False)\n\n            new_message, tokens = agent.parse(\n                placeholders={\n                    \"system\": {\n                        \"all_plan\": all_plan\n                    },\n                    \"user\": {\n                        \"workspace_files\": file_archi,\n                        \"subtask_id\": now_dealing_task.get_subtask_id(to_str=True),\n                        \"max_length\": config.max_subtask_chain_length,\n                        \"step_num\": str(now_node.get_depth()+1),\n                        \"human_help_prompt\": human_prompt,\n                    }\n                },\n                arguments=arguments,\n                functions=functions,\n                function_call=function_call,\n                additional_messages=message_sequence,\n                additional_insert_index=-1\n            )\n\n            new_tree_node = agent.message_to_tool_node(new_message)\n\n            print_data = self.xagent_core_components.print_assistant_thoughts(\n                new_tree_node.data, False\n            )\n\n            tool_output, tool_output_status_code, need_for_plan_refine, using_tools = self.xagent_core_components.function_handler.handle_tool_call(\n                new_tree_node)\n            self.need_for_plan_refine = need_for_plan_refine\n            now_attempt_tree.make_father_relation(now_node, new_tree_node)\n            self.xagent_core_components.interaction.insert_data(\n                data={**print_data, \"using_tools\": using_tools}, status=\"inner\", current=task_id, is_include_pictures=self.is_include_pictures(using_tools))\n\n            now_node = new_tree_node\n\n            if tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n\n                self.status = SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER\n                break\n            elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n                break\n\n        self.finish_node = now_node\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**: ReACTChainSearchJSON\n\nNone\n\n****: ",
            "code_start_line": 316,
            "code_end_line": 325,
            "parent": "ReACTChainSearch",
            "have_return": false,
            "code_content": "    def to_json(self):\n        \"\"\"\n        Placeholder function to convert ReACTChainSearch object to JSON.\n\n        Currently not implemented.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "is_include_pictures": {
            "type": "FunctionDef",
            "name": "is_include_pictures",
            "md_content": "**is_include_pictures**png\n\nusing_toolsusing_toolstool_nametool_outputusing_toolstool_nametool_output\n\ntool_name\"PythonNotebook_execute_cell\"tool_outputoutput'file_name'pngTrue\n\ntool_name\"PythonNotebook_execute_cell\"tool_outputpngFalse\n\n****using_toolspng\n\n****using_tools{\"tool_name\": \"PythonNotebook_execute_cell\", \"tool_output\": [{\"file_name\": \"image1.png\"}, {\"file_name\": \"image2.jpg\"}]}True",
            "code_start_line": 327,
            "code_end_line": 338,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def is_include_pictures(self, using_tools):\n        \"\"\"png\n        \"\"\"\n        tool_name = using_tools.get(\"tool_name\", \"\") if isinstance(\n            using_tools, dict) else \"\"\n        tool_output = using_tools.get(\n            \"tool_output\", {}) if isinstance(using_tools, dict) else \"\"\n        if tool_name == \"PythonNotebook_execute_cell\":\n            for output in tool_output:\n                if isinstance(output, dict) and 'file_name' in output:\n                    return True\n        return False\n",
            "name_column": 8
        }
    },
    "XAgent/inner_loop_search_algorithms/__init__.py": {},
    "XAgent/inner_loop_search_algorithms/base_search.py": {
        "BaseSearchMethod": {
            "type": "ClassDef",
            "name": "BaseSearchMethod",
            "md_content": "**BaseSearchMethod**\n\n\n- status (SearchMethodStatusCode): 'DOING''SUCCESS''FAILED'\n- need_for_plan_refine (bool): False\n\n\n- \\_\\_init\\_\\_(): \n- run(): \n- to_json(): json\n- get_finish_node(): \n- status(): \n\n****\n\n****\n```\n: BaseSearchMethod\n```",
            "code_start_line": 6,
            "code_end_line": 48,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseSearchMethod:\n    \"\"\"The base class for all search methods. It defines the common elements and actions that all search \n    methods have.\n    \n    Attributes:\n        status (SearchMethodStatusCode): The status of the search method. It can be 'DOING', 'SUCCESS' or 'FAILED'.\n        need_for_plan_refine (bool): A flag that indicates if the plan needs to be refined. It starts as False.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the search method instance and logs its creation.\"\"\"\n        logger.typewriter_log(\n            f\"Constructing a searching method:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.status: SearchMethodStatusCode = SearchMethodStatusCode.DOING\n        self.need_for_plan_refine: bool = False\n\n    def run(self):\n        \"\"\"A Placeholder function for running the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n\n    def to_json(self):\n        \"\"\"A Placeholder function for creating a json representation of the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n    \n    def get_finish_node(self):\n        \"\"\"A Placeholder function for getting the final node of the search method run.\n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n\n    def status(self):\n        \"\"\"Gets the current status of the search method.\n\n        Returns:\n            SearchMethodStatusCode: The current status of the search method.\n        \"\"\"\n        return self.status\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**\n\nlogger.typewriter_log()\"Constructing a searching method:\"Fore.YELLOWself.__class__.__name__\n\nself.statusSearchMethodStatusCodeDOINGDONEself.need_for_plan_refinebool\n\n****\n- loggerSearchMethodStatusCode\n- self.statusself.need_for_plan_refine",
            "code_start_line": 14,
            "code_end_line": 22,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"Initializes the search method instance and logs its creation.\"\"\"\n        logger.typewriter_log(\n            f\"Constructing a searching method:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.status: SearchMethodStatusCode = SearchMethodStatusCode.DOING\n        self.need_for_plan_refine: bool = False\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "**run**\n\n\n\n****\n- \n- ",
            "code_start_line": 24,
            "code_end_line": 28,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def run(self):\n        \"\"\"A Placeholder function for running the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json**json\n\njson\n\n****\n- \n- json",
            "code_start_line": 30,
            "code_end_line": 34,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def to_json(self):\n        \"\"\"A Placeholder function for creating a json representation of the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "get_finish_node": {
            "type": "FunctionDef",
            "name": "get_finish_node",
            "md_content": "**get_finish_node**\n\npass\n\n****\n- \n- ",
            "code_start_line": 36,
            "code_end_line": 40,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def get_finish_node(self):\n        \"\"\"A Placeholder function for getting the final node of the search method run.\n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "status": {
            "type": "FunctionDef",
            "name": "status",
            "md_content": "**status**\n\nSearchMethodStatusCode\n\n****\n- \n- SearchMethodStatusCode\n\n****\"RUNNING\"\"RUNNING\"",
            "code_start_line": 42,
            "code_end_line": 48,
            "parent": "BaseSearchMethod",
            "have_return": true,
            "code_content": "    def status(self):\n        \"\"\"Gets the current status of the search method.\n\n        Returns:\n            SearchMethodStatusCode: The current status of the search method.\n        \"\"\"\n        return self.status\n",
            "name_column": 8
        }
    },
    "XAgentGen/app.py": {
        "ConstrainedLogitsProcessor": {
            "type": "ClassDef",
            "name": "ConstrainedLogitsProcessor",
            "md_content": "**ConstrainedLogitsProcessor**logits\n\nLogitsProcessor\n\n- `__init__(self, extra_arguments, functions, function_call, tokenizer_path, device=None)`: ConstrainedLogitsProcessorextra_argumentsfunctionsfunction_calltokenizer_pathtokenizerdevicefunction_callNoneFunctionParserdpTransformersTokenizerXTransformersmodeldpcreate_all_functions_modelregex_listgenerate.multi_regexgenerator\n\n- `__call__(self, generated_token_ids: List[int], logits: torch.Tensor) -> torch.Tensor`: token idslogitslogitstoken idstorch.LongTensorlogitsgeneratorcreate_proposaltoken idslogitsmasked_logitsmasked_logits\n\n****tokenizer\n\n****\n\n```python\nmasked_logits\n```",
            "code_start_line": 68,
            "code_end_line": 84,
            "parent": null,
            "have_return": true,
            "code_content": "class ConstrainedLogitsProcessor(LogitsProcessor):\n    def __init__(self, extra_arguments, functions, function_call, tokenizer_path, device=None):\n        if function_call is not None and len(function_call) == 0:\n            function_call = None\n        self.dp = FunctionParser()\n        outline_tokenizer = TransformersTokenizer(tokenizer_path)\n        fake_model = Dict()\n        fake_model.device = device\n        model = XTransformers(fake_model, outline_tokenizer)\n        self.dp.create_all_functions_model(extra_arguments, functions, function_call)\n        regex_list = self.dp.models_to_regex()\n        self.generator = generate.multi_regex(model, regex_list)\n\n    def __call__(self, generated_token_ids: List[int], logits: torch.Tensor) -> torch.Tensor:\n        generated_token_ids = torch.LongTensor(generated_token_ids).view(1, -1).to(logits.device)\n        masked_logits = self.generator.create_proposal(generated_token_ids, logits.view(1, -1))\n        return masked_logits\n",
            "name_column": 6
        },
        "health": {
            "type": "AsyncFunctionDef",
            "name": "health",
            "md_content": "**health**\"ok\"\n\nasync\n\n\"ok\"\"ok\"\n\n****\n\n****\"ok\"",
            "code_start_line": 87,
            "code_end_line": 88,
            "parent": null,
            "have_return": true,
            "code_content": "async def health():\n    return \"ok\"\n",
            "name_column": 10
        },
        "chat_function": {
            "type": "AsyncFunctionDef",
            "name": "chat_function",
            "md_content": "**chat_function**: \n\n\"agentllama\"\"xagentllm\"ConstrainedLogitsProcessorIDtokenizerenginefinal_output499\n\n\n\n****: :\n- ResponseRequest\n- \n\n****:\n```\n{\n    \"model\": \"agentllama\",\n    \"usage\": {\n        \"prompt_tokens\": 10,\n        \"completion_tokens\": 20,\n        \"total_tokens\": 30\n    },\n    \"choices\": [\n        {\n            \"message\": {\n                \"content\": \"\"\n            },\n            \"finish_reason\": \"stop\",\n            \"index\": 0\n        }\n    ]\n}\n```",
            "code_start_line": 92,
            "code_end_line": 170,
            "parent": null,
            "have_return": true,
            "code_content": "async def chat_function(response:Response,request: Request):\n    global engine\n    call_msg = await request.json()\n    model_name = call_msg.get(\"model\",\"\")\n    if model_name != \"agentllama\" and model_name != \"xagentllm\":\n        return {\"model\": \"\", \"choices\": [{'message': {'content': f'bad model {model_name}'}, 'finish_reason': 'error', 'index': -1}]}\n    messages = call_msg.get(\"messages\",None)\n    arguments = call_msg.get(\"arguments\",None)\n    functions = call_msg.get(\"functions\",None)\n    function_call = call_msg.get(\"function_call\",None)\n    task_prompt = format({\n        \"messages\": messages,\n        \"arguments\": arguments,\n        \"functions\": functions,\n        \"function_call\": function_call\n    }, dump_method='json')\n    processor = ConstrainedLogitsProcessor(arguments, functions, function_call, model_path, device='cuda')\n    sampling_params = SamplingParams(\n        temperature=call_msg.get(\"temperature\", 0.8),\n        top_p=call_msg.get(\"top_p\", 1.0),\n        frequency_penalty=call_msg.get(\"frequency_penalty\",0.5),\n        presence_penalty=call_msg.get(\"presence_penalty\", 0.0),\n        repetition_penalty=call_msg.get(\"repetition_penalty\",1.2),\n        max_tokens=call_msg.get(\"max_tokens\", 4000),\n        logits_processors=[processor]\n    )\n    # make request\n    request_id = random_uuid()\n    # tokenize prompt\n    input_ids = tokenizer.encode(task_prompt, return_tensors=\"pt\")\n    prompt_tokens = input_ids.shape[1]  \n    results_generator = engine.generate(task_prompt, sampling_params, request_id)\n    final_output = None\n    async for request_output in results_generator:\n        if await request.is_disconnected():\n            # Abort the request if the client disconnects.\n            await engine.abort(request_id)\n            return Response(status_code=499)\n        final_output = request_output\n    sequence = final_output.outputs[0].text\n    # tokenizer output\n    output_ids = tokenizer.encode(sequence, return_tensors=\"pt\")\n    completion_tokens = output_ids.shape[1]\n    try:\n        sequence = json.loads(sequence)\n        if \"extra_parameters\" in sequence:\n            sequence[\"arguments\"] = sequence[\"extra_parameters\"]\n            sequence.pop(\"extra_parameters\")\n    except Exception as e:\n        res = {\"status\": \"fail\",\"broken_json\":sequence,\"error_message\":str(e)}\n    else:\n        res = {\n            \"status\": \"success\",\n            \"function_res\": sequence,\n            \"usage\":{\n                \"prompt_tokens\": prompt_tokens,\n                \"completion_tokens\": completion_tokens,\n                \"total_tokens\": prompt_tokens + completion_tokens\n            }\n        }\n\n    if res[\"status\"] == \"fail\":\n        response.status_code = 400\n        return {\"model\": \"\", \"choices\": [{'message': {'content': json.dumps(res,ensure_ascii=False)}, 'finish_reason': 'error', 'index': -1}]}\n    \n    response_model = {\n        'model': model_name,\n        'usage': res[\"usage\"],\n        'choices':[\n            {\n                \"message\":{\n                    \"content\": json.dumps(res[\"function_res\"], ensure_ascii=False)\n                },\n                \"finish_reason\":\"stop\",\n                \"index\":0,\n            }\n        ]\n    }\n    return response_model\n",
            "name_column": 10
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Function\n\nfunction_callfunction_callNoneFunctionParserextra_argumentsfunctionsfunction_callcreate_all_functions_modelXTransformers\n\n****extra_argumentsfunctionsfunction_calltokenizer_pathdeviceextra_argumentsfunctionsfunction_calltokenizer_pathdevice",
            "code_start_line": 69,
            "code_end_line": 79,
            "parent": "ConstrainedLogitsProcessor",
            "have_return": false,
            "code_content": "    def __init__(self, extra_arguments, functions, function_call, tokenizer_path, device=None):\n        if function_call is not None and len(function_call) == 0:\n            function_call = None\n        self.dp = FunctionParser()\n        outline_tokenizer = TransformersTokenizer(tokenizer_path)\n        fake_model = Dict()\n        fake_model.device = device\n        model = XTransformers(fake_model, outline_tokenizer)\n        self.dp.create_all_functions_model(extra_arguments, functions, function_call)\n        regex_list = self.dp.models_to_regex()\n        self.generator = generate.multi_regex(model, regex_list)\n",
            "name_column": 8
        },
        "__call__": {
            "type": "FunctionDef",
            "name": "__call__",
            "md_content": "**__call__**IDlogitsmasked_logits\n\nIDtorch.LongTensorview(1, -1)logits\n\nself.generator.create_proposalIDlogitscreate_proposalIDlogitsmasked_logits\n\nmasked_logits\n\n****\n- generated_token_ids\n- logitstorch.Tensor\n\n****\n```python\nmasked_logits = torch.Tensor(...)\nreturn masked_logits\n```",
            "code_start_line": 81,
            "code_end_line": 84,
            "parent": "ConstrainedLogitsProcessor",
            "have_return": true,
            "code_content": "    def __call__(self, generated_token_ids: List[int], logits: torch.Tensor) -> torch.Tensor:\n        generated_token_ids = torch.LongTensor(generated_token_ids).view(1, -1).to(logits.device)\n        masked_logits = self.generator.create_proposal(generated_token_ids, logits.view(1, -1))\n        return masked_logits\n",
            "name_column": 8
        }
    },
    "XAgentGen/xgen/server/datamodel.py": {
        "FuncReq": {
            "type": "ClassDef",
            "name": "FuncReq",
            "md_content": "**FuncReq**\n\n\n\n- `messages`\n- `arguments`\n- `functions`\n- `function_call`\n- `temperature`\n- `max_tokens`token\n- `top_p`top-p\n- `top_k`top-k\n- `repetition_penalty`\n- `model`\n\n****\n- `messages``arguments``functions``function_call`\n- `temperature``max_tokens``top_p``top_k``repetition_penalty`\n- `model`\n\nFuncReq",
            "code_start_line": 4,
            "code_end_line": 15,
            "parent": null,
            "have_return": false,
            "code_content": "class FuncReq(BaseModel):\n    \"\"\"The request for function call\"\"\"\n    messages:Optional[list[dict]]\n    arguments:Optional[dict]\n    functions:Optional[list[dict]]\n    function_call:Optional[dict]\n    temperature:Optional[float]\n    max_tokens:Optional[int]\n    top_p:Optional[float]\n    top_k:Optional[int]\n    repetition_penalty:Optional[float]\n    model:str\n",
            "name_column": 6
        },
        "Usage": {
            "type": "ClassDef",
            "name": "Usage",
            "md_content": "**Usage**\n\nUsage\n\n- prompt_tokens\n- completion_tokens\n- total_tokens\n\nUsageXAgentResponseXAgentResponseXAgentGen/xgen/server/datamodel.pyXAgent\n\n- modelXAgent\n- usageXAgentUsage\n- choicesXAgentXAgentMessage\n\nUsage\n\n- Usage\n- Usage\n- Usage\n\n****Usage",
            "code_start_line": 18,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "class Usage(BaseModel):\n    \"\"\"The record for token consumption\"\"\"\n    prompt_tokens:int\n    completion_tokens:int\n    total_tokens:int\n",
            "name_column": 6
        },
        "FuncResult": {
            "type": "ClassDef",
            "name": "FuncResult",
            "md_content": "**FuncResult**\n\nFuncResultBaseModelargumentsfunction_call\n\n- argumentsarguments\n- function_callfunction_call\n\nFuncResult\n\n****FuncResultargumentsfunction_call",
            "code_start_line": 24,
            "code_end_line": 27,
            "parent": null,
            "have_return": false,
            "code_content": "class FuncResult(BaseModel):\n    \"\"\"The response for function call\"\"\"\n    arguments:Optional[dict]\n    function_call:Optional[dict]\n",
            "name_column": 6
        },
        "Message": {
            "type": "ClassDef",
            "name": "Message",
            "md_content": "**Message**\n\nMessageBaseModelcontentstr\n\n\nXAgentGen/xgen/server/datamodel.py\n\n```python\nclass XAgentMessage(BaseModel):\n    message: Message\n    finish_reason: str\n    index: int\n```\nXAgentMessageMessagemessageXAgentMessagefinish_reasonindex\n\n****\n- Messagecontent\n- XAgentMessageMessage",
            "code_start_line": 29,
            "code_end_line": 30,
            "parent": null,
            "have_return": false,
            "code_content": "class Message(BaseModel):\n    content: str\n",
            "name_column": 6
        },
        "XAgentMessage": {
            "type": "ClassDef",
            "name": "XAgentMessage",
            "md_content": "**XAgentMessage**XAgent\n\nXAgentMessage\n- message: Message\n- finish_reason: str\n- index: int\n\n\nXAgentGen/xgen/server/datamodel.py\n\n```python\nclass XAgentResponse(BaseModel):\n    model: str\n    usage: Optional[Usage]\n    choices: list[XAgentMessage]\n```\n\n****\n- XAgentMessageXAgent\n- message\n- finish_reason\n- index",
            "code_start_line": 32,
            "code_end_line": 35,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentMessage(BaseModel):\n    message:Message\n    finish_reason:str\n    index:int\n",
            "name_column": 6
        },
        "XAgentResponse": {
            "type": "ClassDef",
            "name": "XAgentResponse",
            "md_content": "**XAgentResponse**XAgent\n\nXAgentResponseBaseModel\n\n- model: str\n- usage: Optional[Usage]Usage\n- choices: list[XAgentMessage]XAgentMessageXAgent\n\nXAgentXAgent\n\n****XAgentResponse\n\n- modelstr\n- usageOptional[Usage]\n- choiceslist[XAgentMessage]\n\nXAgentResponseXAgent",
            "code_start_line": 37,
            "code_end_line": 40,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentResponse(BaseModel):\n    model:str\n    usage:Optional[Usage]\n    choices:list[XAgentMessage]\n",
            "name_column": 6
        }
    },
    "XAgentGen/xgen/server/__init__.py": {},
    "XAgentGen/xgen/server/message_formater.py": {
        "custom_yaml_dump": {
            "type": "FunctionDef",
            "name": "custom_yaml_dump",
            "md_content": "**custom_yaml_dump**itemYAML\n\n\n- itemNoneitem\n- itemcustom_yaml_dump\n- itemliteralYAML\n- item\n\n\nXAgentGen/xgen/server/message_formater.py\n\ndef custom_yaml_dump(item):\n    if item is None:\n        return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = custom_yaml_dump(value)\n        return data\n    elif isinstance(item, str) and '\\n' in item:\n        return literal(item)\n    else:\n        return item\n\n\n\ndef yaml_dump(item):\n    f = StringIO()\n    item = custom_yaml_dump(item)\n    yaml_obj.dump(item, f)\n    f.seek(0)\n    string = f.read()\n    return string\n\n\nXAgentGen/xgen/server/message_formater.py\n\n****\n- PythonYAML\n- item\n- itemcustom_yaml_dump\n- itemliteralYAML\n- item\n\n****\n```python\n{\n    'key1': 'value1',\n    'key2': {\n        'subkey1': 'subvalue1',\n        'subkey2': 'subvalue2'\n    },\n    'key3': None\n}\n```",
            "code_start_line": 21,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def custom_yaml_dump(item):\n    if item is None:\n        return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = custom_yaml_dump(value)\n        return data\n    elif isinstance(item, str) and '\\n' in item:\n        return literal(item)\n    else:\n        return item\n",
            "name_column": 4
        },
        "yaml_load": {
            "type": "FunctionDef",
            "name": "yaml_load",
            "md_content": "**yaml_load**YAML\n\nStringIOfyaml_obj.loadfYAMLdatadata\n\nyaml_objloadyaml_objyaml\n\n****\n- YAML\n- yaml_objyaml\n\n****\"key: value\"{'key': 'value'}",
            "code_start_line": 35,
            "code_end_line": 38,
            "parent": null,
            "have_return": true,
            "code_content": "def yaml_load(string):\n    f = StringIO(string)\n    data = yaml_obj.load(f)\n    return data\n",
            "name_column": 4
        },
        "yaml_dump": {
            "type": "FunctionDef",
            "name": "yaml_dump",
            "md_content": "**yaml_dump**itemyaml\n\nStringIOfcustom_yaml_dumpitemyaml_obj.dumpitemfff\n\nXAgentGen/xgen/server/message_formater.py\n\n```python\ndef my_dump(item, dump_method):\n    item = json_try(item)\n    if dump_method == 'yaml':\n        return yaml_dump(item)\n    elif dump_method == 'json':\n        return json.dumps(item, ensure_ascii=False)\n    else:\n        raise NotImplementedError\n```\n\n****\n- itemyaml\n- dump_method'yaml''json'NotImplementedError\n\n****\n```\nname: John\nage: 30\ncity: New York\n```",
            "code_start_line": 41,
            "code_end_line": 47,
            "parent": null,
            "have_return": true,
            "code_content": "def yaml_dump(item):\n    f = StringIO()\n    item = custom_yaml_dump(item)\n    yaml_obj.dump(item, f)\n    f.seek(0)\n    string = f.read()\n    return string\n",
            "name_column": 4
        },
        "message_format": {
            "type": "FunctionDef",
            "name": "message_format",
            "md_content": "**message_format**\n\nmsg\"user\"\"assistant\"NotImplementedError\n\n\nXAgentGen/xgen/server/message_formater.py\n\n```python\ndef format(item, dump_method='yaml'):\n    \"\"\"\n    reformat the request item\n    item: {\"messages\": ..., \"arguments\": ..., \"functions\": ..., \"function_call\": ...}\n    \"\"\"\n    if \"arguments\" in item and item['arguments'] is not None and len(item['arguments']) > 0:\n        arguments_string = \"# Global Arguments\\n\" + my_dump(item[\"arguments\"], \"yaml\")\n    else:\n        arguments_string = \"\"\n    if \"functions\" in item and item['functions'] is not None and len(item['functions']) > 0:\n        functions_string = \"# Functions\\n\" + my_dump(item[\"functions\"], \"yaml\")\n    else:\n        functions_string = \"\"\n    if \"function_call\" in item and item['function_call'] is not None and 'name' in item['function_call']:\n        function_call_string = f\"You need to use {item['function_call']['name']} function.\"\n    else:\n        function_call_string = \"\"\n    system_prefix = (\n        \"Response with following json schemas:\\n\" +\n        f\"{arguments_string}\\n{functions_string}\\n{function_call_string}\"\n    )\n    system_prefix = system_prefix.strip()\n\n    dialog = item[\"messages\"]\n    sys_msg_idx = find_system_msg(dialog)\n    if sys_msg_idx == -1:\n        dialog.insert(0, {\"role\": \"system\", \"content\": system_prefix})\n    else:\n        dialog[sys_msg_idx][\"content\"] += \"\\n\" + system_prefix\n\n    dialog = merge_messages(dialog)\n    input_string = \"\".join([message_format(msg) for msg in dialog])\n    return input_string\n```\n[]\n[XAgentGen/xgen/server/message_formater.py]\n\n****\n- msg\"role\"\"content\"\n- \"user\"\"assistant\"NotImplementedError\n\n****\n```\n# Global Arguments\n- argument1: value1\n- argument2: value2\n\n# Functions\n- function1:\n    - argument1: value1\n    - argument2: value2\n\nYou need to use function1 function.\n\nUser: [BOS]  [E_INST] \nAssistant: [EOS]\n```\n",
            "code_start_line": 50,
            "code_end_line": 58,
            "parent": null,
            "have_return": true,
            "code_content": "def message_format(msg):\n    \"\"\"https://github.com/facebookresearch/llama/blob/main/llama/generation.py#L343\"\"\"\n    if msg[\"role\"] == \"user\":\n        string = f\"{BOS}{B_INST} {msg['content'].strip()} {E_INST} \"\n    elif msg[\"role\"] == \"assistant\":\n        string = f\"{msg['content'].strip()}{EOS}\"\n    else:\n        raise NotImplementedError\n    return string\n",
            "name_column": 4
        },
        "merge_messages": {
            "type": "FunctionDef",
            "name": "merge_messages",
            "md_content": "**merge_messages**\n\n\n\n\n\n\n\n****\n- messages\n- \n\n****\n```\n[\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"user\", \"content\": \"How are you?\"},\n    {\"role\": \"system\", \"content\": \"I'm fine, thank you.\"}\n]\n```\n\n```\n[\n    {\"role\": \"user\", \"content\": \"Hello\\nHow are you?\"},\n    {\"role\": \"user\", \"content\": \"I'm fine, thank you.\"}\n]\n```",
            "code_start_line": 61,
            "code_end_line": 79,
            "parent": null,
            "have_return": true,
            "code_content": "def merge_messages(messages):\n    new_messages = []\n    pre_role = \"\"\n    for msg in messages:\n        # system message should be merged with user message\n        # reference: https://github.com/facebookresearch/llama/blob/main/llama/generation.py#L324\n        if msg['role'] == 'system':\n            role = 'user'\n            content = B_SYS + msg[\"content\"] + E_SYS\n        else:\n            role = msg['role']\n            content = msg['content']\n\n        if role == pre_role:\n            new_messages[-1][\"content\"] += \"\\n\" + content\n        else:\n            new_messages.append({'role': role, 'content': content})\n        pre_role = role\n    return new_messages\n",
            "name_column": 4
        },
        "find_system_msg": {
            "type": "FunctionDef",
            "name": "find_system_msg",
            "md_content": "**find_system_msg**: \n\n\"role\"\"system\"idxidx\n\n\nXAgentGen/xgen/server/message_formater.py\n\n```python\ndef format(item, dump_method='yaml'):\n    \"\"\"\n    \n    item: {\"messages\": ..., \"arguments\": ..., \"functions\": ..., \"function_call\": ...}\n    \"\"\"\n    if \"arguments\" in item and item['arguments'] is not None and len(item['arguments']) > 0:\n        arguments_string = \"# \\n\" + my_dump(item[\"arguments\"], \"yaml\")\n    else:\n        arguments_string = \"\"\n    if \"functions\" in item and item['functions'] is not None and len(item['functions']) > 0:\n        functions_string = \"# \\n\" + my_dump(item[\"functions\"], \"yaml\")\n    else:\n        functions_string = \"\"\n    if \"function_call\" in item and item['function_call'] is not None and 'name' in item['function_call']:\n        function_call_string = f\" {item['function_call']['name']} \"\n    else:\n        function_call_string = \"\"\n    system_prefix = (\n        \"JSON\\n\" +\n        f\"{arguments_string}\\n{functions_string}\\n{function_call_string}\"\n    )\n    system_prefix = system_prefix.strip()\n\n    dialog = item[\"messages\"]\n    sys_msg_idx = find_system_msg(dialog)\n    if sys_msg_idx == -1:\n        dialog.insert(0, {\"role\": \"system\", \"content\": system_prefix})\n    else:\n        dialog[sys_msg_idx][\"content\"] += \"\\n\" + system_prefix\n\n    dialog = merge_messages(dialog)\n    input_string = \"\".join([message_format(msg) for msg in dialog])\n    return input_string\n```\n[]\n[XAgentGen/xgen/server/message_formater.py]\n\n**find_system_msg**\n\n\"role\"\"system\"idxidx\n\n****-1\n\n****\n```python\nmessages = [\n    {\"role\": \"user\", \"content\": \"\"},\n    {\"role\": \"system\", \"content\": \"1\"},\n    {\"role\": \"user\", \"content\": \"\"},\n    {\"role\": \"system\", \"content\": \"2\"},\n    {\"role\": \"user\", \"content\": \"\"}\n]\n```\nfind_system_msg(messages)222",
            "code_start_line": 82,
            "code_end_line": 87,
            "parent": null,
            "have_return": true,
            "code_content": "def find_system_msg(messages):\n    idx = -1\n    for i, msg in enumerate(messages):\n        if msg[\"role\"] == \"system\":\n            idx = i\n    return idx\n",
            "name_column": 4
        },
        "my_dump": {
            "type": "FunctionDef",
            "name": "my_dump",
            "md_content": "**my_dump**dumpitem\n\n\n- item\n- dump_method'yaml''json'\n\nitemjson_tryJSONdump_methodyaml_dumpjson.dumpsitemdump_method'yaml''json'NotImplementedError\n\n****dump_method'yaml''json'\n\n****item{\"name\": \"John\", \"age\": 25}dump_method'json''{\"name\": \"John\", \"age\": 25}'",
            "code_start_line": 90,
            "code_end_line": 97,
            "parent": null,
            "have_return": true,
            "code_content": "def my_dump(item, dump_method):\n    item = json_try(item)\n    if dump_method == 'yaml':\n        return yaml_dump(item)\n    elif dump_method == 'json':\n        return json.dumps(item, ensure_ascii=False)\n    else:\n        raise NotImplementedError\n",
            "name_column": 4
        },
        "json_try": {
            "type": "FunctionDef",
            "name": "json_try",
            "md_content": "**json_try**: itemJSONitemJSONJSON\n\n\nXAgentGen/xgen/server/message_formater.py\n\n```python\ndef my_dump(item, dump_method):\n    item = json_try(item)\n    if dump_method == 'yaml':\n        return yaml_dump(item)\n    elif dump_method == 'json':\n        return json.dumps(item, ensure_ascii=False)\n    else:\n        raise NotImplementedError\n```\n[]\n\n```python\ndef json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n```\n[]\n\n```python\ndef json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n```\n[]\n\n```python\ndef json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n```\n[]\n[End of XAgentGen/xgen/server/message_formater.py]\n\n****: \n- itemJSON\n- itemJSONitem\n- JSON\n\n****: \n```python\n{\n    \"key1\": \"value1\",\n    \"key2\": {\n        \"nested_key\": \"nested_value\"\n    },\n    \"key3\": [\n        \"item1\",\n        \"item2\"\n    ]\n}\n```",
            "code_start_line": 100,
            "code_end_line": 121,
            "parent": null,
            "have_return": true,
            "code_content": "def json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n",
            "name_column": 4
        },
        "my_load": {
            "type": "FunctionDef",
            "name": "my_load",
            "md_content": "**my_load**dump\n\nstringdump_methoddumpdump_methoddump_method'yaml'yaml_loadYAMLdump_method'json'json.loadsJSONdump_method'yaml''json'NotImplementedError\n\n****\n- dump\n- dump_method'yaml''json'\n\n****'{\"name\": \"John\", \"age\": 30}'dump_method'json'\n{\n  \"name\": \"John\",\n  \"age\": 30\n}",
            "code_start_line": 124,
            "code_end_line": 130,
            "parent": null,
            "have_return": true,
            "code_content": "def my_load(string, dump_method):\n    if dump_method == 'yaml':\n        return yaml_load(string)\n    elif dump_method == 'json':\n        return json.loads(string)\n    else:\n        raise NotImplementedError\n",
            "name_column": 4
        },
        "format": {
            "type": "FunctionDef",
            "name": "format",
            "md_content": "**format**\n\nitemdump_methoditemdump_method'yaml'\n\nitemargumentsfunctionsfunction_call\n\nsystem_prefixdialogsystem message\n\n\n\n****\n- item\n- dump_method'yaml'\n\n****item{\"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}, {\"role\": \"assistant\", \"content\": \"How can I help you?\"}], \"arguments\": {\"arg1\": \"value1\", \"arg2\": \"value2\"}, \"functions\": {\"func1\": \"value1\", \"func2\": \"value2\"}, \"function_call\": {\"name\": \"my_function\"}}\n```\nHello\nHow can I help you?\n# Global Arguments\narg1: value1\narg2: value2\n# Functions\nfunc1: value1\nfunc2: value2\nYou need to use my_function function.\n```",
            "code_start_line": 133,
            "code_end_line": 165,
            "parent": null,
            "have_return": true,
            "code_content": "def format(item, dump_method='yaml'):\n    \"\"\"\n    reformat the request item\n    item: {\"messages\": ..., \"arguments\": ..., \"functions\": ..., \"function_call\": ...}\n    \"\"\"\n    if \"arguments\" in item and item['arguments'] is not None and len(item['arguments']) > 0:\n        arguments_string = \"# Global Arguments\\n\" + my_dump(item[\"arguments\"], \"yaml\")\n    else:\n        arguments_string = \"\"\n    if \"functions\" in item and item['functions'] is not None and len(item['functions']) > 0:\n        functions_string = \"# Functions\\n\" + my_dump(item[\"functions\"], \"yaml\")\n    else:\n        functions_string = \"\"\n    if \"function_call\" in item and item['function_call'] is not None and 'name' in item['function_call']:\n        function_call_string = f\"You need to use {item['function_call']['name']} function.\"\n    else:\n        function_call_string = \"\"\n    system_prefix = (\n        \"Response with following json schemas:\\n\" +\n        f\"{arguments_string}\\n{functions_string}\\n{function_call_string}\"\n    )\n    system_prefix = system_prefix.strip()\n\n    dialog = item[\"messages\"]\n    sys_msg_idx = find_system_msg(dialog)\n    if sys_msg_idx == -1:\n        dialog.insert(0, {\"role\": \"system\", \"content\": system_prefix})\n    else:\n        dialog[sys_msg_idx][\"content\"] += \"\\n\" + system_prefix\n\n    dialog = merge_messages(dialog)\n    input_string = \"\".join([message_format(msg) for msg in dialog])\n    return input_string\n",
            "name_column": 4
        }
    },
    "XAgentGen/xgen/models/transformers.py": {
        "prepare_logits_processor": {
            "type": "FunctionDef",
            "name": "prepare_logits_processor",
            "md_content": "**prepare_logits_processor**logits\n\n\n- temperature\n- repetition_penalty\n- top_pp\n- top_kk\n\nLogitsProcessorListlogitslogits\n\n- temperature1e-51.0TemperatureLogitsWarper\n- repetition_penalty1.0RepetitionPenaltyLogitsProcessor\n- top_p1e-81.0TopPLogitsWarper\n- top_k0TopKLogitsWarper\n\n\n\n****\n- temperature1e-51.0\n- repetition_penalty1.0\n- top_p1e-81.0\n- top_k0\n\n****\n\n```python\nprocessor_list = LogitsProcessorList()\nif temperature >= 1e-5 and temperature != 1.0:\n    processor_list.append(TemperatureLogitsWarper(temperature))\nif repetition_penalty > 1.0:\n    processor_list.append(RepetitionPenaltyLogitsProcessor(repetition_penalty))\nif 1e-8 <= top_p < 1.0:\n    processor_list.append(TopPLogitsWarper(top_p))\nif top_k > 0:\n    processor_list.append(TopKLogitsWarper(top_k))\nreturn processor_list\n```",
            "code_start_line": 17,
            "code_end_line": 31,
            "parent": null,
            "have_return": true,
            "code_content": "def prepare_logits_processor(\n    temperature: float, repetition_penalty: float, top_p: float, top_k: int\n) -> LogitsProcessorList:\n    \"\"\"generate the logits processor with params\"\"\"\n    processor_list = LogitsProcessorList()\n    # TemperatureLogitsWarper doesn't accept 0.0, 1.0 makes it a no-op so we skip two cases.\n    if temperature >= 1e-5 and temperature != 1.0:\n        processor_list.append(TemperatureLogitsWarper(temperature))\n    if repetition_penalty > 1.0:\n        processor_list.append(RepetitionPenaltyLogitsProcessor(repetition_penalty))\n    if 1e-8 <= top_p < 1.0:\n        processor_list.append(TopPLogitsWarper(top_p))\n    if top_k > 0:\n        processor_list.append(TopKLogitsWarper(top_k))\n    return processor_list\n",
            "name_column": 4
        },
        "XTransformers": {
            "type": "ClassDef",
            "name": "XTransformers",
            "md_content": "**XTransformers**: Transformers\n\nTransformers\n\n- **\\_\\_init\\_\\_**: XTransformers\\_\\_init\\_\\_logits_processorNone\n\n- **reset**: prompt_tokenscompletion_tokens0\n\n- **add_logits_processor**: logitsgenerate_kwargsgenerate_kwargslogits_processorlogits_processor\n\n- **forward**: input_idsattention_maskforwardtokenlogitslogits_processorinput_idstokenlogitslogits_processortokenlogits\n\n****: XTransformersresetadd_logits_processorlogitsforward\n\n****:\n```\ntokenlogits: tensor([[ 0.1234, -0.5678,  0.9876, ...]])\n: (tensor([[...]]), tensor([[...]]), ...)\n```",
            "code_start_line": 33,
            "code_end_line": 71,
            "parent": null,
            "have_return": true,
            "code_content": "class XTransformers(Transformers):\n    def __init__(\n        self,\n        model: \"PreTrainedModel\",\n        tokenizer: \"PreTrainedTokenizer\",\n    ):\n        super().__init__(model,tokenizer)\n        self.logits_processor=None\n    \n    def reset(self):\n        self.tokenizer.prompt_tokens = 0\n        self.tokenizer.completion_tokens = 0\n\n    def add_logits_processor(self,generate_kwargs:dict={}):\n\n        temperature = float(generate_kwargs.get(\"temperature\", 1.0))\n        repetition_penalty = float(generate_kwargs.get(\"repetition_penalty\", 1.0))\n        top_p = float(generate_kwargs.get(\"top_p\", 1.0))\n        top_k = int(generate_kwargs.get(\"top_k\", -1))  # -1 means disable\n\n        logits_processor = prepare_logits_processor(\n            temperature, repetition_penalty, top_p, top_k\n        )\n\n        self.logits_processor = logits_processor\n\n    def forward(\n        self,\n        input_ids: torch.LongTensor,\n        attention_mask: torch.LongTensor,\n        past_key_values: Optional[Tuple] = None,\n    ) -> Tuple[torch.FloatTensor, Optional[KVCacheType]]:\n        \n        next_token_logits, output_past_key_values = super().forward(input_ids,attention_mask,past_key_values)\n        \n        if self.logits_processor:\n            next_token_logits = self.logits_processor(input_ids,next_token_logits)\n       \n        return next_token_logits, output_past_key_values\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Function\n\n\n- model: \"PreTrainedModel\"\n- tokenizer: \"PreTrainedTokenizer\"\n\n__init__modeltokenizer\n\nlogits_processorNone\n\n****\n- model\n- tokenizer",
            "code_start_line": 34,
            "code_end_line": 40,
            "parent": "XTransformers",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        model: \"PreTrainedModel\",\n        tokenizer: \"PreTrainedTokenizer\",\n    ):\n        super().__init__(model,tokenizer)\n        self.logits_processor=None\n",
            "name_column": 8
        },
        "reset": {
            "type": "FunctionDef",
            "name": "reset",
            "md_content": "**reset**tokenizerprompt_tokenscompletion_tokens0\n\ntokenizerprompt_tokenscompletion_tokens0tokenizerprompt_tokenstokencompletion_tokenstoken0\n\n****\n- tokenizer\n- prompt_tokenscompletion_tokens",
            "code_start_line": 42,
            "code_end_line": 44,
            "parent": "XTransformers",
            "have_return": false,
            "code_content": "    def reset(self):\n        self.tokenizer.prompt_tokens = 0\n        self.tokenizer.completion_tokens = 0\n",
            "name_column": 8
        },
        "add_logits_processor": {
            "type": "FunctionDef",
            "name": "add_logits_processor",
            "md_content": "**add_logits_processor**logits\n\ngenerate_kwargstemperaturerepetition_penaltytop_ptop_kprepare_logits_processorlogitslogitsself.logits_processor\n\n\nXAgentGen/xgen/parser/function_parser.py\n\n```\ndef create_generator(self,model:models.XTransformers,function_info:Dict[str,Any],generate_params:Dict = {}):\n    \"\"\"\n    @param: model: transformer\n    @param: functions: \n    @param: extra_argument: json\n    @param: function_call: json\n    @param: generate_params: \n    @return: \n    \"\"\"    \n    extra_arguments = function_info.get(\"arguments\",None)\n    functions = function_info.get(\"functions\",None)\n    function_call = function_info.get(\"function_call\",None)\n    self.create_all_functions_model(extra_arguments,functions,function_call) \n    regex_list = self.models_to_regex()\n    self.model = model\n    # temperature and so on\n    self.model.add_logits_processor(generate_params)\n    self.generator = generate.multi_regex(self.model, regex_list,generate_params.get(\"max_tokens\"))\n    return self.generator\n```\n[]\n[XAgentGen/xgen/parser/function_parser.py]\n\n****\n- generate_kwargstemperaturerepetition_penaltytop_ptop_k\n- add_logits_processorlogits",
            "code_start_line": 46,
            "code_end_line": 57,
            "parent": "XTransformers",
            "have_return": false,
            "code_content": "    def add_logits_processor(self,generate_kwargs:dict={}):\n\n        temperature = float(generate_kwargs.get(\"temperature\", 1.0))\n        repetition_penalty = float(generate_kwargs.get(\"repetition_penalty\", 1.0))\n        top_p = float(generate_kwargs.get(\"top_p\", 1.0))\n        top_k = int(generate_kwargs.get(\"top_k\", -1))  # -1 means disable\n\n        logits_processor = prepare_logits_processor(\n            temperature, repetition_penalty, top_p, top_k\n        )\n\n        self.logits_processor = logits_processor\n",
            "name_column": 8
        },
        "forward": {
            "type": "FunctionDef",
            "name": "forward",
            "md_content": "**forward**\n\n\n- input_ids: torch.LongTensortoken\n- attention_mask: torch.LongTensorattention mask\n- past_key_values: None\n\n\n- next_token_logits: torch.FloatTensortokenlogits\n- output_past_key_values: None\n\nforwardinput_idsattention_maskpast_key_valuesnext_token_logitsoutput_past_key_values\n\nlogits_processorlogits_processornext_token_logits\n\nnext_token_logitsoutput_past_key_values\n\n****\n\n****\n\n\n- Markdown\n- ",
            "code_start_line": 59,
            "code_end_line": 71,
            "parent": "XTransformers",
            "have_return": true,
            "code_content": "    def forward(\n        self,\n        input_ids: torch.LongTensor,\n        attention_mask: torch.LongTensor,\n        past_key_values: Optional[Tuple] = None,\n    ) -> Tuple[torch.FloatTensor, Optional[KVCacheType]]:\n        \n        next_token_logits, output_past_key_values = super().forward(input_ids,attention_mask,past_key_values)\n        \n        if self.logits_processor:\n            next_token_logits = self.logits_processor(input_ids,next_token_logits)\n       \n        return next_token_logits, output_past_key_values\n",
            "name_column": 8
        }
    },
    "XAgentGen/xgen/models/__init__.py": {},
    "XAgentGen/xgen/parser/function_parser.py": {
        "FunctionParser": {
            "type": "ClassDef",
            "name": "FunctionParser",
            "md_content": "**FunctionParser**FunctionParserPydantic\n\nFunctionParser\n\n- `__init__(self) -> None`functionCallModelsregex_strs\n\n- `create_total_model(cls)`TotalModelTotalModel\n\n- `create_function_call_model(cls)`FunctionCallModelFunctionCallModel\n\n- `add_property(cls, model, prop_name, prop_type, required, default=None, constrain=None, multi_type=False)`fields\n\n- `pre_process(cls, prop: Dict[str, Any])`\n\n- `create_list_item_model(cls, prop_json: Dict[str, Any], property_name: str) -> Union[BaseModel, str]`Pydantic\n\n- `create_multi_types(cls, property_name: str, type_list: List[Any]) -> List[Any]`union\n\n- `create_object_model(cls, object_item: Dict[str, Any], object_name: str, object_model: BaseModel = None) -> BaseModel`Pydantic\n\n- `add_function_model(cls, extra_arguments_json: Dict[str, Any], function_json: Dict[str, Any] = None)`Pydantic\n\n- `create_all_functions_model(self, extra_arguments: Dict[str, Any] = None, functions: list = None, function_call: Dict[str, Any] = None)`Pydantic\n\n- `models_to_regex(self)`\n\n- `context_ids_next_ids(self, context_ids: List[int])`\n\n- `post_process(self, schema)`\n\n- `create_generator(self, model: models.XTransformers, function_info: Dict[str, Any], generate_params: Dict = {})`\n\n- `check(self, call_info: str)`\n\n****FunctionParser\n- `create_all_functions_model`\n- `create_generator`\n- `check`\n\n****\n```python\n# \ndp = FunctionParser()\ndp.create_all_functions_model(extra_arguments, functions, function_call)\nregex_list = dp.models_to_regex()\nmodel = XTransformers(fake_model, outline_tokenizer)\ngenerator = generate.multi_regex(model, regex_list)\n```\n",
            "code_start_line": 36,
            "code_end_line": 370,
            "parent": null,
            "have_return": true,
            "code_content": "class FunctionParser:\n\n        def __init__(self) -> None:\n                self.functionCallModels = []\n                self.regex_strs = []\n        \n        @classmethod\n        def create_total_model(cls):\n                class TotalModel(BaseModel):\n                        pass\n                return TotalModel\n\n        @classmethod\n        def create_function_call_model(cls):\n                class FunctionCallModel(BaseModel):\n                        name:str\n                return FunctionCallModel\n        \n        @classmethod\n        def add_property(cls,model, prop_name, prop_type, required, default=None, constrain=None,multi_type = False):\n                field_info = model.__fields__\n                field_info[prop_name] = ModelField(name=prop_name,type_=prop_type,class_validators={},model_config=model.__config__,required=required,default=default)\n                if constrain is not None:\n                        field_info[prop_name].field_info.ge = constrain.get('minimum',None)\n                        field_info[prop_name].field_info.le = constrain.get('maximum',None)\n                        field_info[prop_name].field_info.min_length = constrain.get('minLength',None)\n                        field_info[prop_name].field_info.max_length = constrain.get('maxLength',None)\n                        field_info[prop_name].field_info.regex = constrain.get('regex',None)\n                \n                setattr(model, prop_name, field_info)\n\n                if required:\n                        setattr(model, f\"validate_{prop_name}\", validator(prop_name, pre=True, allow_reuse=True)(lambda v: v))\n                \n                model.__fields__ = field_info\n\n                return model\n        \n        @classmethod\n        def pre_process(cls,prop:Dict[str,Any]):\n                new_prop = prop\n                if type2type.get(prop[\"type\"],\"other type\") == list:\n                        item_type = type2type[prop[\"items\"][\"type\"]]\n                        if item_type == int:\n                                new_prop[\"type\"] = \"List[int]\"\n                        elif item_type == str:\n                                new_prop[\"type\"] = \"List[str]\"\n                        elif item_type == bool:\n                                new_prop[\"type\"] = \"List[bool]\"\n                        elif item_type == None:\n                                new_prop[\"type\"] = \"List[null]\"\n\n                return new_prop\n        \n        @classmethod\n        def create_list_item_model(cls,prop_json:Dict[str,Any],property_name:str)->Union[BaseModel,str]:\n                \"\"\"\n                @param: prop: the property which is a array\n                @param: prop_name: the name of array property\n                @param: object_model: do the inplace replace for pydantic model\n                @return: the pydantic model inherited from BaseModel or a str which describe the List[type]\n                \"\"\"\n                item = None\n                property_json = cls.pre_process(prop_json)\n                if property_json[\"items\"].get(\"type\",\"no type\") == \"object\":\n                        item = cls.create_object_model(property_json[\"items\"],property_name+\"_item\")\n                elif property_json[\"items\"].get(\"type\",\"no type\") == \"array\":\n                        item = cls.create_list_item_model(property_json[\"items\"],property_name+\"_arrayItem\")\n                        item = List[item]\n                else:\n                        item = type2type.get(property_json[\"items\"][\"type\"],str)\n                return item\n        @classmethod\n        def create_multi_types(cls,property_name:str,type_list:List[Any])->List[Any]:\n                \"\"\"\n                @param: type_list: a list of types of prop\n                @return: the list of available type(to be union later)\n                \"\"\"\n                new_type_list = []\n                for i,tp in enumerate(type_list):\n                        if not isinstance(tp,dict):\n                                new_type_list.append(type2type.get(tp,str))\n                        elif \"type\" not in tp.keys():\n                                continue\n                        elif tp[\"type\"] == \"object\":\n                                object_type = cls.create_object_model(tp,property_name + f\"_{i}_type_object\") \n                                new_type_list.append(object_type)\n                        elif tp[\"type\"] == \"array\":\n                                array_type = cls.create_list_item_model(tp,property_name + f\"_{i}_type_array\")\n                                new_type_list.append(List[array_type])\n\n                return new_type_list        \n\n\n        @classmethod\n        def create_object_model(cls,object_item:Dict[str,Any],object_name:str,object_model:BaseModel=None)->BaseModel:\n                \"\"\"\n                @param: object_item: the item which is a object(function[parameters]propertyextra_argument[parameters])\n                @param: object_name: the name of object item(for property loc)\n                @return: the object model inherited from BaseModel\n                \"\"\"\n                if object_model is None:\n                        object_model = create_model(object_name,__base__=BaseModel)\n                assert \"properties\" in object_item.keys()\n\n                properties = object_item[\"properties\"]\n                for property_name in properties.keys():\n                        property_json = properties[property_name]\n\n                        if isinstance(property_json[\"type\"],list):\n                                multi_type = cls.create_multi_types(property_name,property_json[\"type\"])\n                                if len(multi_type) > 1:\n                                        multi_type = Union[tuple(multi_type)] # type: ignore\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                                else: \n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=True,default=None)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,multi_type,required=True)\n                        elif \"enum\" in property_json.keys():\n                                enum_name = property_name\n                                enum_values = {value: value for value in property_json['enum']}\n                                enumModel = Enum(enum_name, enum_values)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False)\n\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n                        elif property_json[\"type\"] == \"array\":\n                                item = cls.create_list_item_model(property_json,property_name)\n                                if item is not None:\n                                        if \"required\" in object_item.keys():\n                                                if property_name not in object_item[\"required\"]:\n                                                        if \"default\" in property_json.keys():\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                        else:\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n                                        else:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n\n                        elif property_json[\"type\"] == \"object\" and \"properties\" in property_json.keys():\n                                object_property_model = cls.create_object_model(property_json,property_name)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n\n                        else:   \n                                constrain = \\\n                                {\n                                        \"maxLength\":property_json.get(\"maxLength\",None),\n                                        \"minLength\":property_json.get(\"minLength\",None),\n                                        \"maximum\":property_json.get(\"maximum\",None),\n                                        \"minimum\":property_json.get(\"minimum\",None)        \n                                }\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,constrain=constrain)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,default=None,constrain=constrain)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,constrain=constrain)\n\n                return object_model\n\n        @classmethod\n        def add_function_model(cls,extra_arguments_json:Dict[str,Any],function_json:Dict[str,Any]=None):\n                \"\"\"\n                @param: function: the single function to generate a pydantic model\n                @param: extra_arguments: the extra arguments\n                \"\"\"\n                extra_arguments = copy.deepcopy(extra_arguments_json)\n                extra_argumentModel = None\n                if extra_arguments is not None and \"properties\" in extra_arguments.keys():  \n                        extra_argumentModel = cls.create_object_model(extra_arguments,\"ExtraArgumentModel\",extra_argumentModel)\n                \n                functionCallModel = None\n                if function_json is not None:\n                        function = copy.deepcopy(function_json)\n                        parameters = function[\"parameters\"]\n                        if \"properties\" in parameters.keys():\n                                argumentModel = cls.create_object_model(parameters,\"ArgumentModel\") \n\n                        functionCallModel = cls.create_function_call_model()\n                        functionCallModel = cls.add_property(functionCallModel,\"name\",str,required=True,constrain={\"regex\":function[\"name\"]})\n                        if argumentModel is not None:\n                                functionCallModel = cls.add_property(functionCallModel,\"arguments\",argumentModel,required=True)\n                totalModel = cls.create_total_model()\n                if extra_argumentModel is not None:\n                        totalModel = cls.add_property(totalModel,\"arguments\",extra_argumentModel,required=True)\n                if functionCallModel is not None:\n                        totalModel = cls.add_property(totalModel,\"function_call\",functionCallModel,required=True)\n                return totalModel      \n          \n        \n        def create_all_functions_model(self,extra_arguments:Dict[str,Any]=None,functions:list=None,function_call:Dict[str,Any]=None):\n                \"\"\"\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call\n                \"\"\" \n                self.functionCallModels = []\n                if  functions is None or len(functions)==0:\n                        self.functionCallModels.append(self.add_function_model(extra_arguments))\n                        return\n                for function in functions:\n                        if function_call is not None and \"name\" in function_call.keys():\n                                if  function_call[\"name\"] == function[\"name\"]:\n                                        self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n                                        return\n                        else:\n                                self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n\n\n        def models_to_regex(self):\n                self.regex_strs = []\n                for function in self.functionCallModels:\n                    if hasattr(function, \"model_json_schema\"):\n                        json_schema = function.model_json_schema()\n                    else: \n                        json_schema = function.schema()\n\n                    json_schema = self.post_process(json_schema)\n                    schema = json.dumps(json_schema)\n                    self.regex_strs.append(build_regex_from_object(schema))\n                return self.regex_strs\n\n\n        def context_ids_next_ids(self,context_ids:List[int]):\n                \"\"\"\n                @param: context_ids: the ids of generated tokens (list[list[int]])\n                @return: valid_ids: the valid ids of next token (list[list[int]])\n                \"\"\"\n                # you should empty the pstates every times except you input all context in order)\n                self.generator.pstates = []\n                import traceback\n                logits = torch.ones(len(self.model.tokenizer.vocabulary)).to(self.model.device)\n                # masked_logits \n                try:\n                        masked_logits = self.generator.create_proposal(torch.tensor([context_ids]).to(self.model.device), logits)\n                        # valid indexes\n                        non_inf_indices = torch.nonzero(masked_logits != -math.inf).squeeze(dim=1)\n                        non_inf_indices = non_inf_indices[:,1]\n                        non_inf_indices = non_inf_indices.tolist()\n                except Exception as e:\n                        print(\"no available path\")\n                        non_inf_indices = []\n                return non_inf_indices\n\n\n        def post_process(self,schema):   \n                com_schema = schema\n                if \"definitions\" in com_schema.keys():\n                        for prop in com_schema[\"definitions\"].keys():\n                                if \"type\" not in com_schema[\"definitions\"][prop].keys():\n                                        com_schema[\"definitions\"][prop][\"type\"]=\"string\"\n                \n                return com_schema\n\n        def create_generator(self,model:models.XTransformers,function_info:Dict[str,Any],generate_params:Dict = {}):\n                \"\"\"\n                @param: model: the transformer model\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call name\n                @param: generate_params: a dict of inference constraint arguments\n                @return: create a generator for guided generate\n                \"\"\"    \n                extra_arguments = function_info.get(\"arguments\",None)\n                functions = function_info.get(\"functions\",None)\n                function_call = function_info.get(\"function_call\",None)\n                self.create_all_functions_model(extra_arguments,functions,function_call) \n                regex_list = self.models_to_regex()\n                self.model = model\n                # temperature and so on\n                self.model.add_logits_processor(generate_params)\n                self.generator = generate.multi_regex(self.model, regex_list,generate_params.get(\"max_tokens\"))\n                return self.generator\n        \n        def check(self,call_info:str):\n                \"\"\"\n                @param: function: the dynamic BaseModel generated for specified function\n                \"\"\"\n                try:\n                        call_info_json = json.loads(call_info)\n                except Exception:\n                        return False\n                if \"name\" not in call_info_json.keys():\n                        return False\n                if \"arguments\" not in call_info_json.keys():\n                        return False\n                try:\n                        self.functionCallModel.model_validate_json(call_info)\n                except Exception:\n                        return False\n                return True\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**Function\n\n\n- functionCallModels\n- regex_strs\n\n\n\n****\n- Function\n- ",
            "code_start_line": 38,
            "code_end_line": 40,
            "parent": "FunctionParser",
            "have_return": false,
            "code_content": "        def __init__(self) -> None:\n                self.functionCallModels = []\n                self.regex_strs = []\n",
            "name_column": 12
        },
        "create_total_model": {
            "type": "FunctionDef",
            "name": "create_total_model",
            "md_content": "**create_total_model**TotalModel\n\ncreate_total_modelTotalModelBaseModelTotalModel\n\n****TotalModel\n\n****\n\n```\nclass TotalModel(BaseModel):\n    pass\n```\n\nTotalModelBaseModel",
            "code_start_line": 43,
            "code_end_line": 46,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_total_model(cls):\n                class TotalModel(BaseModel):\n                        pass\n                return TotalModel\n",
            "name_column": 12
        },
        "create_function_call_model": {
            "type": "FunctionDef",
            "name": "create_function_call_model",
            "md_content": "**create_function_call_model**FunctionCallModel\n\nXAgentGen/xgen/parser/function_parser.pycreate_function_call_model\n```python\ndef create_function_call_model(cls):\n    class FunctionCallModel(BaseModel):\n        name:str\n    return FunctionCallModel\n```\n\n****\ncreate_function_call_modelclsFunctionCallModel\n\nBaseModelFunctionCallModelnamestr\n\nFunctionCallModel\n\n****FunctionCallModel\n\n****\n```python\nclass FunctionCallModel(BaseModel):\n    name: str\n```\nFunctionCallModelnamestr",
            "code_start_line": 49,
            "code_end_line": 52,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_function_call_model(cls):\n                class FunctionCallModel(BaseModel):\n                        name:str\n                return FunctionCallModel\n",
            "name_column": 12
        },
        "add_property": {
            "type": "FunctionDef",
            "name": "add_property",
            "md_content": "**add_property**\n\n\n- cls\n- model\n- prop_name\n- prop_type\n- required\n- default\n- constrain\n- multi_type\n\n__fields__ModelFieldModelFieldModelField\n\nsetattrvalidate_{prop_name}__fields__\n\n\n\n****\n- __fields__\n- validate_{prop_name}\n\n****modeladd_propertyprop_nameadd_propertymodel__fields__",
            "code_start_line": 55,
            "code_end_line": 72,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def add_property(cls,model, prop_name, prop_type, required, default=None, constrain=None,multi_type = False):\n                field_info = model.__fields__\n                field_info[prop_name] = ModelField(name=prop_name,type_=prop_type,class_validators={},model_config=model.__config__,required=required,default=default)\n                if constrain is not None:\n                        field_info[prop_name].field_info.ge = constrain.get('minimum',None)\n                        field_info[prop_name].field_info.le = constrain.get('maximum',None)\n                        field_info[prop_name].field_info.min_length = constrain.get('minLength',None)\n                        field_info[prop_name].field_info.max_length = constrain.get('maxLength',None)\n                        field_info[prop_name].field_info.regex = constrain.get('regex',None)\n                \n                setattr(model, prop_name, field_info)\n\n                if required:\n                        setattr(model, f\"validate_{prop_name}\", validator(prop_name, pre=True, allow_reuse=True)(lambda v: v))\n                \n                model.__fields__ = field_info\n\n                return model\n",
            "name_column": 12
        },
        "pre_process": {
            "type": "FunctionDef",
            "name": "pre_process",
            "md_content": "**pre_process**\n\nnew_propint\"List[int]\"str\"List[str]\"bool\"List[bool]\"None\"List[null]\"new_prop\n\n****\n- prop\n- type2type\n\n****prop{\"type\": \"array\", \"items\": {\"type\": \"int\"}}pre_processnew_prop{\"type\": \"List[int]\"}",
            "code_start_line": 75,
            "code_end_line": 88,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def pre_process(cls,prop:Dict[str,Any]):\n                new_prop = prop\n                if type2type.get(prop[\"type\"],\"other type\") == list:\n                        item_type = type2type[prop[\"items\"][\"type\"]]\n                        if item_type == int:\n                                new_prop[\"type\"] = \"List[int]\"\n                        elif item_type == str:\n                                new_prop[\"type\"] = \"List[str]\"\n                        elif item_type == bool:\n                                new_prop[\"type\"] = \"List[bool]\"\n                        elif item_type == None:\n                                new_prop[\"type\"] = \"List[null]\"\n\n                return new_prop\n",
            "name_column": 12
        },
        "create_list_item_model": {
            "type": "FunctionDef",
            "name": "create_list_item_model",
            "md_content": "**create_list_item_model**JSON\n\n\n- prop_jsonJSON\n- property_name\n- object_modelPydantic\n\nBaseModelPydanticList[type]\n\n\n- JSON\n- \n  - \"object\"create_object_modelproperty_name+\"_item\"\n  - \"array\"create_list_item_modelproperty_name+\"_arrayItem\"List\n  - \"object\"\"array\"type2typePython\n- \n\n****\n- JSON\"type\"\n- \"array\"JSON\"items\"\n\n****\n- \"object\"BaseModel\n- \"array\"List[type]\n- \"object\"\"array\"Python\n\n\n- Markdown\n- ",
            "code_start_line": 91,
            "code_end_line": 107,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_list_item_model(cls,prop_json:Dict[str,Any],property_name:str)->Union[BaseModel,str]:\n                \"\"\"\n                @param: prop: the property which is a array\n                @param: prop_name: the name of array property\n                @param: object_model: do the inplace replace for pydantic model\n                @return: the pydantic model inherited from BaseModel or a str which describe the List[type]\n                \"\"\"\n                item = None\n                property_json = cls.pre_process(prop_json)\n                if property_json[\"items\"].get(\"type\",\"no type\") == \"object\":\n                        item = cls.create_object_model(property_json[\"items\"],property_name+\"_item\")\n                elif property_json[\"items\"].get(\"type\",\"no type\") == \"array\":\n                        item = cls.create_list_item_model(property_json[\"items\"],property_name+\"_arrayItem\")\n                        item = List[item]\n                else:\n                        item = type2type.get(property_json[\"items\"][\"type\"],str)\n                return item\n",
            "name_column": 12
        },
        "create_multi_types": {
            "type": "FunctionDef",
            "name": "create_multi_types",
            "md_content": "**create_multi_types**\n\n\n- property_name\n- type_listList[Any]\n\n\n\n\n1. new_type_list\n2. enumeratetype_listitp\n3. tptpnew_type_list\n4. tp\"type\"\"type\"\n   - \"type\"\"object\"create_object_modelnew_type_list\n   - \"type\"\"array\"create_list_item_modelnew_type_list\n5. new_type_list\n\n****type_listnew_type_list\n\n****\ntype_list[\"int\", {\"type\": \"object\"}, {\"type\": \"array\"}][int, object, List]",
            "code_start_line": 109,
            "code_end_line": 127,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_multi_types(cls,property_name:str,type_list:List[Any])->List[Any]:\n                \"\"\"\n                @param: type_list: a list of types of prop\n                @return: the list of available type(to be union later)\n                \"\"\"\n                new_type_list = []\n                for i,tp in enumerate(type_list):\n                        if not isinstance(tp,dict):\n                                new_type_list.append(type2type.get(tp,str))\n                        elif \"type\" not in tp.keys():\n                                continue\n                        elif tp[\"type\"] == \"object\":\n                                object_type = cls.create_object_model(tp,property_name + f\"_{i}_type_object\") \n                                new_type_list.append(object_type)\n                        elif tp[\"type\"] == \"array\":\n                                array_type = cls.create_list_item_model(tp,property_name + f\"_{i}_type_array\")\n                                new_type_list.append(List[array_type])\n\n                return new_type_list        \n",
            "name_column": 12
        },
        "create_object_model": {
            "type": "FunctionDef",
            "name": "create_object_model",
            "md_content": "**create_object_model**BaseModel\n\n\n- object_item: \n- object_name: \n- object_model: \n\nBaseModel\n\n\n- object_modelobject_nameBaseModel\n- object_item\"properties\"\n- object_itemJSON\n- create_multi_typesUnionobject_item\"required\"\"default\"\n- Enumobject_item\"required\"\n- create_list_item_modelobject_item\"required\"\n- create_object_modelobject_item\"required\"\n- JSONobject_item\"required\"\n- \n\n****\n- object_item\"properties\"\n- object_item\n- \n- \n- \n\n****\n```python\nobject_model = create_object_model(object_item, object_name, object_model)\n```",
            "code_start_line": 131,
            "code_end_line": 238,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_object_model(cls,object_item:Dict[str,Any],object_name:str,object_model:BaseModel=None)->BaseModel:\n                \"\"\"\n                @param: object_item: the item which is a object(function[parameters]propertyextra_argument[parameters])\n                @param: object_name: the name of object item(for property loc)\n                @return: the object model inherited from BaseModel\n                \"\"\"\n                if object_model is None:\n                        object_model = create_model(object_name,__base__=BaseModel)\n                assert \"properties\" in object_item.keys()\n\n                properties = object_item[\"properties\"]\n                for property_name in properties.keys():\n                        property_json = properties[property_name]\n\n                        if isinstance(property_json[\"type\"],list):\n                                multi_type = cls.create_multi_types(property_name,property_json[\"type\"])\n                                if len(multi_type) > 1:\n                                        multi_type = Union[tuple(multi_type)] # type: ignore\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                                else: \n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=True,default=None)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,multi_type,required=True)\n                        elif \"enum\" in property_json.keys():\n                                enum_name = property_name\n                                enum_values = {value: value for value in property_json['enum']}\n                                enumModel = Enum(enum_name, enum_values)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False)\n\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n                        elif property_json[\"type\"] == \"array\":\n                                item = cls.create_list_item_model(property_json,property_name)\n                                if item is not None:\n                                        if \"required\" in object_item.keys():\n                                                if property_name not in object_item[\"required\"]:\n                                                        if \"default\" in property_json.keys():\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                        else:\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n                                        else:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n\n                        elif property_json[\"type\"] == \"object\" and \"properties\" in property_json.keys():\n                                object_property_model = cls.create_object_model(property_json,property_name)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n\n                        else:   \n                                constrain = \\\n                                {\n                                        \"maxLength\":property_json.get(\"maxLength\",None),\n                                        \"minLength\":property_json.get(\"minLength\",None),\n                                        \"maximum\":property_json.get(\"maximum\",None),\n                                        \"minimum\":property_json.get(\"minimum\",None)        \n                                }\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,constrain=constrain)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,default=None,constrain=constrain)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,constrain=constrain)\n\n                return object_model\n",
            "name_column": 12
        },
        "add_function_model": {
            "type": "FunctionDef",
            "name": "add_function_model",
            "md_content": "**add_function_model**pydantic\n\n\n- extra_arguments_json\n- function_jsonjsonNone\n\n\n1. extra_arguments_jsonextra_arguments\n2. extra_argumentsNoneextra_arguments\"properties\"create_object_modelExtraArgumentModelextra_argumentModel\n3. function_jsonNone\n   - function_jsonfunction\n   - functionparameters\"properties\"create_object_modelArgumentModelargumentModel\n   - create_function_call_modelfunctionCallModel\n   - add_propertyfunctionCallModel\"name\"str{\"regex\":function[\"name\"]}\n   - argumentModelNoneadd_propertyfunctionCallModel\"arguments\"argumentModel\n4. create_total_modeltotalModel\n5. extra_argumentModelNoneadd_propertytotalModel\"arguments\"extra_argumentModel\n6. functionCallModelNoneadd_propertytotalModel\"function_call\"functionCallModel\n7. totalModel\n\n****\n- extra_arguments_jsonfunction_json\n- add_function_modelcreate_object_modelcreate_function_call_modeladd_propertycreate_total_model\n\n****",
            "code_start_line": 241,
            "code_end_line": 267,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def add_function_model(cls,extra_arguments_json:Dict[str,Any],function_json:Dict[str,Any]=None):\n                \"\"\"\n                @param: function: the single function to generate a pydantic model\n                @param: extra_arguments: the extra arguments\n                \"\"\"\n                extra_arguments = copy.deepcopy(extra_arguments_json)\n                extra_argumentModel = None\n                if extra_arguments is not None and \"properties\" in extra_arguments.keys():  \n                        extra_argumentModel = cls.create_object_model(extra_arguments,\"ExtraArgumentModel\",extra_argumentModel)\n                \n                functionCallModel = None\n                if function_json is not None:\n                        function = copy.deepcopy(function_json)\n                        parameters = function[\"parameters\"]\n                        if \"properties\" in parameters.keys():\n                                argumentModel = cls.create_object_model(parameters,\"ArgumentModel\") \n\n                        functionCallModel = cls.create_function_call_model()\n                        functionCallModel = cls.add_property(functionCallModel,\"name\",str,required=True,constrain={\"regex\":function[\"name\"]})\n                        if argumentModel is not None:\n                                functionCallModel = cls.add_property(functionCallModel,\"arguments\",argumentModel,required=True)\n                totalModel = cls.create_total_model()\n                if extra_argumentModel is not None:\n                        totalModel = cls.add_property(totalModel,\"arguments\",extra_argumentModel,required=True)\n                if functionCallModel is not None:\n                        totalModel = cls.add_property(totalModel,\"function_call\",functionCallModel,required=True)\n                return totalModel      \n",
            "name_column": 12
        },
        "create_all_functions_model": {
            "type": "FunctionDef",
            "name": "create_all_functions_model",
            "md_content": "**create_all_functions_model**\n\n\n- extra_argumentsJSON\n- functions\n- function_callJSON\n\nself.functionCallModels\n\nfunctions0add_function_modelself.functionCallModels\n\nfunction_call\"name\"\"name\"add_function_modelself.functionCallModels\n\nadd_function_modelself.functionCallModels\n\n****\n- FunctionParser\n- \n\n****\n```\n[\n    {\n        \"name\": \"function1\",\n        \"arguments\": {\n            \"arg1\": \"value1\",\n            \"arg2\": \"value2\"\n        }\n    },\n    {\n        \"name\": \"function2\",\n        \"arguments\": {\n            \"arg3\": \"value3\",\n            \"arg4\": \"value4\"\n        }\n    }\n]\n```",
            "code_start_line": 270,
            "code_end_line": 286,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_all_functions_model(self,extra_arguments:Dict[str,Any]=None,functions:list=None,function_call:Dict[str,Any]=None):\n                \"\"\"\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call\n                \"\"\" \n                self.functionCallModels = []\n                if  functions is None or len(functions)==0:\n                        self.functionCallModels.append(self.add_function_model(extra_arguments))\n                        return\n                for function in functions:\n                        if function_call is not None and \"name\" in function_call.keys():\n                                if  function_call[\"name\"] == function[\"name\"]:\n                                        self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n                                        return\n                        else:\n                                self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n",
            "name_column": 12
        },
        "models_to_regex": {
            "type": "FunctionDef",
            "name": "models_to_regex",
            "md_content": "**models_to_regex**\n\nFunctionParserfunctionCallModelsfunctionmodel_json_schemaJSONmodel_json_schemaschema\n\nJSONregex_strsregex_strs\n\n****FunctionParserfunctionCallModels\n\n****functionCallModelsfunctionJSONregex_strs\n```\n['{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}, \"age\": {\"type\": \"number\"}}}', '{\"type\": \"object\", \"properties\": {\"title\": {\"type\": \"string\"}, \"content\": {\"type\": \"string\"}}}']\n```",
            "code_start_line": 289,
            "code_end_line": 300,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def models_to_regex(self):\n                self.regex_strs = []\n                for function in self.functionCallModels:\n                    if hasattr(function, \"model_json_schema\"):\n                        json_schema = function.model_json_schema()\n                    else: \n                        json_schema = function.schema()\n\n                    json_schema = self.post_process(json_schema)\n                    schema = json.dumps(json_schema)\n                    self.regex_strs.append(build_regex_from_object(schema))\n                return self.regex_strs\n",
            "name_column": 12
        },
        "context_ids_next_ids": {
            "type": "FunctionDef",
            "name": "context_ids_next_ids",
            "md_content": "**context_ids_next_ids**idtokenid\n\n\n- pstates\n- traceback\n- logits1\n- create_proposallogitsidlogits\n- Python\n- logits\"no available path\"\n- \n\n****\n- pstates\n- context_idsid\n- tokenid\n\n****\n```python\n[1, 3, 5, 7]\n```",
            "code_start_line": 303,
            "code_end_line": 322,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def context_ids_next_ids(self,context_ids:List[int]):\n                \"\"\"\n                @param: context_ids: the ids of generated tokens (list[list[int]])\n                @return: valid_ids: the valid ids of next token (list[list[int]])\n                \"\"\"\n                # you should empty the pstates every times except you input all context in order)\n                self.generator.pstates = []\n                import traceback\n                logits = torch.ones(len(self.model.tokenizer.vocabulary)).to(self.model.device)\n                # masked_logits \n                try:\n                        masked_logits = self.generator.create_proposal(torch.tensor([context_ids]).to(self.model.device), logits)\n                        # valid indexes\n                        non_inf_indices = torch.nonzero(masked_logits != -math.inf).squeeze(dim=1)\n                        non_inf_indices = non_inf_indices[:,1]\n                        non_inf_indices = non_inf_indices.tolist()\n                except Exception as e:\n                        print(\"no available path\")\n                        non_inf_indices = []\n                return non_inf_indices\n",
            "name_column": 12
        },
        "post_process": {
            "type": "FunctionDef",
            "name": "post_process",
            "md_content": "**post_process**schema\n\nschemacom_schemacom_schema\"definitions\"\"type\"\"string\"\n\ncom_schema\n\n****\n- schema\n- schema\"type\"\"string\"\n\n****schema\n```json\n{\n  \"definitions\": {\n    \"prop1\": {},\n    \"prop2\": {}\n  }\n}\n```\nschema\n```json\n{\n  \"definitions\": {\n    \"prop1\": {\n      \"type\": \"string\"\n    },\n    \"prop2\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```",
            "code_start_line": 325,
            "code_end_line": 332,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def post_process(self,schema):   \n                com_schema = schema\n                if \"definitions\" in com_schema.keys():\n                        for prop in com_schema[\"definitions\"].keys():\n                                if \"type\" not in com_schema[\"definitions\"][prop].keys():\n                                        com_schema[\"definitions\"][prop][\"type\"]=\"string\"\n                \n                return com_schema\n",
            "name_column": 12
        },
        "create_generator": {
            "type": "FunctionDef",
            "name": "create_generator",
            "md_content": "**create_generator**\n\n\n- model: transformer\n- function_info: \n- generate_params: \n\n\n\nfunction_infocreate_all_functions_modelregex_listself.modelgenerate.multi_regextokenself.generator\n\n****\n- modeltransformer\n- function_info\n- generate_params\n\n****",
            "code_start_line": 334,
            "code_end_line": 352,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_generator(self,model:models.XTransformers,function_info:Dict[str,Any],generate_params:Dict = {}):\n                \"\"\"\n                @param: model: the transformer model\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call name\n                @param: generate_params: a dict of inference constraint arguments\n                @return: create a generator for guided generate\n                \"\"\"    \n                extra_arguments = function_info.get(\"arguments\",None)\n                functions = function_info.get(\"functions\",None)\n                function_call = function_info.get(\"function_call\",None)\n                self.create_all_functions_model(extra_arguments,functions,function_call) \n                regex_list = self.models_to_regex()\n                self.model = model\n                # temperature and so on\n                self.model.add_logits_processor(generate_params)\n                self.generator = generate.multi_regex(self.model, regex_list,generate_params.get(\"max_tokens\"))\n                return self.generator\n",
            "name_column": 12
        },
        "check": {
            "type": "FunctionDef",
            "name": "check",
            "md_content": "**check**call_info\n\ncall_infocall_infoJSONFalseJSON\"name\"\"arguments\"Falseself.functionCallModel.model_validate_jsoncall_infoFalseTrue\n\n****call_infoJSON\n\n****False",
            "code_start_line": 354,
            "code_end_line": 370,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def check(self,call_info:str):\n                \"\"\"\n                @param: function: the dynamic BaseModel generated for specified function\n                \"\"\"\n                try:\n                        call_info_json = json.loads(call_info)\n                except Exception:\n                        return False\n                if \"name\" not in call_info_json.keys():\n                        return False\n                if \"arguments\" not in call_info_json.keys():\n                        return False\n                try:\n                        self.functionCallModel.model_validate_json(call_info)\n                except Exception:\n                        return False\n                return True\n",
            "name_column": 12
        },
        "TotalModel": {
            "type": "ClassDef",
            "name": "TotalModel",
            "md_content": "**TotalModel**XXX\n\nXAgentGen/xgen/parser/function_parser.pycreate_total_model\n\n```python\ndef create_total_model(cls):\n    class TotalModel(BaseModel):\n        pass\n    return TotalModel\n```\n\n****BaseModel\n\n\n- XAgentGen/xgen/parser/function_parser.pycreate_total_modelTotalModel\n\n\n- \n- ",
            "code_start_line": 44,
            "code_end_line": 45,
            "parent": "create_total_model",
            "have_return": false,
            "code_content": "                class TotalModel(BaseModel):\n                        pass\n",
            "name_column": 22
        },
        "FunctionCallModel": {
            "type": "ClassDef",
            "name": "FunctionCallModel",
            "md_content": "**FunctionCallModel**name\n\nname\n\n****\n- name",
            "code_start_line": 50,
            "code_end_line": 51,
            "parent": "create_function_call_model",
            "have_return": false,
            "code_content": "                class FunctionCallModel(BaseModel):\n                        name:str\n",
            "name_column": 22
        }
    },
    "XAgentGen/xgen/parser/__init__.py": {},
    "XAgentGen/xgen/text/generate/__init__.py": {},
    "XAgentGen/xgen/text/generate/regex.py": {
        "to_hash": {
            "type": "FunctionDef",
            "name": "to_hash",
            "md_content": "**to_hash**vocabularyregex_streos_token\n\n\n- vocabulary\n- regex_str\n- eos_token\n\nf-stringvocabularyregex_streos_tokenhash\n\n\n\n****vocabularyregex_str\n\n****[\"apple\", \"banana\", \"orange\"], \"[a-z]+\", \"<eos>\"-123456789",
            "code_start_line": 15,
            "code_end_line": 17,
            "parent": null,
            "have_return": true,
            "code_content": "def to_hash(vocabulary, regex_str, eos_token):\n    string = f\"vocabulary:{''.join(vocabulary)}, regex: {regex_str}, eos_token: {eos_token}\"\n    return hash(string)\n",
            "name_column": 4
        },
        "XRegex": {
            "type": "ClassDef",
            "name": "XRegex",
            "md_content": "**XRegex**\n\n`Regex`\n- `model`\n- `regex_string`\n- `max_tokens`\n- `sampler``sampler`\n- `stop`\n- `allow_empty_tokens`token\n- `initial_state`\n- `final_states`\n- `states_to_token_maps`token\n- `empty_token_ids`tokenid\n\n`model.tokenizer.vocabulary``to_hash`\n\n`pstate_to_vocab_path_cache`tokentokenid`interegular.parse_pattern``make_deterministic_fsm``reduce``create_fsm_index_tokenizer`tokentokenidtokentokenid`pstate_to_vocab_path_cache`\n\n`Regex`\n\n****`XRegex``multi_regex`",
            "code_start_line": 19,
            "code_end_line": 61,
            "parent": null,
            "have_return": false,
            "code_content": "class XRegex(Regex):\n    def __init__(\n        self,\n        model,\n        regex_string: str,\n        max_tokens: Optional[int] = None,\n        *,\n        sampler: Optional[\"Sampler\"] = None,\n        stop: Union[str, List[str]] = [],\n        allow_empty_tokens: bool = True,\n        initial_state: Optional[int] = None,\n        final_states: Optional[Set[int]] = None,\n        states_to_token_maps: Optional[Dict[int, Dict[int, int]]] = None,\n        empty_token_ids: Optional[Set[int]] = None,\n    ):\n        \n        vocab = model.tokenizer.vocabulary\n        sorted_vocabulary = [\n            model.tokenizer.convert_token_to_string(k)\n            for k, v in sorted(vocab.items(), key=lambda kv: kv[1])\n        ]\n        hash_key = to_hash(list(sorted_vocabulary), regex_string, model.tokenizer.eos_token)\n\n        if hash_key in pstate_to_vocab_path_cache:\n            regex_fsm,states_to_token_maps,empty_token_ids = pstate_to_vocab_path_cache[hash_key]\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n        else:\n            regex_pattern = interegular.parse_pattern(regex_string)\n            regex_fsm, _ = make_deterministic_fsm(regex_pattern.to_fsm().reduce())\n            (\n                states_to_token_maps,\n                empty_token_ids,\n            ) = create_fsm_index_tokenizer(regex_fsm, model.tokenizer)\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n            \n            pstate_to_vocab_path_cache[hash_key] = (regex_fsm,states_to_token_maps,empty_token_ids)\n\n        super().__init__(\n            model, regex_string, max_tokens, sampler=sampler,stop=stop,\n            allow_empty_tokens=allow_empty_tokens,initial_state=initial_state,final_states=final_states,\n            states_to_token_maps=states_to_token_maps,empty_token_ids=empty_token_ids)\n",
            "name_column": 6
        },
        "multi_regex": {
            "type": "FunctionDef",
            "name": "multi_regex",
            "md_content": "**multi_regex**\n\n\n- model: \n- choices: \n- max_tokens: \n- sampler: \n- allow_empty_tokens: \n\nXRegex\n\n****\n- model\n- choices\n- max_tokens\n- sampler\n\n****choices[\"abc\", \"def\", \"ghi\"]max_tokens10XRegex\n- model: \n- regex_str: \"(abc|def|ghi)\"\n- max_tokens: max_tokens\n- sampler: \n- allow_empty_tokens: allow_empty_tokens",
            "code_start_line": 63,
            "code_end_line": 78,
            "parent": null,
            "have_return": true,
            "code_content": "def multi_regex(\n    model,\n    choices: List[str],\n    max_tokens: Optional[int] = None,\n    *,\n    sampler: Optional[\"Sampler\"] = None,\n    allow_empty_tokens: bool = True,\n):\n    regex_str = r\"(\" + r\"|\".join(choices) + r\")\"\n    return XRegex(\n        model,\n        regex_str,\n        max_tokens,\n        sampler=sampler,\n        allow_empty_tokens=allow_empty_tokens,\n    )\n",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__**\n\nIDIDID\n\n__init__ID\n\n****\n- \n- ID\n- ID\n- ",
            "code_start_line": 20,
            "code_end_line": 61,
            "parent": "XRegex",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        model,\n        regex_string: str,\n        max_tokens: Optional[int] = None,\n        *,\n        sampler: Optional[\"Sampler\"] = None,\n        stop: Union[str, List[str]] = [],\n        allow_empty_tokens: bool = True,\n        initial_state: Optional[int] = None,\n        final_states: Optional[Set[int]] = None,\n        states_to_token_maps: Optional[Dict[int, Dict[int, int]]] = None,\n        empty_token_ids: Optional[Set[int]] = None,\n    ):\n        \n        vocab = model.tokenizer.vocabulary\n        sorted_vocabulary = [\n            model.tokenizer.convert_token_to_string(k)\n            for k, v in sorted(vocab.items(), key=lambda kv: kv[1])\n        ]\n        hash_key = to_hash(list(sorted_vocabulary), regex_string, model.tokenizer.eos_token)\n\n        if hash_key in pstate_to_vocab_path_cache:\n            regex_fsm,states_to_token_maps,empty_token_ids = pstate_to_vocab_path_cache[hash_key]\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n        else:\n            regex_pattern = interegular.parse_pattern(regex_string)\n            regex_fsm, _ = make_deterministic_fsm(regex_pattern.to_fsm().reduce())\n            (\n                states_to_token_maps,\n                empty_token_ids,\n            ) = create_fsm_index_tokenizer(regex_fsm, model.tokenizer)\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n            \n            pstate_to_vocab_path_cache[hash_key] = (regex_fsm,states_to_token_maps,empty_token_ids)\n\n        super().__init__(\n            model, regex_string, max_tokens, sampler=sampler,stop=stop,\n            allow_empty_tokens=allow_empty_tokens,initial_state=initial_state,final_states=final_states,\n            states_to_token_maps=states_to_token_maps,empty_token_ids=empty_token_ids)\n",
            "name_column": 8
        }
    }
}